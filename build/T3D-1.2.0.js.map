{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/LocalReader/ArchiveParser.js","src/LocalReader/DataReader.js","src/LocalReader/FileTypes.js","src/LocalReader/LocalReader.js","src/LocalReader/PersistantStore.js","src/Logger.js","src/MapFileList.js","src/T3DLib.js","src/dataRenderer/DataRenderer.js","src/dataRenderer/EnvironmentRenderer.js","src/dataRenderer/HavokRenderer.js","src/dataRenderer/PropertiesRenderer.js","src/dataRenderer/SingleModelRenderer.js","src/dataRenderer/StringRenderer.js","src/dataRenderer/TerrainRenderer.js","src/dataRenderer/ZoneRenderer.js","src/format/file/GW2Chunk.js","src/format/file/GW2File.js","src/util/Constants.js","src/util/MapEnvUtils.js","src/util/MapHavokUtils.js","src/util/MapPropsUtils.js","src/util/MapTerrainUtils.js","src/util/MapZoneUtils.js","src/util/MaterialUtils.js","src/util/MathUtils.js","src/util/ModelUtils.js","src/util/ParserUtils.js","src/util/RenderUtils.js","src/util/TerrainShader.js"],"names":["f","exports","module","define","amd","window","global","self","this","T3D","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","1","MathUtils","parseANDatHeader","ds","header","version","readUint8","magic","readString","headerSize","readUint32","seek","position","chunkSize","crc","mftOffset","arr32To64","mftSize","flags","Logger","log","TYPE_DEBUG","TYPE_ERROR","parseMFTTable","nbOfEntries","fullTable","item","readUint16","table","mftIndexOffset","offset","mftIndexSize","size","parseMFTIndex","indexTable","id","mftIndex","getFilePart","file","Promise","resolve","reject","reader","FileReader","onerror","onload","fileEvent","buffer","target","result","DataStream","endianness","LITTLE_ENDIAN","len","readAsArrayBuffer","slice","readArchive","async","archiveHeader","mftData","metaTable","DataReader","[object Object]","settings","_settings","_workerPool","_workerLoad","_handleCounter","_workQueue","_handleRegister","workersNb","_startWorker","workerPath","mftId","isImage","capLength","arrayBuffer","byteLength","TYPE_WARNING","push","freeWorkerIndex","_getFreeWorkerIndex","_workNext","workerId","workData","shift","handle","_getNewHandle","postMessage","path","_id","selfWorkerId","worker","Worker","onmessage","messageEvent","answer","data","handleID","split","handleData","dxtType","imageWidth","imageHeight","_","terminate","indexOf","GW2File","FileTypes","getFileType","first4","readCString","type","ArchiveParser","PersistantStore","MapFileList","LocalReader","_dataReader","_persistantStore","undefined","_file","_indexTable","_fileMetaTable","noIndexedDB","baseId","raw","fileLength","extractLength","isBaseId","getFileIndex","meta","getFileMeta","compressed","inflate","then","catch","oldFileList","persistantId","persistantList","lastListing","getLastListing","name","array","complete","key","iterateList","Object","keys","map","Number","index","taskArray","task","persistantNeedsUpdate","_needsScan","scan","taskId","race","readFileType","scanResult","fileType","change","Math","floor","TYPE_PROGRESS","putListing","res","all","_persistantData","getFileList","mapArray","reversedIndex","getReverseIndex","maps","filter","found","category","fileMap","find","fileName","toString","mapEntry","typeList","reverseBaseIdList","fileList","baseIds","baseIdList","reduce","reversed","searchAll","callback","restoreOuput","returnArray","elt","findIndex","sort","j","readFileList","getMapList","returnObj","fileEntry","readFile","persistantData","metaData","_fileTypeCache","fileBuffer","min","DB_VERSION","_dbConnection","_getConnection","request","indexedDB","open","onblocked","event","onupgradeneeded","db","currentVersion","oldVersion","createObjectStore","autoIncrement","currentTarget","transaction","objectStore","createIndex","unique","onsuccess","isReady","listing","isComplete","store","put","filename","openCursor","IDBKeyRange","only","cursor","value","primaryKey","TYPE_MESSAGE","logFunctions","Array","arguments","argArr","argsToArr","unshift","severity","max","apply","args","console","error","warn","debug","t3dtoolsWorker","concurrentTasks","navigator","hardwareConcurrency","GW2Chunk","DataRenderer","EnvironmentRenderer","HavokRenderer","PropertiesRenderer","SingleModelRenderer","TerrainRenderer","ZoneRenderer","StringRenderer","MaterialUtils","ParserUtils","RenderUtils","getLocalReader","lrInstance","openArchive","getFileListAsync","localReader","getMapListAsync","renderMapContentsAsync","renderers","logger","context","parseInt","mapFile","runAllRenderers","runRenderer","renderClass","assign","bind","RenderClass","cb","renderAsync","getContextValue","clazz","propName","defaultValue","output","hasWebGL","returnContext","WebGLRenderingContext","canvas","document","createElement","names","getContext","getParameter","gl","numErrors","THREE","checkRequirements","constructor","otherClass","inflatedData","getOutput","fileId","rawData","uarr","Uint8Array","textDecoder","TextDecoder","rawString","decode","image","width","height","MapEnvUtils","super","environmentChunkData","getChunk","parameterChunkData","hazeColor","getHazeColor","hazeColorAsInt","lightData","parseLights","hasLight","lights","skyElements","parseSkybox","MapHavokUtils","lastP","seed","meshes","havokChunkData","boundingBox","boundsMax","propModels","zoneModels","obsModels","mdl","scale","geometries","animations","renderZoneModelsCB","renderModels","models","title","currentOutput","concat","MapPropsUtils","propertiesChunkData","props","propArray","animProps","propAnimArray","instanceProps","propInstanceArray","metaProps","propMetaArray","renderIndex","getIdsForProp","ModelUtils","meshCache","getMeshesForFilename","isCached","boundingSphere","forEach","mesh","strings","end","entryHeaderDef","entryIndex","entry","readStruct","decryptionOffset","bitsPerSymbol","readUCS2String","recid","language","MapTerrainUtils","pagedImageId","materials","pagedImage","loadPagedImageCallback","anisotropy","terrainResult","terrainTiles","water","bounds","mapRect","getTerrainFilesId","MapZoneUtils","zoneChunkData","rect","zones","zoneArray","zoneDefs","zoneDefArray","lastPct","dataForUtils","stepZone","pct","round","renderZone","HEAD_STRUCT","DUPLICATE_SETTINGS","PACKTOCHUNK","pack","chunk","root","addr","setting","regex","RegExp","chunkDef","formats","v","defsIdx","defs","versions","getRootName","pop","match","Definition","__root","genDuplicateSettings","headerLength","NaN","loadHead","useNthIndex","fileTypes","defsFound","chunkVersion","def","getDefinition","chunkDataSize","Chunk","noChunks","chunks","readHead","readChunks","ch","loadData","next","toLowerCase","fvfFormat","Position","Weights","Group","Normal","Color","Tangent","Bitangent","TangentFrame","UV32Mask","UV16Mask","Unknown1","Unknown2","Unknown3","Unknown4","PositionCompressed","Unknown5","getMat","tex","MeshBasicMaterial","side","BackSide","fog","depthWrite","loadTextureWithFallback","targetMatIndices","materialArray","fallbackFilename","writeMat","mat","loadFallback","TextureLoader","load","loadLocalTexture","setTimeout","hazes","dataGlobal","haze","farColor","ambientLight","lightOutput","lighting","backlightIntensity","backlightColor","idx","light","sumDirLightIntensity","dirLightData","color","directionalLight","DirectionalLight","getHex","intensity","set","direction","normalize","directions","lightDir","AmbientLight","ambientTotal","g","b","skyboxFallbackArray","skyModeTex","texPathNE","texPathSW","texPathT","mapW","abs","x1","x2","mapD","y1","y2","visible","skyGeometry","BoxGeometry","boxSize","faceVertexUvs","vecs","face","vec2","x","y","uvsNeedUpdate","skyBox","Mesh","translateY","getCollisionsForAnimation","animation","collisions","ret","collisionIndices","collision","animationFromGeomIndex","propGeomIndex","l","renderMesh","rendererData","model","pos","translate","rot","rotate","clone","geom","Geometry","vertices","Vector3","indices","f1","f2","f3","faces","Face3","computeFaceNormals","parseHavokMesh","rotation","order","parseAllModels","geometryIndex","MeshNormalMaterial","DoubleSide","propsArray","textureCache","pctStr","prop","addMeshToLOD","groups","lod","needsClone","lodDist","lod2","lodOverride","geometry","material","updateMatrix","matrixAutoUpdate","add","group","addLevel","meshArray","LOD","maxDist","boundingSphereRadius","radius","transforms","transform","update","addMeshesToScene","fileIds","getFilesUsedByModel","propFileIds","TerrainShader","inflatedBuffer","envOutput","pimgDS","pimgTableDataChunk","pimgData","terrainData","parameterData","maxAnisotropy","numChunksD_1","sqrt","dims","chunkArray","numChunksD_2","parseNumChunks","xChunks","yChunks","allMaterials","allTextures","texFileArray","dx","dy","cdx","cdy","allMats","customMaterial","MeshLambertMaterial","flatShading","chunkTextures","strippedPages","page","layer","coord","matName","chunkTex","wrapS","RepeatWrapping","wrapT","renderChunk","cx","cy","chunkIndex","pageX","pageY","chunkTextureIndices","loResMaterial","texIndexArray","pageOffetX","pageOffetY","fileNames","gi","textureFileName","pageTexName","pageTexName2","near","far","uniforms","UniformsUtils","merge","UniformsLib","uvScale","Vector2","texturePicker","texturePicker2","texture1","texture2","texture3","texture4","ShaderMaterial","fragmentShader","getFragmentShader","vertexShader","getVertexShader","chunkGeo","PlaneBufferGeometry","chunkW","cn","getAttribute","heightMapArray","mS","Matrix4","identity","elements","applyMatrix","SceneUtils","createMultiMaterialObject","PI","globalOffsetX","chunkOffsetX","globalOffsetY","chunkOffsetY","z","px","py","updateMatrixWorld","wireframe","opacity","transparent","renderRect","drawWater","terrainChunk","texture","zone","renderZoneCallback","zoneDef","zd","token","defToken","modelGroups","mapX","mapY","zoneRect","vertRect","encodeData","zdx","linearPos","flag","zoneDefLayer","layerDefArray","modelX","modelY","modelZ","startZ","raycaster","Raycaster","intersections","intersectObject","distance","modelIdx","modelArray","modelFilename","rotRangeX","rotRangeY","rotRangeZ","scaleRange","fadeRange","getModelGroups","groupKeys","stepModels","meshGroups","instanceIdx","meshIdx","materialFlags","move","mg","readVerts","verts","Float32Array","readIndices","getIndex","Uint32Array","readUVs","uvs","readNormals","normals","writeVerts","stride","writeIndices","strideIndices","writeUvs","uvStride","writeNormals","normalStride","meshGroup","mergedGeom","BufferGeometry","addAttribute","BufferAttribute","setIndex","buffersNeedUpdate","buildVS","numUv","vdefs","adefs","reads","generateDataTexture","DataTexture","RGBAFormat","buildPS","textures","alphaTest","lightMap","t1uv","uvIdx","discard","writeColor","varyings","getUVMat","numUV","attributes","vs","FrontSide","getTexture","texURL","sharedTextures","finalTexture","flipY","mapping","defaultColor","random","minFilter","LinearMipMapLinearFilter","magFilter","LinearFilter","generateMipmaps","format","needsUpdate","getMaterial","materialFile","dxChunk","grChunk","finalMaterial","finalTextures","effect","techniques","passes","effects","samplerTextures","samplerIndex","samplerIdx","sampler","samplers","textureToken","texTokens","textureIndex","samplerTex","uvPSInputIndex","ft","nt","MeshPhongMaterial","normalMap","textureFilename","shading","FlatShading","alphaMask0","alphaMask1","lightMask","base32Max","pow","f16","h","s","Infinity","popcount","bits","arr","sort_unique","arr_in","comparator","prototype","hasOwnProperty","matFiles","renderGeomChunk","modelDataChunk","showUnmaterialed","rawMeshes","mats","permutations","rawMesh","rawGeom","fvf","numVerts","vertexCount","rawVerts","vertDS","distToUV","uv32Flag","uv16Flag","isUV32","hasUV","masked","readFloat32","Uint16Array","computeVertexNormals","uvName","materialIndex","finalMesh","materialFilename","materialName","numLods","lods","sharedMeshes","hideLOD","solidColor","finalMeshes","modelFile","geometryDataChunk","bsc","center","loadMaterialIndex","mIdx","matCallback","texMask","loadMeshFromModelFile","matFileName","getArrayReader","structDef","maxCount","struct","arrLen","arrPtr","readType","getRefArrayReader","retArr","orgPos","offsets","readInt32Array","pointer","getQWordReader","getStringReader","ptr","getString16Reader","stringOffset","num","String","fromCharCode","getPointerReader","getFileNameReader","fileRef","m_highPart","m_lowPart","yPos","dz","cz","plane","overdraw","ShaderChunk","join"],"mappings":"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","file":"T3D-1.2.0.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst MathUtils = require(\"../util/MathUtils\");\n\n/**\n * @file The ArchiveParser module is a set of helper tools to correctly read the Archive.\n * @namespace ArchiveParser\n */\n\n/**\n *    All in one function to read a GW2.dat file and parse all the needed informations to work with it\n *\n * @memberof ArchiveParser\n * @param {File} file\n * @returns {Promise<{archiveHeader: ArchiveHeader, metaTable: MetaTable, indexTable: IndexTable}>}\n */\nasync function readArchive(file) {\n  let archiveHeader = parseANDatHeader((await getFilePart(file, 0, 40)).ds);\n  let mftData = parseMFTTable(\n    (await getFilePart(file, archiveHeader.mftOffset, archiveHeader.mftSize)).ds\n  );\n  let { ds, len } = await getFilePart(\n    file,\n    mftData.mftIndexOffset,\n    mftData.mftIndexSize\n  );\n  let indexTable = parseMFTIndex(ds, len);\n\n  return {\n    archiveHeader: archiveHeader,\n    metaTable: mftData.table,\n    indexTable: indexTable\n  };\n}\n\n/**\n * The header of the archive.\n * @typedef {Object} ArchiveHeader\n * @property {number} version\n * @property {number} magic\n * @property {number} headerSize\n * @property {number} chunkSize\n * @property {number} crc\n * @property {number} mftOffset\n * @property {number} mftSize\n * @property {number} flags\n */\n\n/**\n *   Parse the main information about the archive like format version, positions of information tables, crc etc...\n *\n * @memberof ArchiveParser\n * @param {DataStream} ds\n * @returns {ArchiveIndex} Returns undefined if the header couldn't be parsed\n */\nfunction parseANDatHeader(ds) {\n  let header = {};\n\n  // Header parsing\n  header.version = ds.readUint8();\n  header.magic = ds.readString(3);\n  header.headerSize = ds.readUint32();\n  ds.seek(ds.position + 4); // Skip uint32\n  header.chunkSize = ds.readUint32();\n  header.crc = ds.readUint32();\n  ds.seek(ds.position + 4); // Skip uint32\n  header.mftOffset = MathUtils.arr32To64([ds.readUint32(), ds.readUint32()]);\n  header.mftSize = ds.readUint32();\n  header.flags = ds.readUint32();\n  // End header parsing\n\n  // Check MAGIC\n  if (header.magic !== \"AN\\u001A\") {\n    T3D.Logger.log(\n      T3D.Logger.TYPE_ERROR,\n      \"ANDat header is not valid\",\n      header.magic\n    );\n    return undefined;\n  }\n\n  T3D.Logger.log(T3D.Logger.TYPE_DEBUG, \"Loaded Main .dat header\");\n\n  return header;\n}\n\n/**\n * The array containing all the meta information concerning the contained files\n * @typedef {Array<{offset: number, size: number, compressed: number, crc: number}>} MetaTable\n */\n\n/**\n *   Parse the main information table that contains the offset, size, compression flags and crc\n *\n * @memberof ArchiveParser\n * @param {Datastream}  ds\n * @returns {{header: {magic: String, nbOfEntries: number}, table: MetaTable, mftIndexOffset: number, mftIndexSize: number}|undefined}\n *   Returns undefined if it couldn't parse the table\n */\nfunction parseMFTTable(ds) {\n  // Parse the table header\n  let header = {};\n  header.magic = ds.readString(4);\n  ds.seek(ds.position + 8); // Skip uint64\n  header.nbOfEntries = ds.readUint32();\n  ds.seek(ds.position + 4 + 4); // Skip uint32 * 2\n\n  // check MAGIC\n  if (header.magic !== \"Mft\\u001A\") {\n    T3D.Logger.log(\n      T3D.Logger.TYPE_ERROR,\n      \"MFTTable header is not valid\",\n      header.magic\n    );\n    return undefined;\n  }\n\n  // Where we put all the parsed data\n  // We don't pre-alloc anymore since not having the data aligned together procs too many\n  // cache misses during a fullscan\n  let fullTable = [];\n\n  // Go through the table\n  for (let i = 1; i < header.nbOfEntries; i++) {\n    let item = {};\n    item[\"offset\"] = MathUtils.arr32To64([ds.readUint32(), ds.readUint32()]);\n    item[\"size\"] = ds.readUint32();\n    item[\"compressed\"] = ds.readUint16();\n    ds.seek(ds.position + 4 + 2); // Skip uint16 + uint32\n    item[\"crc\"] = ds.readUint32();\n    fullTable[i] = item;\n  }\n\n  T3D.Logger.log(T3D.Logger.TYPE_DEBUG, \"Loaded MFTTable\");\n\n  return {\n    header: header,\n    table: fullTable,\n    // Register the MFTIndex table position and size\n    mftIndexOffset: fullTable[2].offset,\n    mftIndexSize: fullTable[2].size\n  };\n}\n\n/**\n * The array linking all the file indexes to their respective files\n * @typedef {Array<number>} IndexTable\n */\n\n/**\n *   This function used to be much more complex with the use of\n *   a \"fileId\" which in the end was just the equivalent of\n *   MFTbaseIds[mftId].sort().reverse()[0] (aka the bigger baseId found)\n *\n * @memberof ArchiveParser\n * @param {DataStream} ds\n * @param {number} size\n * @returns {IndexTable}\n */\nfunction parseMFTIndex(ds, size) {\n  let length = size / 8;\n\n  let indexTable = [];\n\n  for (let i = 0; i < length; i++) {\n    // Parse table\n    let id = ds.readUint32();\n    let mftIndex = ds.readUint32();\n    // Store the values\n    indexTable[id] = mftIndex;\n  }\n\n  T3D.Logger.log(T3D.Logger.TYPE_DEBUG, \"Finished indexing MFT\");\n\n  return indexTable;\n}\n\n/**\n *   Get a chunk of the specified file. Used mainly to take parts of the Archive before parsing.\n *\n * @memberof ArchiveParser\n * @param {File} file\n * @param {number} offset\n * @param {number} length\n * @returns {Promise<{ds: DataStream, len: number}>}\n */\nfunction getFilePart(file, offset, length) {\n  return new Promise((resolve, reject) => {\n    let reader = new FileReader();\n\n    reader.onerror = reject;\n\n    reader.onload = fileEvent => {\n      let buffer = fileEvent.target.result;\n      let ds = new DataStream(buffer);\n      ds.endianness = DataStream.LITTLE_ENDIAN;\n      // Pass data stream and data length to callback function\n      resolve({\n        ds: ds,\n        len: length\n      });\n    };\n\n    // Slicing a File is just reducing the scope of the ArrayBuffer, but doesn't load anything in memory.\n    reader.readAsArrayBuffer(file.slice(offset, offset + length));\n  });\n}\n\nmodule.exports = {\n  readArchive: readArchive,\n  parseANDatHeader: parseANDatHeader,\n  parseMFTTable: parseMFTTable,\n  parseMFTIndex: parseMFTIndex,\n  getFilePart: getFilePart\n};\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * Organized thread pool of extractors\n * @class DataReader\n */\nclass DataReader {\n  /**\n   * @constructor\n   * @param {Object} settings\n   * @param {number} settings.workersNb Amount of concurrent spawned workers\n   * @param {string} settings.workerPath Path to the worker script\n   */\n  constructor(settings) {\n    this._settings = settings;\n    this._workerPool = [];\n    this._workerLoad = [];\n\n    // Makes individual ids for file extraction\n    this._handleCounter = 0;\n\n    /**\n     * Work to be processed\n     * @private\n     * @type {[{buffer: ArrayBuffer, size: number, mftId: number, isImage: boolean, capLength: number, resolve: function, reject: function}]}\n     */\n    this._workQueue = [];\n\n    /**\n     * Work currently processed\n     * @private\n     * Entries : {mftId: number, workerId: number, resolve: resolve, reject: reject}\n     */\n    this._handleRegister = {};\n\n    for (let i = 0; i < settings.workersNb; i++) {\n      this._startWorker(settings.workerPath);\n    }\n  }\n\n  /**\n   * @param {DataStream} ds\n   * @param {number} size\n   * @param {number} mftId\n   * @param {boolean} [isImage] Parses the output as a dxt texture\n   * @param {number} [capLength] Output size\n   * @returns {Promise<{buffer: ArrayBuffer, dxtType: number, imageWidth: number, imageHeight: number}>}\n   */\n  inflate(ds, size, mftId, isImage, capLength) {\n    return new Promise((resolve, reject) => {\n      let arrayBuffer = ds.buffer;\n\n      // If no capLength then inflate the whole file\n      if (!capLength || capLength < 0) {\n        capLength = 0;\n      }\n\n      // Buffer length size check\n      if (arrayBuffer.byteLength < 12) {\n        T3D.Logger.log(\n          T3D.Logger.TYPE_WARNING,\n          `not inflating, length is too short (${arrayBuffer.byteLength})`,\n          mftId\n        );\n        reject(new Error(\"Couldn't inflate \" + mftId + \" (mftId)\"));\n        return;\n      }\n\n      // Register the data to work with\n      this._workQueue.push({\n        buffer: arrayBuffer,\n        size: size,\n        mftId: mftId,\n        isImage: isImage,\n        capLength: capLength,\n        resolve: resolve,\n        reject: reject\n      });\n\n      // Check if there is a free worker and ask it to start\n      const freeWorkerIndex = this._getFreeWorkerIndex();\n      if (freeWorkerIndex >= 0) {\n        this._workNext(freeWorkerIndex);\n      }\n    });\n  }\n\n  /**\n   * Function used to give work to a worker\n   * @private\n   * @param {number} workerId\n   **/\n  _workNext(workerId) {\n    const workData = this._workQueue.shift();\n\n    if (workData) {\n      // Get a handleID\n      const handle = this._getNewHandle();\n\n      this._handleRegister[handle] = {\n        mftId: workData.mftId,\n        workerId: workerId,\n        resolve: workData.resolve,\n        reject: workData.reject\n      };\n\n      this._workerLoad[workerId] += 1;\n      this._workerPool[workerId].postMessage([\n        handle,\n        workData.buffer,\n        workData.isImage === true,\n        workData.capLength\n      ]);\n    }\n  }\n\n  _getNewHandle() {\n    return this._handleCounter++;\n  }\n\n  // Initialization function for creating a new worker (thread)\n  // _id should only be used to restart a worker !\n  _startWorker(path, _id) {\n    let worker = new Worker(path);\n    let selfWorkerId;\n    if (_id) {\n      selfWorkerId = _id;\n      this._workerPool[selfWorkerId] = worker;\n      this._workerLoad[selfWorkerId] = 0;\n    } else {\n      selfWorkerId = this._workerPool.push(worker) - 1;\n      if (this._workerLoad.push(0) !== selfWorkerId + 1)\n        throw new Error(\"WorkerLoad and WorkerPool don't have the same length\");\n    }\n\n    // This\n    worker.onmessage = messageEvent => {\n      const answer = messageEvent.data;\n      let handleID;\n\n      // Remove load\n      this._workerLoad[selfWorkerId] -= 1;\n\n      // If error\n      if (typeof answer === \"string\") {\n        T3D.Logger.log(\n          T3D.Logger.TYPE_WARNING,\n          \"Inflater threw an error\",\n          answer\n        );\n\n        // Parse the handle\n        handleID = answer.split(\":\")[0];\n\n        // Get handle owner informations and reject then cleanup\n        const handleData = this._handleRegister[handleID];\n        if (handleData) {\n          handleData.reject(`Error: ${answer}`);\n          delete this._handleRegister[handleID];\n        }\n      } else {\n        // Parse handle\n        handleID = answer[0];\n\n        const handleData = this._handleRegister[handleID];\n        // If handle is recognized: success\n        if (handleData) {\n          // Array buffer, dxtType, imageWidth, imageHeight\n          handleData.resolve({\n            buffer: answer[1],\n            dxtType: answer[2],\n            imageWidth: answer[3],\n            imageHeight: answer[4]\n          });\n\n          // Cleanup\n          delete this._handleRegister[handleID];\n        }\n\n        // Unknown error\n        else {\n          T3D.Logger.log(\n            T3D.Logger.TYPE_ERROR,\n            \"Inflater threw an error\",\n            answer\n          );\n        }\n      }\n\n      this._workNext(selfWorkerId);\n    };\n\n    // Handle errors, we assume worse case: it crashed and corrupted its memory\n    worker.onerror = _ => {\n      // Get all handles sent to this worker and reject them\n      for (let handle in this._handleRegister) {\n        if (this._handleRegister[handle].workerId === selfWorkerId) {\n          this._handleRegister[handle].reject(\n            // TODO\n            `Error: Worker crashed while processing ${\n              this._handleRegister[handle].mftId\n            }`\n          );\n          delete this._handleRegister[handle];\n        }\n      }\n\n      // Clean and restart the worker\n      this._workerPool[selfWorkerId].terminate();\n      this._startWorker(this._settings.workerPath, selfWorkerId);\n    };\n  }\n\n  // Returns -1 if there are no free worker, or the index of a free worker\n  _getFreeWorkerIndex() {\n    return this._workerLoad.indexOf(0);\n  }\n}\n\nmodule.exports = DataReader;\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst GW2File = require(\"../format/file/GW2File.js\");\n\n/**\n * @namespace FileTypes\n */\n\nlet FileTypes = {\n  /**\n   * Parse the beginning of a file to find its type\n   *\n   * @memberof FileTypes\n   * @param {DataStream} ds\n   * @return {number}\n   */\n  getFileType: ds => {\n    let first4 = ds.readCString(4);\n\n    // Parse textures\n    switch (first4) {\n      case \"ATEC\":\n        return \"TEXTURE_ATEC\";\n      case \"ATEP\":\n        return \"TEXTURE_ATEP\";\n      case \"ATET\":\n        return \"TEXTURE_ATET\";\n      case \"ATEU\":\n        return \"TEXTURE_ATEU\";\n      case \"ATEX\":\n        return \"TEXTURE_ATEX\";\n      case \"ATTX\":\n        return \"TEXTURE_ATTX\";\n    }\n\n    if (first4.indexOf(\"DDS\") === 0) return \"TEXTURE_DDS\";\n\n    if (first4.indexOf(\"PNG\") === 1) return \"TEXTURE_PNG\";\n\n    if (first4.indexOf(\"RIFF\") === 0) return \"TEXTURE_RIFF\";\n\n    if (first4.indexOf(\"YUI\") === 0) return \"TEXT_YUI\";\n\n    // PackFiles\n    if (first4.indexOf(\"PF\") === 0) {\n      let file = new GW2File(ds, 0, true); /// true for \"plz no load chunkz\"\n      return \"PF_\" + file.header.type;\n    }\n\n    // Binaries\n    if (first4.indexOf(\"MZ\") === 0) return \"BINARIES\";\n\n    // Strings\n    if (first4.indexOf(\"strs\") === 0) return \"STRINGS\";\n\n    // Raw asnd chunk (without pack file)\n    if (first4.indexOf(\"asnd\") === 0) return \"CHUNK_ASND\";\n\n    // TODO: parse all datastream and if all bytes are valid unicode symbols then\n    // return TEXT_UNKNOWN;\n\n    // Unknown\n    return \"UNKNOWN\";\n  }\n};\n\nmodule.exports = FileTypes;\n","/*\r\nCopyright  Tyria3DLibrary project contributors\r\n\r\nThis file is part of the Tyria 3D Library.\r\n\r\nTyria 3D Library is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nTyria 3D Library is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nconst ArchiveParser = require(\"./ArchiveParser\");\r\nconst PersistantStore = require(\"./PersistantStore\");\r\nconst DataReader = require(\"./DataReader\");\r\nconst MapFileList = require(\"../MapFileList\");\r\nconst FileTypes = require(\"./FileTypes\");\r\n\r\n/**\r\n * A statefull class that handles reading and inflating data from a local GW2 dat file.\r\n * LocalReader have been completely rewritten from scratch,\r\n * the API changed quite a lot between 1.0.4 and 1.1.0.\r\n *\r\n * API CHANGES: LocalReader (1.1.0 from 1.0.4)\r\n * - The constructor have __changed__.\r\n * - parseHeaderAsync have been __removed__.\r\n * - connectInflated have been __removed__.\r\n * - NaClListener have been __removed__.\r\n * - readANDatHeader have been __removed__.\r\n * - readMFTHeader have been __removed__.\r\n * - readMFTIndexFile have been __removed__.\r\n * - loadFileList is now __deprecated__.\r\n * - loadMapList is now __deprecated__.\r\n * - storeFileList have been __removed__.\r\n * - storeMapList have been __removed__.\r\n * - readFileListAsync is now __deprecated__.\r\n * - readMapListAsync is now __deprecated__.\r\n * - listFiles have been __removed__.\r\n * - getFileIndex have been slightly __changed__.\r\n * - loadTextureFile is now __deprecated__.\r\n * - loadFile have been __deprecated__.\r\n * - inflate have been __removed__.\r\n * - loadFilePart have been __removed__.\r\n *\r\n * @param {{workerPath: String, workersNb: number, noIndexedDB: boolean}} settings\r\n *   * workerPath: the path to the t3dtools worker script file.\r\n *   * workersNb: amount of threads spawned for decompression.\r\n *   * noIndexedDB: Do not use indexedDB (persistant storage, default is true)\r\n */\r\nclass LocalReader {\r\n  constructor(settings) {\r\n    this._settings = settings;\r\n\r\n    /**\r\n     * @private\r\n     * @type {DataReader}\r\n     */\r\n    this._dataReader = new DataReader(settings);\r\n\r\n    /**\r\n     * @private\r\n     * @type {PersistantStore}\r\n     */\r\n    this._persistantStore = undefined;\r\n\r\n    /**\r\n     * @private\r\n     * @type {File}\r\n     */\r\n    this._file = undefined;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<number>}\r\n     */\r\n    this._indexTable = [];\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<{offset: number, size: number, compressed: number, crc: number}>}\r\n     */\r\n    this._fileMetaTable = [];\r\n\r\n    if (settings.noIndexedDB !== false) {\r\n      this._persistantStore = new PersistantStore();\r\n    }\r\n  }\r\n\r\n  /**\r\n   *   Asynchronously loads the archive by parsing its file index and header.\r\n   *\r\n   * @param {File} file\r\n   * @returns {Promise}\r\n   */\r\n  async openArchive(file) {\r\n    let { metaTable, indexTable } = await ArchiveParser.readArchive(file);\r\n    this._fileMetaTable = metaTable;\r\n    this._indexTable = indexTable;\r\n    this._file = file;\r\n  }\r\n\r\n  /**\r\n   *   Gets MFT index by baseId\r\n   *\r\n   * @param  {Number} baseId   A base Id\r\n   * @return {Number}          MFT index\r\n   */\r\n  getFileIndex(baseId) {\r\n    return this._indexTable[baseId];\r\n  }\r\n\r\n  /**\r\n   *   \"Meta\" informations to deal with files in the archive.\r\n   * @typedef     {Object}    FileMetaData\r\n   * @property    {number}    offset\r\n   * @property    {number}    size\r\n   * @property    {number}    compressed\r\n   * @property    {number}    crc\r\n   */\r\n\r\n  /**\r\n   *   Returns the metadata of a file stored in the archive\r\n   *\r\n   * @param {number} mftId Mft index of the file\r\n   * @returns {FileMetaData} Metadata informations\r\n   */\r\n  getFileMeta(mftId) {\r\n    return this._fileMetaTable[mftId];\r\n  }\r\n\r\n  /**\r\n   *   Fetch a file and uncompress it if needed / required.\r\n   *\r\n   * @param {number} mftId File's archive ID\r\n   * @param {boolean} [isImage] Try to read the data as a Dxt texture.\r\n   * @param {boolean} [raw] Force no decompression.\r\n   * @param {number} [fileLength] Slice the uncompressed file.\r\n   * @param {number} [extractLength] Slice the decompression.\r\n   * @param {boolean} [isBaseId] If true, the first parameter mftId becomes a baseId\r\n   * @returns {Promise<{buffer: ArrayBuffer, dxtType: number|undefined, imageWidth: number|undefined, imageHeight: number|undefined}>}\r\n   */\r\n  async readFile(mftId, isImage, raw, fileLength, extractLength, isBaseId) {\r\n    if (isBaseId) {\r\n      const baseId = mftId;\r\n      mftId = this.getFileIndex(baseId);\r\n      if (!(mftId > 0)) throw new Error(`Unexistant file: ${baseId} (baseId)`);\r\n    }\r\n\r\n    let meta = this.getFileMeta(mftId);\r\n    if (!meta) throw new Error(`Unexistant file: ${mftId} (mftId)`);\r\n\r\n    // Slice up the data\r\n    let { ds, len } = await ArchiveParser.getFilePart(\r\n      this._file,\r\n      meta.offset,\r\n      fileLength || meta.size\r\n    );\r\n\r\n    // If needed we decompress, if not we keep raw\r\n    if (meta.compressed || raw !== false) {\r\n      let data;\r\n      await this._dataReader\r\n        .inflate(ds, len, mftId, isImage, extractLength || 0)\r\n        .then(result => {\r\n          data = result;\r\n        })\r\n        .catch(_ => {\r\n          data = {\r\n            buffer: undefined,\r\n            dxtType: undefined,\r\n            imageWidth: undefined,\r\n            imageHeight: undefined\r\n          };\r\n        });\r\n      return data;\r\n    } else {\r\n      return {\r\n        buffer: ds.buffer\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   *   Scans asynchronously the types of all the files listed in the archive.\r\n   *   Uses persistant store to cache and speed up a rescan.\r\n   *\r\n   * @param {Array<{baseId: number, size: number, crc: number, fileType: string}>|undefined} oldFileList\r\n   *   Way for platform not supporting indexDB to provide their own persistant storage.\r\n   * @returns {Promise<Array<FileItem>>}\r\n   */\r\n  async readFileList(oldFileList) {\r\n    let persistantList = oldFileList || [];\r\n    let persistantId;\r\n\r\n    // Load previously saved data\r\n    if (this._persistantStore) {\r\n      let lastListing = await this._persistantStore.getLastListing(\r\n        this._file.name\r\n      );\r\n      persistantList = lastListing.array;\r\n      // If the last scan was not completed then we will just update it..\r\n      if (!lastListing.complete) {\r\n        persistantId = lastListing.key;\r\n      }\r\n    }\r\n\r\n    // Create a list of all the baseIds we need to inspect\r\n    let iterateList = Object.keys(this._indexTable).map(i => Number(i));\r\n    for (let index in persistantList) {\r\n      if (!(index in this._indexTable)) iterateList.push(index);\r\n    }\r\n\r\n    // Spawn the decompression tasks\r\n    let taskArray = [];\r\n    for (let i = 0; i < 1; i++) {\r\n      taskArray[i] = Promise.resolve({\r\n        task: i\r\n      });\r\n    }\r\n\r\n    let persistantNeedsUpdate = false;\r\n\r\n    // Iterate through the array\r\n    for (let index in iterateList) {\r\n      let baseId = iterateList[index];\r\n\r\n      // First use a synchronous function to know if we need to scan the file\r\n      let result = this._needsScan(baseId, persistantList);\r\n      if (result.scan === true) {\r\n        let taskId = (await Promise.race(taskArray)).task;\r\n        taskArray[taskId] = this.readFileType(baseId).then(scanResult => {\r\n          // Put the result into our persistant storage\r\n          persistantList[baseId] = {\r\n            baseId: baseId,\r\n            size: scanResult.size,\r\n            crc: scanResult.crc,\r\n            fileType: scanResult.fileType\r\n          };\r\n          return {\r\n            task: taskId\r\n          };\r\n        });\r\n      }\r\n      if (result.change === \"removed\") {\r\n        // Update the persistant storage\r\n        delete persistantList[baseId];\r\n      }\r\n\r\n      // Handle persistant storage update\r\n      if (result.change !== \"none\") persistantNeedsUpdate = true;\r\n\r\n      // Tasks to do only every %\r\n      if (index % Math.floor(iterateList.length / 100) === 0) {\r\n        // Print progress\r\n        T3D.Logger.log(\r\n          T3D.Logger.TYPE_PROGRESS,\r\n          \"Finding types\",\r\n          index / Math.floor(iterateList.length / 100)\r\n        );\r\n\r\n        // Update the persistant storage if needed\r\n        if (this._persistantStore && persistantNeedsUpdate) {\r\n          persistantNeedsUpdate = false;\r\n          this._persistantStore\r\n            .putListing(persistantId, persistantList, this._file.name, false)\r\n            .then(res => (persistantId = res));\r\n        }\r\n      }\r\n    }\r\n\r\n    await Promise.all(taskArray).then(() => {\r\n      // Finally update the listing as complete\r\n      if (this._persistantStore) {\r\n        this._persistantStore.putListing(\r\n          persistantId,\r\n          persistantList,\r\n          this._file.name,\r\n          true\r\n        );\r\n      }\r\n    });\r\n    this._persistantData = persistantList;\r\n    return this.getFileList();\r\n  }\r\n\r\n  /**\r\n   * @typedef {Object} MapItem\r\n   * @property {string} name\r\n   * @property {string} category\r\n   * @property {number} baseId\r\n   */\r\n\r\n  /**\r\n   *   Returns a list of all the maps with their name and category.\r\n   *   Uncategorized maps are available only if readFileList have been used before.\r\n   *\r\n   * @returns {Array<MapItem>}\r\n   */\r\n  getMapList() {\r\n    let mapArray = [];\r\n    // If the archive have been scanned for all its file we iterate through the results\r\n    if (this._persistantData) {\r\n      // Filter the maps out of all our files\r\n      let reversedIndex = this.getReverseIndex();\r\n      let maps = this._persistantData\r\n        .filter(file => file.fileType === \"PF_mapc\")\r\n        .filter(\r\n          id => id.baseId === reversedIndex[this.getFileIndex(id.baseId)][0]\r\n        );\r\n\r\n      for (let map of maps) {\r\n        let found = false;\r\n        // Try to see if we already have some informations on this map\r\n        for (let category of MapFileList.maps) {\r\n          let fileMap = category.maps.find(\r\n            item => Number(item.fileName.split(\".data\")[0]) === map.baseId\r\n          );\r\n          if (fileMap) {\r\n            mapArray.push({\r\n              name: fileMap.name,\r\n              category: category.name,\r\n              baseId: map.baseId\r\n            });\r\n            found = true;\r\n            break;\r\n          }\r\n        }\r\n        // If not we register it as Uncategorized\r\n        if (!found) {\r\n          mapArray.push({\r\n            name: map.baseId.toString(),\r\n            category: \"Uncategorized\",\r\n            baseId: map.baseId\r\n          });\r\n        }\r\n      }\r\n    } else {\r\n      // If not then we check only known maps\r\n      for (let category of MapFileList.maps) {\r\n        for (let mapEntry of category.maps) {\r\n          if (Number(mapEntry.fileName.split(\".data\")[0]) in this._indexTable) {\r\n            mapArray.push({\r\n              name: mapEntry.name,\r\n              category: category.name,\r\n              baseId: Number(mapEntry.fileName.split(\".data\")[0])\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return mapArray;\r\n  }\r\n\r\n  /**\r\n   * @typedef {Object} FileItem\r\n   * @property {number} mftId\r\n   * @property {Array<number>} baseIdList\r\n   * @property {number} size\r\n   * @property {number} crc\r\n   * @property {string} fileType\r\n   **/\r\n\r\n  /**\r\n   *   Return the meta table with extra information such as an array of baseIds and the file types.\r\n   *   The filetype is available only if readFileList have been used before of course.\r\n   *\r\n   * @returns {Array<FileItem>}\r\n   */\r\n  getFileList() {\r\n    let typeList = this._persistantData\r\n      ? this._persistantData.map(i => i.fileType)\r\n      : [];\r\n    let reverseBaseIdList = this.getReverseIndex();\r\n\r\n    let fileList = this._fileMetaTable.map((meta, mftId) => {\r\n      let baseIds = reverseBaseIdList[mftId] ? reverseBaseIdList[mftId] : [];\r\n      let type = reverseBaseIdList[mftId]\r\n        ? typeList[baseIds[0]]\r\n        : \"Non-Registered\";\r\n      return {\r\n        mftId: mftId,\r\n        baseIdList: baseIds,\r\n        size: meta.size,\r\n        crc: meta.crc,\r\n        fileType: type\r\n      };\r\n    });\r\n    fileList[0] = {\r\n      mftId: 0,\r\n      baseIdList: [],\r\n      size: 0,\r\n      crc: 0,\r\n      fileType: \"Non-Registered\"\r\n    };\r\n    return fileList;\r\n  }\r\n\r\n  /**\r\n   * @returns {Array<Array<number>>}\r\n   */\r\n  getReverseIndex() {\r\n    return this._indexTable.reduce((reversed, mftId, baseId) => {\r\n      if (mftId in reversed) reversed[mftId].push(baseId);\r\n      else reversed[mftId] = [baseId];\r\n      return reversed;\r\n    }, []);\r\n  }\r\n\r\n  // API Compatibility\r\n\r\n  /**\r\n     * Looks up mft indices for all mapc pack files in the dat. Either looks trough all files or\r\n     * only the list defined in {@link MapFileList}\r\n     *\r\n     * @deprecated Use now the getFileList method.\r\n     * @param  {boolean}   searchAll if true forces re-indexing of entire dat.\r\n     * If false only reads indices specified in \"T3D/MapFileList\".\r\n     * @param  {Function} callback Fired when the list is generated\r\n     *\r\n     * First argument is the a list of mft indices grouped by file type. For exmample:\r\n     *\r\n     * \t\t{\r\n     * \t\t\tmaps:[\r\n     * \t\t\t\t{\r\n     * \t\t\t\t\tname: 'Heart of Maguuma',\r\n     * \t\t\t\t\tmaps: [\r\n     * \t\t\t\t\t\t{fileName:1151420, name:'HoT BWE3 Raid'},\r\n     * \t\t\t\t\t\t{fileName:969663, name:'Verdant Brink}\r\n     * \t\t\t\t\t]\r\n     * \t\t\t\t},\r\n     * \t\t\t\t{\r\n     * \t\t\t\t\tname: 'Unknown maps',\r\n     * \t\t\t\t\tmaps: [\r\n     * \t\t\t\t\t\t{fileName:12345678, name:'Unknown map 12345678'}\r\n     * \t\t\t\t\t]\r\n     * \t\t\t\t}\r\n     * \t\t\t]\r\n\r\n    *\t    };\r\n    */\r\n  readMapListAsync(searchAll, callback) {\r\n    T3D.Logger.log(\r\n      T3D.Logger.TYPE_WARNING,\r\n      \"LocalReader.readMapListAsync is deprecated !\"\r\n    );\r\n\r\n    // Let's preserve the old output way\r\n    function restoreOuput(array) {\r\n      let returnArray = [];\r\n      for (let elt of array) {\r\n        let category = returnArray.findIndex(i => i.name === elt.category);\r\n        if (category === -1) {\r\n          category =\r\n            returnArray.push({\r\n              name: elt.category,\r\n              maps: []\r\n            }) - 1;\r\n        }\r\n        returnArray[category].maps.push({\r\n          fileName: elt.baseId,\r\n          name: elt.name\r\n        });\r\n      }\r\n      // And resort it in order\r\n      returnArray.sort((i, j) => {\r\n        if (i.name < j.name) return -1;\r\n        if (i.name > j.name) return 1;\r\n        return 0;\r\n      });\r\n      return {\r\n        maps: returnArray\r\n      };\r\n    }\r\n\r\n    /// If seachAll flag is true, force a deep search\r\n    if (searchAll) {\r\n      this.readFileList().then(() => {\r\n        callback(restoreOuput(this.getMapList()));\r\n      });\r\n    } else {\r\n      callback(restoreOuput(this.getMapList()));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reads the file type of each file in the dat and stores the resulting list in\r\n   * the browser's local storage.\r\n   *\r\n   * @deprecated Use now the readFileList or getFileList methods.\r\n   * @param  {Function} callback Fired when the list is generated and stores\r\n   *\r\n   * First argument is the a list of mft indices grouped by file type.\r\n   */\r\n  readFileListAsync(callback) {\r\n    T3D.Logger.log(\r\n      T3D.Logger.TYPE_WARNING,\r\n      \"LocalReader.readFileListAsync is deprecated !\"\r\n    );\r\n\r\n    // Because the API changed we reform the data as wanted previously\r\n    this.readFileList().then(result => {\r\n      let returnObj = {};\r\n      for (let fileEntry of result) {\r\n        if (returnObj[fileEntry.fileType] === undefined) {\r\n          returnObj[fileEntry.fileType] = [];\r\n        }\r\n        returnObj[fileEntry.fileType].push(fileEntry.mftId);\r\n      }\r\n      callback(returnObj);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Reads data from a file in the dat.\r\n   *\r\n   * @deprecated Use now the Promise-based method readFile.\r\n   * @param  {Number}   baseId   Base or File id of the texture to load\r\n   * @param  {Function} callback Fires when the inflater has read the data.\r\n   *\r\n   * The passed arguments are\r\n   * -ArrayBuffer raw data\r\n   * -Number DXT Type if applicable\r\n   * -Number image width if applicable\r\n   * -Number image height if applicable\r\n   *\r\n   *\r\n   * @param  {boolean}  isImage\r\n   * @param  {boolean}   raw      If true, any infation is skipped and raw data is returned.\r\n   */\r\n  loadFile(baseId, callback, isImage, raw) {\r\n    T3D.Logger.log(\r\n      T3D.Logger.TYPE_WARNING,\r\n      \"LocalReader.loadFile is deprecated !\"\r\n    );\r\n    this.readFile(baseId, isImage, raw, undefined, undefined, true).then(\r\n      result => {\r\n        if (result.buffer === undefined) return callback(null);\r\n        callback(\r\n          result.buffer,\r\n          result.dxtType,\r\n          result.imageWidth,\r\n          result.imageHeight\r\n        );\r\n      }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Reads a bitmap from a texture file in the dat.\r\n   *\r\n   * @deprecated\r\n   * @param  {Number}   baseId   Base or File id of the texture to load\r\n   * @param  {Function} callback Fires when the inflater has read the texture data.\r\n   *\r\n   * The passed arguments are\r\n   * -ArrayBuffer Bitmap\r\n   * -Number DXT Type\r\n   * -Number image width\r\n   * -Number image height\r\n   *\r\n   */\r\n  loadTextureFile(baseId, callback) {\r\n    T3D.Logger.log(\r\n      T3D.Logger.TYPE_WARNING,\r\n      \"LocalReader.loadTextureFile is deprecated !\"\r\n    );\r\n\r\n    /// Old way:\r\n    // this.loadFile(baseId, callback, true);\r\n\r\n    /// New way:\r\n    this.readFile(\r\n      baseId,\r\n      undefined, // isImage\r\n      undefined, // raw\r\n      undefined, // fileLength\r\n      undefined, // extractLength\r\n      true\r\n    ).then(result => {\r\n      if (result.buffer === undefined) return callback(null);\r\n      callback(\r\n        result.buffer,\r\n        result.dxtType,\r\n        result.imageWidth,\r\n        result.imageHeight\r\n      );\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Used to read the cached list of files corresponding to the reader's .dat from the localStorage.\r\n   * Now kept only for backward compatibility, but doesn't do anything.\r\n   * Please use getFileList now.\r\n   *\r\n   * @deprecated\r\n   */\r\n  loadFileList() {\r\n    T3D.Logger.log(\r\n      T3D.Logger.TYPE_WARNING,\r\n      \"LocalReader.loadFileList is deprecated !\"\r\n    );\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Used to read the cached list of maps corresponding to the reader's .dat from the localStorage.\r\n   * Now kept only for backward compatibility, but doesn't do anything.\r\n   * Please use getMapList now.\r\n   *\r\n   * @deprecated\r\n   */\r\n  loadMapList() {\r\n    T3D.Logger.log(\r\n      T3D.Logger.TYPE_WARNING,\r\n      \"LocalReader.loadMapList is deprecated !\"\r\n    );\r\n    return undefined;\r\n  }\r\n\r\n  // Private\r\n\r\n  /**\r\n   * @private\r\n   * @param {number} baseId\r\n   * @param {Array<{baseId: number, crc: number, size: number, fileType: string}>} persistantData\r\n   * @returns {{scan: boolean, change: string }}\r\n   */\r\n  _needsScan(baseId, persistantData) {\r\n    if (baseId <= 0) {\r\n      return {\r\n        change: \"none\",\r\n        scan: false\r\n      };\r\n    }\r\n\r\n    let mftId = this.getFileIndex(baseId);\r\n    let metaData = this.getFileMeta(mftId);\r\n\r\n    if (metaData === undefined && !(baseId in persistantData)) {\r\n      // Nothing interesting\r\n      return {\r\n        change: \"none\",\r\n        scan: false\r\n      };\r\n    } else if (metaData === undefined) {\r\n      // If the file have been deleted\r\n      return {\r\n        change: \"removed\",\r\n        scan: false\r\n      };\r\n    } else if (!(baseId in persistantData)) {\r\n      // If the file is new\r\n      return {\r\n        change: \"added\",\r\n        scan: true\r\n      };\r\n    } else if (\r\n      metaData.size !== persistantData[baseId].size ||\r\n      metaData.crc !== persistantData[baseId].crc\r\n    ) {\r\n      // If the size or crc don't match\r\n      return {\r\n        change: \"modified\",\r\n        scan: true\r\n      };\r\n    } else {\r\n      // If everything is the same\r\n      return {\r\n        change: \"none\",\r\n        scan: false\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reads the file type and gives back an object with fileType, crc and size informations\r\n   * @param {number} baseId\r\n   * @param {Array<{baseId: number, crc: number, size: number, fileType: string}>} persistantData\r\n   * @returns {Promise<{fileType: string, crc: number, size: number}>}\r\n   */\r\n  async readFileType(baseId) {\r\n    if (!this._fileTypeCache) this._fileTypeCache = [];\r\n\r\n    let mftId = this.getFileIndex(baseId);\r\n    let metaData = this.getFileMeta(mftId);\r\n\r\n    let fileType;\r\n    if (this._fileTypeCache[baseId] !== undefined) {\r\n      fileType = this._fileTypeCache[baseId];\r\n    } else {\r\n      let fileBuffer = (await this.readFile(\r\n        mftId,\r\n        false,\r\n        false,\r\n        Math.min(metaData.size, 1000),\r\n        32\r\n      )).buffer;\r\n      if (fileBuffer === undefined) return undefined;\r\n      fileType = FileTypes.getFileType(new DataStream(fileBuffer));\r\n    }\r\n    return {\r\n      fileType: fileType,\r\n      crc: metaData.crc,\r\n      size: metaData.size\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = LocalReader;\r\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/// Indexed DB versioning\nconst DB_VERSION = 4;\n\n/**\n * This class handles offline storage of the .dat indexes and files metadata\n * @class PersistantStore\n */\nclass PersistantStore {\n  constructor() {\n    // They may be multiple connection request issued at the same time, but it's actually okay since\n    // as soon as they are registered, the not-used ones will get garbage collected\n    this._dbConnection = undefined;\n    this._getConnection(() => {});\n  }\n\n  /**\n   *   Initialize the IndexedDB connection and manages version changes.\n   *\n   * @async\n   * @private\n   * @returns {Promise<IDBDatabase>} Promise to the Database connection\n   */\n  _getConnection() {\n    return new Promise((resolve, reject) => {\n      if (this._dbConnection) resolve(this._dbConnection);\n\n      // Let us open our database\n      let request = window.indexedDB.open(\"Tyria3DLibrary\", DB_VERSION);\n\n      /// onblocked is fired when the db needs an upgrade but an older version is opened in another tab\n      request.onblocked = event => {\n        T3D.Logger.log(\n          T3D.Logger.TYPE_ERROR,\n          \"The T3D persistant database cannot be upgraded while the app is opened somewhere else.\"\n        );\n      };\n\n      /// fired when the database needs to be upgraded (or the first time)\n      request.onupgradeneeded = event => {\n        /** @type {IDBDatabase} */\n        let db = event.target.result;\n        let currentVersion = event.oldVersion;\n\n        if (currentVersion < 2) {\n          db.createObjectStore(\"listings\", {\n            autoIncrement: true\n          });\n        }\n\n        if (currentVersion < 3) {\n          let storeListing = event.currentTarget.transaction.objectStore(\n            \"listings\"\n          );\n          storeListing.createIndex(\"filename\", \"filename\", {\n            unique: false\n          });\n        }\n      };\n\n      request.onsuccess = event => {\n        this._dbConnection = event.target.result;\n        this.isReady = true;\n        resolve(this._dbConnection);\n      };\n\n      request.onerror = event => {\n        T3D.Logger.log(\n          T3D.Logger.TYPE_ERROR,\n          \"The T3D persistant database could not be opened.\"\n        );\n        reject(new Error(\"IndexedDB failed to open\"));\n      };\n    });\n  }\n\n  /**\n   *   Add or update a listing into the database\n   *\n   * @async\n   * @param {number|undefined} id This ID doesn't really matter, it's just the index of the object in the database, can be undefined\n   * @param {Array} listing\n   * @param {string} fileName .dat file name, allows to have multiple listings for different .dat files.\n   * @param {boolean} isComplete Keep back the information if that was the last update on the current scan or not.\n   * @returns {Promise<number>} On success, the number is the object key in the database\n   */\n  putListing(id, listing, fileName, isComplete) {\n    return new Promise((resolve, reject) => {\n      this._getConnection().then(db => {\n        let store = db\n          .transaction([\"listings\"], \"readwrite\")\n          .objectStore(\"listings\");\n\n        let request = id\n          ? store.put(\n              {\n                array: listing,\n                filename: fileName,\n                complete: isComplete\n              },\n              id\n            )\n          : store.put({\n              array: listing,\n              name: fileName\n            });\n\n        request.onsuccess = event => {\n          resolve(request.result);\n        };\n        request.onerror = event => {\n          reject(new Error(\"Could not put listing to Indexed DB\"));\n        };\n      });\n    });\n  }\n\n  /**\n   * Returns the last valid listing in the database\n   *\n   * @async\n   * @param {string} fileName .dat file name, allows to have multiple listings for different .dat files.\n   * @returns {Promise<{array: Array, key: number, complete: boolean}>}\n   *      array: the last listing\n   *      key: the index of the last listing in the database\n   */\n  getLastListing(fileName) {\n    return new Promise((resolve, reject) => {\n      this._getConnection().then(db => {\n        let listingsStore = db\n          .transaction([\"listings\"], \"readonly\")\n          .objectStore(\"listings\")\n          .index(\"filename\");\n\n        listingsStore.openCursor(\n          IDBKeyRange.only(fileName),\n          \"prev\"\n        ).onsuccess = event => {\n          let cursor = event.target.result;\n          if (!cursor) {\n            resolve({\n              array: [],\n              key: undefined,\n              complete: true\n            });\n          } else {\n            resolve({\n              array: cursor.value.array,\n              key: cursor.primaryKey,\n              complete: cursor.value.complete\n            });\n          }\n        };\n      });\n    });\n  }\n}\n\nmodule.exports = PersistantStore;\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * A Logger class for T3D\n *\n * This satic class defines severity levels of messages and provides\n * basic logging functionality. Replacing the reference to\n *\n * @namespace\n * @static\n */\nlet Logger = {};\n\n/**\n * @readonly\n * @property {number} TYPE_ERROR\n */\nLogger.TYPE_ERROR = 4;\n\n/**\n * @readonly\n * @property {number} TYPE_WARNING\n */\nLogger.TYPE_WARNING = 3;\n\n/**\n * @readonly\n * @property {number} TYPE_MESSAGE\n */\nLogger.TYPE_MESSAGE = 2;\n\n/**\n * @readonly\n * @property {number} TYPE_PROGRESS\n */\nLogger.TYPE_PROGRESS = 1;\n\n/**\n * @readonly\n * @property {number} TYPE_DEBUG\n */\nLogger.TYPE_DEBUG = 0;\n\n/**\n * The logging functions, indexed by severity/type.\n *\n * @property logFunctions\n * @type Function[]\n */\nLogger.logFunctions = new Array(5);\n\n/**\n * Main logging method. Takes 1 to N arguments. If there are more than 1 arguments\n * the first argument is interpreted as severity. If there is only one argument\n * severity defaults to\n * {{#crossLink \"Logger/TYPE_MESSAGE:property\"}}{{/crossLink}}.\n *  \n * The following arguments are passed to a logging function matching the\n * severity.\n * \n \n * \n */\nLogger.log = function() {\n  /// Require at least 1 argument\n  if (arguments.length === 0) {\n    return;\n  }\n\n  /// Parse arguments to an actual array\n  let argArr = Logger.argsToArr(arguments);\n\n  /// Default to message if just one argument was passed\n  if (argArr.length === 1) {\n    argArr.unshift(Logger.TYPE_MESSAGE);\n  }\n\n  /// Otherwise 1st arg is severity, log/warn/error\n  let severity = Math.max(\n    0,\n    Math.min(Logger.logFunctions.length, argArr.shift())\n  );\n  let logFunc = Logger.logFunctions[severity];\n\n  /// Ouput the rest of the arguments\n  logFunc.apply(this, argArr);\n};\n\nLogger.argsToArr = function(args) {\n  let argArr = new Array(args.length);\n  for (let i = 0; i < argArr.length; ++i) {\n    argArr[i] = args[i];\n  }\n  return argArr;\n};\n\nLogger.logFunctions[Logger.TYPE_ERROR] = function() {\n  console.error.apply(console, arguments);\n};\n\nLogger.logFunctions[Logger.TYPE_WARNING] = function() {\n  console.warn.apply(console, arguments);\n};\n\nLogger.logFunctions[Logger.TYPE_MESSAGE] = function() {\n  console.log.apply(console, arguments);\n};\n\nLogger.logFunctions[Logger.TYPE_PROGRESS] = function() {\n  let argArr = Logger.argsToArr(arguments);\n  argArr.unshift(\"Progress: \");\n  console.log.apply(console, argArr);\n};\n\nLogger.logFunctions[Logger.TYPE_DEBUG] = function() {\n  let argArr = Logger.argsToArr(arguments);\n  console.debug.apply(console, argArr);\n};\n\nmodule.exports = Logger;\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nmodule.exports = {\n  /**\n   * @property maps\n   * @type {Array.<{name: String, maps: Array.<{fileName: String, name: String}>}>}\n   */\n  maps: [\n    {\n      name: \"01. Shiverpeaks\",\n      maps: [\n        {\n          fileName: \"125199.data\",\n          name: \"Wayfarer Foothills (0)\"\n        },\n        {\n          fileName: \"187611.data\",\n          name: \"Wayfarer Foothills (1)\"\n        },\n        {\n          fileName: \"568778.data\",\n          name: \"Cragstead\"\n        },\n        {\n          fileName: \"132434.data\",\n          name: \"Hoelbrak (0)\"\n        },\n        {\n          fileName: \"197122.data\",\n          name: \"Hoelbrak (1)\"\n        },\n        {\n          fileName: \"1966018.data\",\n          name: \"Hoelbrak (2)\"\n        },\n        {\n          fileName: \"124093.data\",\n          name: \"Snowden Drifts (0)\"\n        },\n        {\n          fileName: \"186397.data\",\n          name: \"Snowden Drifts (1)\"\n        },\n        {\n          fileName: \"275155.data\",\n          name: \"Dredgehaunt Cliffs\"\n        },\n        {\n          fileName: \"276252.data\",\n          name: \"Frostgorge Sound\"\n        },\n        {\n          fileName: \"277587.data\",\n          name: \"Lornar's Pass\"\n        },\n        {\n          fileName: \"278717.data\",\n          name: \"Timberline Falls (0)\"\n        },\n        {\n          fileName: \"846866.data\",\n          name: \"Timberline Falls (1)\"\n        },\n        {\n          fileName: \"1018612.data\",\n          name: \"Timberline Falls (2)\"\n        },\n        {\n          fileName: \"295282.data\",\n          name: \"Eye of the North\"\n        }\n      ]\n    },\n    {\n      name: \"02. Ascalon\",\n      maps: [\n        {\n          fileName: \"126118.data\",\n          name: \"Plains of Ashford (0)\"\n        },\n        {\n          fileName: \"188591.data\",\n          name: \"Plains of Ashford (1)\"\n        },\n        {\n          fileName: \"127888.data\",\n          name: \"Diessa Plateau (0)\"\n        },\n        {\n          fileName: \"190490.data\",\n          name: \"Diessa Plateau (1)\"\n        },\n        {\n          fileName: \"131944.data\",\n          name: \"Black Citadel (0)\"\n        },\n        {\n          fileName: \"196585.data\",\n          name: \"Black Citadel (1)\"\n        },\n        {\n          fileName: \"1968107.data\",\n          name: \"Black Citadel (2)\"\n        },\n        {\n          fileName: \"280025.data\",\n          name: \"Blazeridge Steppes\"\n        },\n        {\n          fileName: \"281313.data\",\n          name: \"Fireheart Rise\"\n        },\n        {\n          fileName: \"282668.data\",\n          name: \"Iron Marches\"\n        },\n        {\n          fileName: \"283574.data\",\n          name: \"Fields of Ruin\"\n        }\n      ]\n    },\n    {\n      name: \"03. Kryta\",\n      maps: [\n        {\n          fileName: \"191000.data\",\n          name: \"Lion's Arch (0)\"\n        },\n        {\n          fileName: \"814803.data\",\n          name: \"Lion's Arch (1)\"\n        },\n        {\n          fileName: \"1019669.data\",\n          name: \"Lion's Arch (Legacy)\"\n        },\n        {\n          fileName: \"1796999.data\",\n          name: \"Lion's Arch (2)\"\n        },\n        {\n          fileName: \"1869665.data\",\n          name: \"Lion's Arch (3)\"\n        },\n        {\n          fileName: \"1968576.data\",\n          name: \"Lion's Arch (4)\"\n        },\n        {\n          fileName: \"128151.data\",\n          name: \"Divinity's Reach (0)\"\n        },\n        {\n          fileName: \"191265.data\",\n          name: \"Divinity's Reach (1)\"\n        },\n        {\n          fileName: \"705746.data\",\n          name: \"Divinity's Reach (2)\"\n        },\n        {\n          fileName: \"1968748.data\",\n          name: \"Divinity's Reach (3)\"\n        },\n        {\n          fileName: \"129834.data\",\n          name: \"North of Divinity's Reach (0)\"\n        },\n        {\n          fileName: \"193081.data\",\n          name: \"North of Divinity's Reach (1)\"\n        },\n        {\n          fileName: \"129524.data\",\n          name: \"Queensdale (0)\"\n        },\n        {\n          fileName: \"192711.data\",\n          name: \"Queensdale (1)\"\n        },\n        {\n          fileName: \"130970.data\",\n          name: \"Kessex Hills (0)\"\n        },\n        {\n          fileName: \"194288.data\",\n          name: \"Kessex Hills (1)\"\n        },\n        {\n          fileName: \"672138.data\",\n          name: \"Kessex Hills (2)\"\n        },\n        {\n          fileName: \"861815.data\",\n          name: \"Kessex Hills (3)\"\n        },\n        {\n          fileName: \"286945.data\",\n          name: \"Bloodtide Coast\"\n        },\n        {\n          fileName: \"287870.data\",\n          name: \"Harathi Hinterlands\"\n        },\n        {\n          fileName: \"289176.data\",\n          name: \"Gendarran Fields\"\n        },\n        {\n          fileName: \"295005.data\",\n          name: \"Chantry of Secrets\"\n        },\n        {\n          fileName: \"294938.data\",\n          name: \"Claw Island\"\n        }\n      ]\n    },\n    {\n      name: \"04. Maguuma Jungle\",\n      maps: [\n        {\n          fileName: \"195149.data\",\n          name: \"Caledon Forest\"\n        },\n        {\n          fileName: \"195493.data\",\n          name: \"Metrica Province\"\n        },\n        {\n          fileName: \"922320.data\",\n          name: \"Metrica Province Instance\"\n        },\n        {\n          fileName: \"198076.data\",\n          name: \"The Grove (0)\"\n        },\n        {\n          fileName: \"1969341.data\",\n          name: \"The Grove (1)\"\n        },\n        {\n          fileName: \"198272.data\",\n          name: \"Rata Sum (0)\"\n        },\n        {\n          fileName: \"1968896.data\",\n          name: \"Rata Sum (1)\"\n        },\n        {\n          fileName: \"291064.data\",\n          name: \"Mount Maelstrom\"\n        },\n        {\n          fileName: \"292254.data\",\n          name: \"Sparkfly Fen\"\n        },\n        {\n          fileName: \"293307.data\",\n          name: \"Brisban Wildlands\"\n        }\n      ]\n    },\n    {\n      name: \"05. Ruins of Orr\",\n      maps: [\n        {\n          fileName: \"284829.data\",\n          name: \"Straits of Devastation\"\n        },\n        {\n          fileName: \"285089.data\",\n          name: \"Malchor's Leap\"\n        },\n        {\n          fileName: \"285634.data\",\n          name: \"Cursed Shore\"\n        },\n        {\n          fileName: \"295179.data\",\n          name: \"Cathedral of Hidden Depths\"\n        },\n        {\n          fileName: \"295962.data\",\n          name: \"A Light in the Darkness\"\n        }\n      ]\n    },\n    {\n      name: \"06. Living World S1\",\n      maps: [\n        {\n          fileName: \"520479.data\",\n          name: \"Southsun Cove\"\n        },\n        {\n          fileName: \"679089.data\",\n          name: \"Tower of Nightmares\"\n        }\n      ]\n    },\n    {\n      name: \"07. Living World S2\",\n      maps: [\n        {\n          fileName: \"836211.data\",\n          name: \"Dry top (0)\"\n        },\n        {\n          fileName: \"861770.data\",\n          name: \"Dry top (1)\"\n        },\n        {\n          fileName: \"909361.data\",\n          name: \"The Silverwastes (0)\"\n        },\n        {\n          fileName: \"996202.data\",\n          name: \"The Silverwastes (1)\"\n        },\n        {\n          fileName: \"908730.data\",\n          name: \"Glint's Lair\"\n        }\n      ]\n    },\n    {\n      name: \"08. Heart of Maguuma\",\n      maps: [\n        {\n          fileName: \"969663.data\",\n          name: \"Verdant Brink\"\n        },\n        {\n          fileName: \"1262460.data\",\n          name: \"Hearts and Minds\"\n        },\n        {\n          fileName: \"969964.data\",\n          name: \"Unknown Airship in tree\"\n        },\n        {\n          fileName: \"1262310.data\",\n          name: \"Dragon Stand\"\n        },\n        {\n          fileName: \"1263739.data\",\n          name: \"Tarir\"\n        },\n        {\n          fileName: \"1264291.data\",\n          name: \"Tangled Depths\"\n        }\n      ]\n    },\n    {\n      name: \"09. Living World S3\",\n      maps: [\n        {\n          fileName: \"1472635.data\",\n          name: \"(E1) Bloodstone Fen\"\n        },\n        {\n          fileName: \"1498071.data\",\n          name: \"(E2) Taimi Simulator\"\n        },\n        {\n          fileName: \"1498578.data\",\n          name: \"(E2) Ring of Fire\"\n        },\n        {\n          fileName: \"1605211.data\",\n          name: \"(E3) Bitterfrost Frontier\"\n        },\n        {\n          fileName: \"1645474.data\",\n          name: \"(E4) Caudecus Manor\"\n        },\n        {\n          fileName: \"1646520.data\",\n          name: \"(E4) Lake Doric\"\n        },\n        {\n          fileName: \"1682493.data\",\n          name: \"(E5) Draconis Mons\"\n        },\n        {\n          fileName: \"1682763.data\",\n          name: \"(E5) Titan's Throat\"\n        },\n        {\n          fileName: \"1734839.data\",\n          name: \"(E6) White Mantle Fortress\"\n        },\n        {\n          fileName: \"1735346.data\",\n          name: \"(E6) Siren's Landing\"\n        },\n        {\n          fileName: \"1735440.data\",\n          name: \"(E6) Shining Blade Headquarters\"\n        }\n      ]\n    },\n    {\n      name: \"10. Crystal Desert\",\n      maps: [\n        {\n          fileName: \"1794574.data\",\n          name: \"Crystal Oasis\"\n        },\n        {\n          fileName: \"1833034.data\",\n          name: \"Desert Highlands\"\n        },\n        {\n          fileName: \"1833726.data\",\n          name: \"PoF story instances\"\n        },\n        {\n          fileName: \"1839188.data\",\n          name: \"Domain of Vabbi\"\n        },\n        {\n          fileName: \"1840103.data\",\n          name: \"Elon Riverlands\"\n        },\n        {\n          fileName: \"1840368.data\",\n          name: \"Kormir Sanctuary\"\n        },\n        {\n          fileName: \"1842533.data\",\n          name: \"The Desolation\"\n        }\n      ]\n    },\n    {\n      name: \"11. Living World S4\",\n      maps: [\n        {\n          fileName: \"1901428.data\",\n          name: \"(E1) Fahranur\"\n        },\n        {\n          fileName: \"1902235.data\",\n          name: \"(E1) Istan\"\n        },\n        {\n          fileName: \"1903523.data\",\n          name: \"(E1) Crystal Oasis\"\n        },\n        {\n          fileName: \"1954984.data\",\n          name: \"(E2) Desert Highlands\"\n        },\n        {\n          fileName: \"1955224.data\",\n          name: \"(E2) Inquest Lab Tower\"\n        },\n        {\n          fileName: \"1955471.data\",\n          name: \"(E2) Rata Primus\"\n        },\n        {\n          fileName: \"1955642.data\",\n          name: \"(E2) Divinity's Reach\"\n        },\n        {\n          fileName: \"1955915.data\",\n          name: \"(E2) Mount Maelstrom\"\n        },\n        {\n          fileName: \"1956140.data\",\n          name: \"(E2) Frostgorge Sound\"\n        },\n        {\n          fileName: \"1956245.data\",\n          name: \"(E2) Void\"\n        },\n        {\n          fileName: \"1956299.data\",\n          name: \"(E2) Hided Inquest Lab\"\n        },\n        {\n          fileName: \"1957526.data\",\n          name: \"(E2) Sandswept Isles\"\n        }\n      ]\n    },\n    {\n      name: \"12. Seasonal Activities\",\n      maps: [\n        {\n          fileName: \"506592.data\",\n          name: \"Ascent to Madness\"\n        },\n        {\n          fileName: \"506670.data\",\n          name: \"Mad King's Labyrinth (Past)\"\n        },\n        {\n          fileName: \"662436.data\",\n          name: \"Mad King's Labyrinth (Present)\"\n        },\n        {\n          fileName: \"506739.data\",\n          name: \"Mad King's Clock Tower\"\n        },\n        {\n          fileName: \"622681.data\",\n          name: \"The Crown Pavilion\"\n        },\n        {\n          fileName: \"569756.data\",\n          name: \"SAB Hub (0)\"\n        },\n        {\n          fileName: \"636133.data\",\n          name: \"SAB Hub (1)\"\n        },\n        {\n          fileName: \"635555.data\",\n          name: \"SAB World 1\"\n        },\n        {\n          fileName: \"635960.data\",\n          name: \"SAB World 2\"\n        },\n        {\n          fileName: \"606255.data\",\n          name: \"Zephyr Sanctum\"\n        },\n        {\n          fileName: \"529896.data\",\n          name: \"Tixx's Infinirarium\"\n        },\n        {\n          fileName: \"529945.data\",\n          name: \"Winter Wonderland\"\n        }\n      ]\n    },\n    {\n      name: \"13. Activites\",\n      maps: [\n        {\n          fileName: \"605983.data\",\n          name: \"Sanctum Sprint\"\n        },\n        {\n          fileName: \"606030.data\",\n          name: \"Basket Brawl\"\n        }\n      ]\n    },\n    {\n      name: \"14. Dungeons\",\n      maps: [\n        {\n          fileName: \"126840.data\",\n          name: \"Ascalonian Catacombs (0)\"\n        },\n        {\n          fileName: \"189364.data\",\n          name: \"Ascalonian Catacombs (1)\"\n        },\n        {\n          fileName: \"275474.data\",\n          name: \"Sorrow's Embrace\"\n        },\n        {\n          fileName: \"276520.data\",\n          name: \"Honor of the Waves\"\n        },\n        {\n          fileName: \"284039.data\",\n          name: \"Citadel of Flame\"\n        },\n        {\n          fileName: \"287214.data\",\n          name: \"Caudecus's Manor\"\n        },\n        {\n          fileName: \"291284.data\",\n          name: \"Twilight Arbor (0)\"\n        },\n        {\n          fileName: \"645968.data\",\n          name: \"Twilight Arbor (1)\"\n        },\n        {\n          fileName: \"293606.data\",\n          name: \"Crucible of Eternity\"\n        },\n        {\n          fileName: \"473930.data\",\n          name: \"The Ruined City of Arah\"\n        },\n        {\n          fileName: \"473765.data\",\n          name: \"Arah - Story\"\n        },\n        {\n          fileName: \"580061.data\",\n          name: \"Molten Facility\"\n        },\n        {\n          fileName: \"595722.data\",\n          name: \"Aetherblade Retreat\"\n        }\n      ]\n    },\n    {\n      name: \"15. Fractals\",\n      maps: [\n        {\n          fileName: \"519839.data\",\n          name: \"Fractals of the Mists\"\n        },\n        {\n          fileName: \"697450.data\",\n          name: \"Thaumanova Reactor\"\n        },\n        {\n          fileName: \"1426653.data\",\n          name: \"Cliffside Fractal\"\n        },\n        {\n          fileName: \"1472361.data\",\n          name: \"Chaos Isle Fractal\"\n        },\n        {\n          fileName: \"1472382.data\",\n          name: \"Snowblind Fractal\"\n        },\n        {\n          fileName: \"1472406.data\",\n          name: \"Swampland Fractal\"\n        },\n        {\n          fileName: \"1498016.data\",\n          name: \"Mistlock Observatory\"\n        },\n        {\n          fileName: \"1498798.data\",\n          name: \"Aetherblade/Mai Trin Fractal\"\n        },\n        {\n          fileName: \"1605344.data\",\n          name: \"Nightmare Fractal\"\n        },\n        {\n          fileName: \"1733857.data\",\n          name: \"Shattered Observatory Fractal\"\n        },\n        {\n          fileName: \"1733961.data\",\n          name: \"Mistlock Sanctuary\"\n        },\n        {\n          fileName: \"1905739.data\",\n          name: \"Molten Boss Fractal\"\n        },\n        {\n          fileName: \"1905889.data\",\n          name: \"Twilight Oasis Fractal\"\n        }\n      ]\n    },\n    {\n      name: \"16. Raid\",\n      maps: [\n        {\n          fileName: \"1151420.data\",\n          name: \"(W1) Spirit Vale\"\n        },\n        {\n          fileName: \"1383309.data\",\n          name: \"(W2) Salvation Pass\"\n        },\n        {\n          fileName: \"1427048.data\",\n          name: \"Special Forces Training Area\"\n        },\n        {\n          fileName: \"1454070.data\",\n          name: \"(W3) Stronghold of the Faithful\"\n        },\n        {\n          fileName: \"1645215.data\",\n          name: \"(W4) Bastion of the Penitent\"\n        },\n        {\n          fileName: \"1906329.data\",\n          name: \"(W5) Hall of Chains\"\n        }\n      ]\n    },\n    {\n      name: \"17. Structured PvP\",\n      maps: [\n        {\n          fileName: \"871093.data\",\n          name: \"Original Stronghold\"\n        },\n        {\n          fileName: \"870987.data\",\n          name: \"Battle of Champion's Dusk (0)\"\n        },\n        {\n          fileName: \"1666233.data\",\n          name: \"Battle of Champion's Dusk (1)\"\n        },\n        {\n          fileName: \"132570.data\",\n          name: \"Heart of the Mists (0)\"\n        },\n        {\n          fileName: \"197249.data\",\n          name: \"Heart of the Mists (1)\"\n        },\n        {\n          fileName: \"1734729.data\",\n          name: \"Heart of the Mists (2)\"\n        },\n        {\n          fileName: \"1712986.data\",\n          name: \"Hall of the Mists\"\n        },\n        {\n          fileName: \"132710.data\",\n          name: \"The Battle of Khylo (0)\"\n        },\n        {\n          fileName: \"197402.data\",\n          name: \"The Battle of Khylo (1)\"\n        },\n        {\n          fileName: \"132837.data\",\n          name: \"Forest of Niflhel (0)\"\n        },\n        {\n          fileName: \"197545.data\",\n          name: \"Forest of Niflhel (1)\"\n        },\n        {\n          fileName: \"376916.data\",\n          name: \"Legacy of the Foefire\"\n        },\n        {\n          fileName: \"467374.data\",\n          name: \"Raid on the Capricorn\"\n        },\n        {\n          fileName: \"520609.data\",\n          name: \"Temple of the Silent Storm\"\n        },\n        {\n          fileName: \"579383.data\",\n          name: \"Skyhammer (0)\"\n        },\n        {\n          fileName: \"677968.data\",\n          name: \"Skyhammer (1)\"\n        },\n        {\n          fileName: \"1934470.data\",\n          name: \"Skyhammer (2)\"\n        },\n        {\n          fileName: \"791564.data\",\n          name: \"Courtyard (0)\"\n        },\n        {\n          fileName: \"1713054.data\",\n          name: \"Courtyard (1)\"\n        },\n        {\n          fileName: \"556199.data\",\n          name: \"Spirit Watch (0)\"\n        },\n        {\n          fileName: \"1473061.data\",\n          name: \"Spirit Watch (1)\"\n        },\n        {\n          fileName: \"506539.data\",\n          name: \"Reaper's Rumble\"\n        },\n        {\n          fileName: \"529718.data\",\n          name: \"Snowball Mayhem\"\n        },\n        {\n          fileName: \"595582.data\",\n          name: \"Dragon Ball Arena\"\n        },\n        {\n          fileName: \"617120.data\",\n          name: \"Aspect Arena\"\n        },\n        {\n          fileName: \"1644624.data\",\n          name: \"Revenge of the Capricorn\"\n        },\n        {\n          fileName: \"1704155.data\",\n          name: \"Eternal Coliseum\"\n        }\n      ]\n    },\n    {\n      name: \"18. World vs World\",\n      maps: [\n        {\n          fileName: \"131235.data\",\n          name: \"Eternal Battlegrounds (0)\"\n        },\n        {\n          fileName: \"195806.data\",\n          name: \"Eternal Battlegrounds (1)\"\n        },\n        {\n          fileName: \"1885693.data\",\n          name: \"Eternal Battlegrounds (2)\"\n        },\n        {\n          fileName: \"1918037.data\",\n          name: \"Eternal Battlegrounds (3)\"\n        },\n        {\n          fileName: \"131574.data\",\n          name: \"Alpine Borderlands (0)\"\n        },\n        {\n          fileName: \"641501.data\",\n          name: \"Alpine Borderlands (1)\"\n        },\n        {\n          fileName: \"1799855.data\",\n          name: \"Alpine Borderlands (2)\"\n        },\n        {\n          fileName: \"1647236.data\",\n          name: \"Desert Borderlands (0)\"\n        },\n        {\n          fileName: \"1799442.data\",\n          name: \"Desert Borderlands (1)\"\n        },\n        {\n          fileName: \"736241.data\",\n          name: \"Edge of the Mists\"\n        }\n      ]\n    },\n    {\n      name: \"19. Guild Halls\",\n      maps: [\n        {\n          fileName: \"1255378.data\",\n          name: \"Gilded Hollow\"\n        },\n        {\n          fileName: \"1256064.data\",\n          name: \"Lost Precipice\"\n        },\n        {\n          fileName: \"1843274.data\",\n          name: \"Windswept Haven\"\n        }\n      ]\n    },\n    {\n      name: \"20. Concept and not released\",\n      maps: [\n        {\n          fileName: \"122695.data\",\n          name: \"Empty Plane\"\n        },\n        {\n          fileName: \"184799.data\",\n          name: \"Empty Plane v1\"\n        },\n        {\n          fileName: \"197562.data\",\n          name: \"Empty Plane v2\"\n        },\n        {\n          fileName: \"875614.data\",\n          name: \"Unknown Mists Platforms\"\n        },\n        {\n          fileName: \"132853.data\",\n          name: \"Empty Box\"\n        },\n        {\n          fileName: \"1255516.data\",\n          name: \"Guild Coliseum\"\n        },\n        {\n          fileName: \"1498193.data\",\n          name: \"Concept sPVP Map 1\"\n        },\n        {\n          fileName: \"1513556.data\",\n          name: \"Concept sPVP Map 2\"\n        },\n        {\n          fileName: \"1513607.data\",\n          name: \"Concept sPVP Map 3\"\n        },\n        {\n          fileName: \"1513620.data\",\n          name: \"Concept sPVP Map 4\"\n        },\n        {\n          fileName: \"1513675.data\",\n          name: \"Concept sPVP Map 5\"\n        },\n        {\n          fileName: \"1712945.data\",\n          name: \"Concept sPVP Map 6\"\n        }\n      ]\n    }\n  ]\n};\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/* INCLUDES */\nconst LocalReader = require(\"./LocalReader/LocalReader\");\n\n/* PRIVATE VARS */\nconst _version = \"1.2.0\";\nconst _settings = {\n  t3dtoolsWorker: \"modules/t3dtools/t3dworker.js\",\n  concurrentTasks:\n    typeof navigator !== \"undefined\" ? navigator.hardwareConcurrency : 1\n};\n\nlet T3D;\n\n/* PUBLIC PROPERTIES */\n\n/**\n * Tyria 3D Library main module.\n *\n * Use this static class to access file parsers- and data renderer classes.\n *\n * This class also works as a factory for creating\n * LocalReader instances that looks up and inflates files from the Guild Wars 2 .dat.\n * @module T3D\n */\nT3D = module.exports = {\n  /**\n   * The current library version. Used to make sure local storage caches are not\n   * shared between different releases.\n   *\n   * @property version\n   * @type String\n   */\n  version: _version,\n\n  /* FILES */\n\n  /**\n   * A static reference to the GW2File class, the preferred way of\n   * accessing this class.\n   *\n   * @memberof T3D\n   * @property GW2File\n   * @type Class\n   */\n  GW2File: require(\"./format/file/GW2File\"),\n\n  /**\n   * A static reference to the GW2Chunk class, the preferred way of\n   * accessing this class.\n   *\n   * @memberOf T3D\n   * @property GW2Chunk\n   * @type Class\n   */\n  GW2Chunk: require(\"./format/file/GW2Chunk\"),\n\n  /* RENDERERS */\n\n  /**\n   * A static reference to the DataRenderer class, the preferred way of\n   * accessing this class.\n   *\n   * @readonly\n   * @property DataRenderer\n   * @type Class\n   */\n  DataRenderer: require(\"./dataRenderer/DataRenderer\"),\n\n  /**\n   * A static reference to the EnvironmentRenderer class, the preferred way of\n   * accessing this class.\n   *\n   * @readonly\n   * @property EnvironmentRenderer\n   * @type Class\n   */\n  EnvironmentRenderer: require(\"./dataRenderer/EnvironmentRenderer\"),\n\n  /**\n   * A static reference to the HavokRenderer class, the preferred way of\n   * accessing this class.\n   *\n   * @readonly\n   * @property HavokRenderer\n   * @type Class\n   */\n  HavokRenderer: require(\"./dataRenderer/HavokRenderer\"),\n\n  /**\n   * A static reference to the PropertiesRenderer class, the preferred way of\n   * accessing this class.\n   *\n   * @readonly\n   * @property PropertiesRenderer\n   * @type Class\n   */\n  PropertiesRenderer: require(\"./dataRenderer/PropertiesRenderer\"),\n\n  /**\n   * A static reference to the SingleModelRenderer class, the preferred way of\n   * accessing this class.\n   *\n   * @readonly\n   * @property SingleModelRenderer\n   * @type Class\n   */\n  SingleModelRenderer: require(\"./dataRenderer/SingleModelRenderer\"),\n\n  /**\n   * A static reference to the TerrainRenderer class, the preferred way of\n   * accessing this class.\n   *\n   * @readonly\n   * @property TerrainRenderer\n   * @type Class\n   */\n  TerrainRenderer: require(\"./dataRenderer/TerrainRenderer\"),\n\n  /**\n   * A static reference to the ZoneRenderer class, the preferred way of\n   * accessing this class.\n   *\n   * @readonly\n   * @property ZoneRenderer\n   * @type Class\n   */\n  ZoneRenderer: require(\"./dataRenderer/ZoneRenderer\"),\n\n  /**\n   * A static reference to the StringRenderer class, the preferred way of\n   * accessing this class.\n   *\n   * @readonly\n   * @property StringRenderer\n   * @type Class\n   */\n  StringRenderer: require(\"./dataRenderer/StringRenderer\"),\n\n  /* LOGGING */\n\n  /**\n   * A static reference to the static Logger object, the preferred way of\n   * accessing this object. A simple way of providing your own logging methods\n   * is to simply overwrite any or all of the logging methods specified in\n   * {{#crossLink \"Logger/logFunctions:property\"}}{{/crossLink}}\n   *\n   * @property Logger\n   * @type Object\n   */\n  Logger: require(\"./Logger\"),\n\n  /* SETTINGS */\n\n  /**\n   * Contains a list of known map fileID:s and their names. Used in order to quickly\n   * look up what maps are in a .dat file. Note that this property is hard coded and\n   * has high probablity of being outdated. Also note that the names are just guesses\n   * by RequestTimeout.\n   *\n   * The format of this list objects is\n   *\n   *\n   * \t{\n   *  \tmaps : [\n   *\t  \t\t{\n   *     \t\t\tname:\"World Area Name\",\n   *\t       \t\tmaps:[\n   *\t         \t\t{ fileName :\"[numeric fileId].data\", name:\"Map Name One\" },\n   *\t           \t\t{ fileName :\"[numeric fileId].data\", name:\"Map Name Two\" },\n   *\t             \t{ fileName :\"[numeric fileId].data\", name:\"Map Name Three\" }\n   *\t              ]\n   *           },\n   *\t         {\n   *\t\t\t    name:\"Another World Area Name\",\n   *\t\t \t   \tmaps:[\n   *\t\t \t\t   \t{ fileName :\"[numeric fileId].data\", name:\"Map Name 408\" }\n   *\t\t\t    ]\n   *\t\t     }\n   * \t\t]\n   *   }\n   *\n   * @readonly\n   * @property MapFileList\n   * @type Object\n   */\n  MapFileList: require(\"./MapFileList\"),\n\n  /* UTILS */\n\n  /**\n   * A static reference to the MaterialUtils class.\n   *\n   * @readonly\n   * @property MaterialUtils\n   * @type Object\n   */\n  MaterialUtils: require(\"./util/MaterialUtils.js\"),\n\n  /**\n   * A static reference to the MathUtils class.\n   *\n   * @readonly\n   * @property MathUtils\n   * @type Object\n   */\n  MathUtils: require(\"./util/MathUtils.js\"),\n\n  /**\n   * A static reference to the ParserUtils class.\n   *\n   * @readonly\n   * @property ParserUtils\n   * @type Object\n   */\n  ParserUtils: require(\"./util/ParserUtils.js\"),\n\n  /**\n   * A static reference to the RenderUtils class.\n   *\n   * @readonly\n   * @property RenderUtils\n   * @type Object\n   */\n  RenderUtils: require(\"./util/RenderUtils.js\"),\n\n  /**\n   * A static reference to the PersistantStore class.\n   *\n   * @readonly\n   * @property PersistantStore\n   * @type Class\n   */\n  PersistantStore: require(\"./LocalReader/PersistantStore\"),\n\n  /**\n   * A static reference to the FileTypes tools and list.\n   *\n   * @readonly\n   * @property FileTypes\n   * @type Object\n   */\n  FileTypes: require(\"./LocalReader/FileTypes\"),\n\n  /* PUBLIC METHODS */\n\n  /**\n   * Creates a new instance of LocalReader with an pNaCl inflater connected to it.\n   *\n   * @async\n   * @param  {File}   \tfile\t\tCore JS File instance, must refer to a GW2 .dat file\n   * @param  {Function}\tcallback\tCallback function, fired when the file index is fully\n   *                             \t\tconstructed. Takes no arguments.\n   *\n   * @param  {String} \tt3dtoolsWorker URL to the inflater file. If omitted\n   *                               \t_settings.t3dtoolsWorker will be used instead.\n   *\n   * @return {LocalReader}\t\t\tThe contructed LocalReader, note that this object\n   *                             \t\twill not be fully initialized until the callback\n   *                             \t\tis fired.\n   */\n  getLocalReader: function(file, callback, t3dtoolsWorker) {\n    let path = t3dtoolsWorker || _settings.t3dtoolsWorker;\n\n    // Create the instance and init the threads\n    const lrInstance = new LocalReader({\n      workerPath: path,\n      workersNb: _settings.concurrentTasks\n    });\n\n    /// Callback with the lrInstance\n    lrInstance.openArchive(file).then(() => {\n      callback(lrInstance);\n    });\n\n    return lrInstance;\n  },\n\n  /**\n   * Utility method for acceccing a list containing information about all files\n   * in the .dat connected to the provided LocalReader instance. This method first\n   * tries to read a local indexing list from the client's localstorage and\n   * fallbacks to generating the list by scanning the MFT indices of the .dat\n   * and peeking each file in order to find out what filetype it has.\n   *\n   * Note that peeking the files is the time consuming task, so if you don't want\n   * yout application to spend time indexing the .dat and have a priori knowledge\n   * about the required file Id's you should not use this method.\n   *\n   * @async\n   * @param  {LocalReader}\tlocalReader A fully initialized LocalReader instance\n   * @param  {Function}\t\tcallback    Fires when the index has been loaded\n   *                                 \t\tfrom the localstorage or after it has\n   *                                 \t\tbeen built and stored in localstorage.\n   *                                 \t\tTakes the generated object list of\n   *                                 \t\tfiles as an argument. This list groups\n   *                                 \t\tarrays of MFT indices per file type,\n   *                                 \t\tfor exmample:\n   *\n   *\n   * \t{\n   *\t  \t\"Unknown\"\t: [444, 555, 333],\n   *\t  \t\"MODL\"\t\t: [444, 555, 333],\n   * \t  \t\"String\"\t: [666, 777, 888]\n   * \t}\n   *\n   * For more details see\n   * {{#crossLink \"LocalReader/listFiles:method\"}}{{/crossLink}}\n   */\n  getFileListAsync: function(localReader, callback) {\n    // Because the localreader API changed we reform the data as wanted\n    localReader.readFileList().then(result => {\n      let returnObj = {};\n      for (let fileEntry of result) {\n        if (returnObj[fileEntry.fileType] === undefined)\n          returnObj[fileEntry.fileType] = [];\n        returnObj[fileEntry.fileType].push(fileEntry.mftId);\n      }\n      callback(returnObj);\n    });\n  },\n\n  /**\n\t * Utility method for acceccing a list containing information about all map files\n\t * in the .dat connected to the provided LocalReader instance. This method first\n\t * tries to read a local indexing list from the client's localstorage and\n\t * fallbacks to generating the list by scanning the MFT indices of the .dat\n\t * and peeking each file in order to find out what filetype it has.\n\t *\n\t * If the searchAll flag is not set to true, this process will only scan files\n\t * from the {{#crossLink \"T3D/MapFileList:property\"}}{{/crossLink}}\n\t * \n\t * @async\n\t * @param {LocalReader}\tlocalReader\tA fully initialized LocalReader instance\n\t * @param {Function}\tcallback\tFires when the index has been loaded\n\t *                                 \tfrom the localstorage or after it has\n\t *                                 \tbeen built and stored in localstorage.\n\t *                                 \tTakes the generated object list of\n\t *                                 \tfiles as an argument. This list groups\n\t *                                 \tarrays of MFT indices per file type,\n\t *                                 \tfor exmample:\n\t * \n\t * \t\t{\t\n\t * \t\t\tmaps:[\n\t * \t\t\t\t{\n\t * \t\t\t\t\tname: 'Heart of Maguuma',\n\t * \t\t\t\t\tmaps: [\n\t * \t\t\t\t\t\t{fileName:1151420, name:'HoT BWE3 Raid'},\n\t * \t\t\t\t\t\t{fileName:969663, name:'Verdant Brink}\n\t * \t\t\t\t\t]\n\t * \t\t\t\t},\n\t * \t\t\t\t{\n\t * \t\t\t\t\tname: 'Unknown maps',\n\t * \t\t\t\t\tmaps: [\n\t * \t\t\t\t\t\t{fileName:12345678, name:'Unknown map 12345678'}\n\t * \t\t\t\t\t]\n\t * \t\t\t\t}\n\t * \t\t\t]\n\t \n\t*\t    };\n\t* @param {boolean} searchAll if true forces re-indexing of entire dat.\n\t*/\n  getMapListAsync: function(localReader, callback, searchAll) {\n    // Define a function that transforms the localreader output to what we want\n    function restoreOuput(array) {\n      let returnArray = [];\n      for (let elt of array) {\n        let category = returnArray.findIndex(i => i.name === elt.category);\n        if (category === -1)\n          category =\n            returnArray.push({\n              name: elt.category,\n              maps: []\n            }) - 1;\n        returnArray[category].maps.push({\n          fileName: elt.baseId,\n          name: elt.name\n        });\n      }\n      // And resort it in order\n      returnArray.sort((i, j) => {\n        if (i.name < j.name) return -1;\n        if (i.name > j.name) return 1;\n        return 0;\n      });\n      return {\n        maps: returnArray\n      };\n    }\n\n    /// If seachAll flag is true, force a deep search\n    if (searchAll) {\n      localReader.readFileList().then(() => {\n        callback(restoreOuput(localReader.getMapList()));\n      });\n    }\n    /// If not, it's only looking through known maps\n    else {\n      callback(restoreOuput(localReader.getMapList()));\n    }\n  },\n\n  /**\n   * Utility method used for rendering map files. Loads a map file and applies\n   * the provided renderers to it.\n   *\n   * @async\n   * @param  {LocalReader}\tlocalReader A fully initialized LocalReader instance\n   * @param  {Number}   \t\tfileName\tThe File Id of a mapc file.\n   * @param  {Array}   \t\trenderers\tAn array of renderer classes. Each\n   *                               \t\tclass should extend\n   *                               \t\t{{#crossLink \"DataRenderer\"}}{{/crossLink}}\n   * @param  {Function}\t\tcallback    Callback function, takes the shared\n   *                                 \t\trenderer context as an argument.\n   * @param  {Class}\t\t\tlogger      A logger class of the same type as\n   *                               \t\t{{#crossLink \"Logger\"}}{{/crossLink}}\n   */\n  renderMapContentsAsync: function(\n    localReader,\n    fileName,\n    renderers,\n    callback,\n    logger\n  ) {\n    /// VO for storing result from renderers\n    let context = {};\n\n    /// Make sure we got an actuall ID number\n    if (parseInt(fileName)) {\n      /// File name is baseId, load using local reader.\n      localReader\n        .readFile(parseInt(fileName), false, false, undefined, undefined, true)\n        .then(result => {\n          let arrayBuffer = result.buffer;\n\n          /// Set up datastream\n          let ds = new DataStream(arrayBuffer, 0, DataStream.LITTLE_ENDIAN);\n\n          /// Initiate Map file object. Connect callback\n          let mapFile = new T3D.GW2File(ds, 0);\n\n          /// Populate VO by running the renderers\n          const runAllRenderers = function(i) {\n            /// Run each renderer\n            if (i < renderers.length) {\n              T3D.runRenderer(\n                renderers[i].renderClass,\n                localReader,\n                Object.assign(renderers[i].settings, {\n                  mapFile: mapFile\n                }),\n                context,\n                runAllRenderers.bind(this, i + 1)\n              );\n            }\n\n            /// Fire callback with VO when done\n            else {\n              callback(context);\n            }\n          };\n\n          /// Starting point for running each renderer\n          runAllRenderers(0);\n        });\n    }\n\n    /// Primitive error message...\n    else {\n      let outputLogger = logger || T3D.Logger;\n      outputLogger.log(\n        T3D.Logger.TYPE_ERROR,\n        \"Map id must be an integer!, was:\",\n        fileName\n      );\n    }\n  },\n\n  /**\n   * Utility method for applying a single renderer to a LocalReader insatnce.\n   *\n   * @async\n   *\n   * @param  {Class}\t\trenderClass\tA class extending\n   *                                \t{{#crossLink \"DataRenderer\"}}{{/crossLink}}\n   * @param  {LocalReader}localReader A fully initialized LocalReader instance\n   * @param  {Object}\t\tsettings    Settings passed to the renderer. Often\n   *                               \tspecifies thinks like what file ID should\n   *                               \tbe loaded.\n   * @param  {Object}\t\tcontext     The shared renderer context value object.\n   * @param  {Function} \tcb          Callback method passed to the renderAsync\n   *                                 \tmethod of the renderer.\n   */\n  runRenderer: function(RenderClass, localReader, settings, context, cb) {\n    let r = new RenderClass(localReader, settings, context);\n\n    r.renderAsync(cb);\n  },\n\n  /**\n   * @param  {Object} context      \tA shared renderer context value object.\n   * @param  {Class} \tclazz        \tA class extending\n   *                                \t{{#crossLink \"DataRenderer\"}}{{/crossLink}}.\n   *                                \tSpecifies for renderer class you want to read\n   *                                \toutput.\n   * @param  {String} propName     \tThe name of the property written by the\n   *                                \trenderer that should retrtieved.\n   * @param  {any} \tdefaultValue \tThis value is passed back if no data could\n   *                              \tbe found.\n   * @return {any}    \t\t\t\tThe specified value from the conext if any,\n   *                          \t\totherwise defaultValue.\n   */\n  getContextValue: function(context, clazz, propName, defaultValue) {\n    let output = context[clazz.name];\n    if (output) {\n      return output[propName] ? output[propName] : defaultValue;\n    }\n    return defaultValue;\n  },\n\n  /**\n   * Check if the client web browser can render WebGL 3D content.\n   *\n   * @private\n   * @param  {boolean} returnContext flag making this method return the canvas object instead of true\n   * @return {boolean} true if the client is WebGL enabled, false otherwise\n   */\n  hasWebGL: function(returnContext) {\n    if (window.WebGLRenderingContext) {\n      let canvas = document.createElement(\"canvas\");\n\n      let names = [\"webgl\", \"experimental-webgl\", \"moz-webgl\", \"webkit-3d\"];\n\n      let context = false;\n\n      for (let i = 0; i < 4; i++) {\n        try {\n          context = canvas.getContext(names[i]);\n          if (context && typeof context.getParameter === \"function\") {\n            // WebGL is enabled\n            if (returnContext) {\n              // return WebGL object if the function's argument is present\n              return {\n                name: names[i],\n                gl: context\n              };\n            }\n            // else, return just true\n            return true;\n          }\n        } catch (e) {}\n      }\n\n      // WebGL is supported, but disabled\n      return false;\n    }\n\n    // WebGL not supported\n    return false;\n  }\n};\n\n/* PRIVATE METHODS */\n\n/**\n * Performs checks for required browser capabilities and required third party libraries.\n * Loggs any warnings or error messages.\n *\n * @private\n * @return {Number} The ammount of errors and warnings generated.\n */\nfunction checkRequirements() {\n  let numErrors = 0;\n\n  if (!global.window || !window.indexedDB) {\n    T3D.Logger.log(\n      T3D.Logger.TYPE_ERROR,\n      \"T3D persistant storing and loading requires indexedDB support.\"\n    );\n    numErrors++;\n  }\n\n  if (typeof DataStream === \"undefined\") {\n    T3D.Logger.log(\n      T3D.Logger.TYPE_ERROR,\n      \"T3D core functionality requires DataStream library.\"\n    );\n    numErrors++;\n  }\n\n  if (typeof THREE === \"undefined\") {\n    T3D.Logger.log(\n      T3D.Logger.TYPE_WARNING,\n      \"T3D mesh generation requires three.js library.\"\n    );\n    numErrors++;\n  }\n\n  if (numErrors < 1) {\n    T3D.Logger.log(\n      T3D.Logger.TYPE_MESSAGE,\n      \"Tyria 3D API v\" + T3D.version + \" initialized.\"\n    );\n  }\n\n  return numErrors;\n}\n\n/// Library checks requirements on startup\ncheckRequirements();\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst GW2File = require(\"../format/file/GW2File\");\n\n/**\n * Base class for data interpretors a.k.a. 'Renderers'\n *\n * Renderers are classes that collect and interpret data from the dat file.\n *\n * A {{#crossLink \"LocalReader\"}}{{/crossLink}} instance is used for accessing data from the dat.\n *\n * A {{#crossLink \"Logger\"}}{{/crossLink}} is used for posting progress output or error messages.\n *\n * Most Renderers use one or more\n * {{#crossLink \"GW2Chunk\"}}GW2Chunks{{/crossLink}}, typed data structures that can be read from\n * {{#crossLink \"GW2File\"}}GW2Files{{/crossLink}}.\n *\n * The generated data, be it strings, numbers or meshes are put into a value object structure called\n * the 'context'. The context can store data generated by multiple renderers and makes sure each\n * renderer type, or class has it's own value object within the context. This enables one renderer\n * to read data written by another renderer wihtout having to worry about overwriting existing data\n * within the context. Keep in mind that you will have to manually pass and clean the conext object!\n *\n * A clean context object should just be the empty javasript object : {}.\n *\n * When a Renderer is done it will fire the callback and any view interrested in retrieving the generated\n * data from the context can read it using\n * {{#crossLink \"T3D/getContextValue:method\"}}{{/crossLink}}.\n *\n *\n *\n *\n * @class DataRenderer\n * @constructor\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nclass DataRenderer {\n  constructor(localReader, settings, context, logger) {\n    /// Just storing parameters\n    this.localReader = localReader;\n    this.settings = settings;\n    if (!settings) {\n      settings = {};\n    }\n    this.context = context;\n    this.context[this.constructor.name] = {};\n\n    if (logger) this.logger = logger;\n    else this.logger = T3D.Logger;\n  }\n\n  /**\n   * Gets the output value object for a specified class within the context.\n   *\n   * @param  {Class} otherClass The class to fetch the output value object for.\n   * If not specified the class of this instance will be used.\n   * @return {Object}            The output value object for this class within the context.\n   */\n  getOutput(otherClass) {\n    return this.context[otherClass ? otherClass.name : this.constructor.name];\n  }\n\n  /**\n   * Basic rendering of unknown files. Output fileds generated:\n   *\n   * - *fileId* The fileId passed in the settings parameter when constructing this instance.\n   *\n   * - *rawData* An ArrayBuffer containg the infalted binary data of the loaded file.\n   *\n   * - *rawString* A string representation of the rawData\n   *\n   * - *image* A value object witht he fields 'width', 'height' and 'data' describing a RGBA bitmap\n   * image. Only set if the loaded file was a texture.\n   *\n   * - *file* A GW2File representation of the loaded file. Only set if the loaded file was a Pack File.\n   *\n   * @async\n   * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n   */\n  renderAsync(callback) {\n    this.localReader\n      .readFile(this.settings.id, false, false, undefined, undefined, true)\n      .then(result => {\n        let inflatedData = result.buffer;\n\n        /// Set fileId so callers can identify this VO\n        this.getOutput().fileId = this.settings.id;\n\n        /// Share inflated data\n        this.getOutput().rawData = inflatedData;\n\n        /// Construct raw string\n        let uarr = new Uint8Array(inflatedData);\n        let textDecoder = new TextDecoder(\"latin2\");\n        this.getOutput().rawString = textDecoder.decode(uarr);\n\n        /// Check if this is an PF or ATEX file\n        // Binareis are MZ\n        let ds = new DataStream(inflatedData);\n        let first4 = ds.readCString(4);\n\n        /// Do special stuff for different fcc signatures\n        /// fourcc != fcc::ATEX && fourcc != fcc::ATEC && fourcc != fcc::ATEP &&\n        /// fourcc != fcc::ATET && fourcc != fcc::ATEU && fourcc != fcc::ATTX)\n        if (\n          first4 === \"ATEX\" ||\n          first4 === \"ATEC\" ||\n          first4 === \"ATEP\" ||\n          first4 === \"ATET\" ||\n          first4 === \"ATEU\" ||\n          first4 === \"ATTX\"\n        ) {\n          this.localReader\n            .readFile(this.settings.id, true, false, undefined, undefined, true)\n            .then(result => {\n              /// Create image using returned data.\n              let image = {\n                data: new Uint8Array(result.buffer),\n                width: result.imageWidth,\n                height: result.imageHeight\n              };\n\n              this.getOutput().image = image;\n              callback();\n            });\n        } else if (first4.indexOf(\"PF\") === 0) {\n          this.getOutput().file = new GW2File(ds, 0);\n          callback();\n        } else {\n          this.getOutput().file = null;\n          callback();\n        }\n      });\n  }\n}\n\nmodule.exports = DataRenderer;\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst MapEnvUtils = require(\"../util/MapEnvUtils\");\nconst DataRenderer = require(\"./DataRenderer\");\n\n/**\n *\n * A renderer that generates some of the environment objects of a map.\n *\n * @class EnvironmentRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"mapFile\", a GW2File.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nclass EnvironmentRenderer extends DataRenderer {\n  constructor(localReader, settings, context, logger) {\n    super(localReader, settings, context, logger);\n\n    this.mapFile = this.settings.mapFile;\n  }\n\n  /**\n   * Output fileds generated:\n   *\n   * - *hazeColor* Array of RGBA values describing the global haze color of the map.\n   * - *lights* An array of THREE.DirectionalLight and  THREE.AmbientLight objects.\n   * - *hasLight* Boolean is false if no directional lights were added to \"lights\".\n   * - *skyElements* A textured THREE.Mesh skybox.\n   *\n   * @async\n   * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n   */\n  renderAsync(callback) {\n    let environmentChunkData = this.mapFile.getChunk(\"env\").data;\n    let parameterChunkData = this.mapFile.getChunk(\"parm\").data;\n\n    /// Set renderer clear color from environment haze\n    let hazeColor = MapEnvUtils.getHazeColor(environmentChunkData);\n    let hazeColorAsInt =\n      hazeColor[2] * 256 * 256 + hazeColor[1] * 256 + hazeColor[0];\n    this.getOutput().hazeColor = hazeColor;\n\n    /// Add directional lights to output. Also write hasLight flag\n    let lightData = MapEnvUtils.parseLights(environmentChunkData);\n    this.getOutput().hasLight = lightData.hasLight;\n    this.getOutput().lights = lightData.lights;\n\n    /// Generate skybox\n    this.getOutput().skyElements = MapEnvUtils.parseSkybox(\n      environmentChunkData,\n      parameterChunkData,\n      hazeColorAsInt,\n      // TODO: Move outside of library\n      [\"img/193068.png\", \"img/193070.png\", \"img/193072.png\"],\n      this.localReader\n    ).skyElements;\n\n    /// All parsing is synchronous, just fire callback\n    callback();\n  }\n}\n\nmodule.exports = EnvironmentRenderer;\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst DataRenderer = require(\"./DataRenderer\");\nconst MapHavokUtils = require(\"../util/MapHavokUtils\");\n\n/**\n *\n * A renderer that generates meshes describing the collisions of a map.\n *\n * @class HavokRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"mapFile\", a GW2File. If \"visible\" is specified and true, the generated meshes will be textured\n * with a MeshNormalMaterial, otherwise they will not be visible.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\n\nclass HavokRenderer extends DataRenderer {\n  constructor(localReader, settings, context, logger) {\n    super(localReader, settings, context, logger);\n\n    this.mapFile = this.settings.mapFile;\n\n    this.lastP = -1;\n    this.seed = 1;\n    this.meshes = [];\n  }\n\n  /**\n   * Output fileds generated:\n   *\n   * - *boundingBox* Array of values describing the bounding box of all collision.\n   * - *meshes* An array of THREE.Mesh objects visualizing all collision in the map.\n   *\n   * @async\n   * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n   */\n  renderAsync(callback) {\n    // TODO:The design of this method pretty much requires one instance\n    // of the class per parallel async render. Should probably fix this\n    // at some point...\n\n    /// Get required chunks\n    this.havokChunkData = this.mapFile.getChunk(\"havk\").data;\n\n    /// Set static bounds to the bounds of the havk models\n    this.getOutput().boundingBox = this.havokChunkData.boundsMax;\n\n    this.meshes = [];\n\n    /// Grab model raw data from the chunk.\n    /// Add missing scale value to obs models.\n    let propModels = this.havokChunkData.propModels;\n    let zoneModels = this.havokChunkData.zoneModels;\n    let obsModels = this.havokChunkData.obsModels;\n    for (const mdl of obsModels) {\n      mdl.scale = 1;\n    }\n\n    /// Store geoms and animations from the file in the instance so we don't\n    /// have to pass them around too much. (fix this later)\n    this.geometries = this.havokChunkData.geometries;\n    this.animations = this.havokChunkData.animations;\n\n    /// Render \"prop\", \"zone\" and \"obs\" models in that order.\n    let renderPropModelsCB = () => {\n      this.renderModels(zoneModels, \"zone\", renderZoneModelsCB);\n    };\n    const renderZoneModelsCB = () => {\n      this.renderModels(obsModels, \"obs\", callback);\n    };\n    this.renderModels(propModels, \"prop\", renderPropModelsCB);\n  }\n\n  renderModels(models, title, callback) {\n    MapHavokUtils.renderModels(\n      {\n        settings: this.settings,\n        lastP: this.lastP,\n        geometries: this.geometries,\n        animations: this.animations,\n        havokChunkData: this.havokChunkData,\n        meshes: this.meshes,\n        output: { meshes: [] }\n      },\n      models,\n      title,\n      output => {\n        // Add to current output before calling the callback\n        let currentOutput = this.getOutput().meshes;\n        this.getOutput().meshes = currentOutput\n          ? currentOutput.concat(output.meshes)\n          : output.meshes;\n        callback();\n      }\n    );\n  }\n}\n\nmodule.exports = HavokRenderer;\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst DataRenderer = require(\"./DataRenderer\");\nconst MapPropsUtils = require(\"../util/MapPropsUtils\");\n\n/**\n *\n * A renderer that generates property models for a map.\n *\n * @class PropertiesRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"mapFile\", a GW2File.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\n\nclass PropertiesRenderer extends DataRenderer {\n  constructor(localReader, settings, context, logger) {\n    super(localReader, settings, context, logger);\n\n    this.mapFile = this.settings.mapFile;\n  }\n\n  /**\n   * Renders all property meshes in a GW2 map described by the map's PROP chunk.\n   * Output fileds generated:\n   *\n   * - *meshes* An array of THREE.Mesh objects visualizing all property models refered by this map.\n   *\n   * @async\n   * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n   */\n  renderAsync(callback) {\n    let propertiesChunkData = this.mapFile.getChunk(\"prp2\").data;\n\n    if (!propertiesChunkData) {\n      callback();\n      return;\n    }\n\n    let props = propertiesChunkData.propArray;\n    let animProps = propertiesChunkData.propAnimArray;\n    let instanceProps = propertiesChunkData.propInstanceArray;\n    let metaProps = propertiesChunkData.propMetaArray;\n\n    /// Concat all prop types\n    props = props\n      .concat(animProps)\n      .concat(instanceProps)\n      .concat(metaProps);\n\n    /// Start serial loading and redering. (to allow re-using meshes and textures)\n    MapPropsUtils.renderIndex(this.localReader, props, 0, output => {\n      this.getOutput().meshes = output.meshes;\n      callback();\n    });\n  }\n\n  /**\n   * TODO: write description. Used for export feature\n   * @param  {Function} callback [description]\n   * @return {*}            [description]\n   */\n  getFileIdsAsync(callback) {\n    const propertiesChunkData = this.mapFile.getChunk(\"prp2\").data;\n\n    let props = propertiesChunkData.propArray;\n    const animProps = propertiesChunkData.propAnimArray;\n    const instanceProps = propertiesChunkData.propInstanceArray;\n    const metaProps = propertiesChunkData.propMetaArray;\n\n    props = props\n      .concat(animProps)\n      .concat(instanceProps)\n      .concat(metaProps);\n\n    MapPropsUtils.getIdsForProp(props, 0, callback);\n  }\n}\n\nmodule.exports = PropertiesRenderer;\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst ModelUtils = require(\"../util/ModelUtils\");\nconst DataRenderer = require(\"./DataRenderer\");\n\n/**\n *\n * A renderer that generates meshes for a single model file.\n *\n * @class SingleModelRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"id\" the base ID or file ID of the model to generate meshes for.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nclass SingleModelRenderer extends DataRenderer {\n  constructor(localReader, settings, context, logger) {\n    super(localReader, settings, context, logger);\n  }\n\n  /**\n   * Output fileds generated:\n   *\n   * - *meshes* An array of THREE.Mesh objects visualizing this model file.\n   *\n   * @async\n   * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n   */\n  renderAsync(callback) {\n    let self = this;\n\n    /// Get file id\n    let fileId = this.settings.id;\n    let showUnmaterialed = true;\n\n    /// Load the model file\n    let meshCache = {};\n    let textureCache = {};\n\n    /// Set up output array\n    self.getOutput().meshes = [];\n\n    ModelUtils.getMeshesForFilename(\n      fileId,\n      0x00ff00,\n      self.localReader,\n      meshCache,\n      textureCache,\n      showUnmaterialed,\n      true,\n      function(meshes, isCached, boundingSphere) {\n        if (meshes) {\n          meshes.forEach(function(mesh) {\n            mesh.boundingSphere = boundingSphere;\n            self.getOutput().meshes.push(mesh);\n          });\n        }\n\n        /// Fire callback after all meshes have been added.\n        meshCache = {};\n        callback();\n      }\n    );\n  }\n}\n\nmodule.exports = SingleModelRenderer;\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst DataRenderer = require(\"./DataRenderer\");\n\n/**\n *\n * A renderer that generates a list of readable strings from a \"strs\" file.\n *\n * @class StringRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"id\" the base ID or file ID of the string file to read strings from.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nclass StringRenderer extends DataRenderer {\n  constructor(localReader, settings, context, logger) {\n    super(localReader, settings, context, logger);\n  }\n\n  /**\n   * Output fileds generated:\n   *\n   * - *strings* An array of objects. Each object has a \"recid\"-property specifing on what index within the file\n   * a given string was found, and a \"value\"-property specigying the string value.\n   *\n   * - *language* An integer specifing the language of the loaded file.\n   *\n   * @async\n   * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n   */\n  renderAsync(callback) {\n    let self = this;\n\n    /// Get file id\n    let fileId = this.settings.id;\n    let showUnmaterialed = true;\n\n    /// Load the string file\n\n    /// Set up output array\n    this.getOutput().strings = [];\n\n    this.localReader\n      .readFile(this.settings.id, false, false, undefined, undefined, true)\n      .then(result => {\n        let inflatedData = result.buffer;\n        let ds = new DataStream(inflatedData);\n        let end = ds.byteLength - 2;\n\n        /// skip past fcc\n        ds.seek(4);\n\n        let entryHeaderDef = [\n          \"size\",\n          \"uint16\",\n          \"decryptionOffset\",\n          \"uint16\",\n          \"bitsPerSymbol\",\n          \"uint16\"\n        ];\n\n        let entryIndex = 0;\n\n        while (end - ds.position > 6) {\n          let entry = ds.readStruct(entryHeaderDef);\n          entry.size -= 6;\n\n          if (entry.size > 0) {\n            let isEncrypted =\n              entry.decryptionOffset !== 0 || entry.bitsPerSymbol !== 0x10;\n\n            /// UTF-16\n            if (!isEncrypted) {\n              let value = ds.readUCS2String(entry.size / 2);\n              self.getOutput().strings.push({\n                value: value,\n                recid: entryIndex\n              });\n            }\n\n            /// Other... ignored\n            else {\n            }\n          }\n\n          entryIndex++;\n        }\n\n        ds.seek(ds.byteLength - 2);\n        self.getOutput().language = ds.readUint16();\n        callback();\n      });\n  }\n}\n\nmodule.exports = StringRenderer;\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst DataRenderer = require(\"./DataRenderer\");\n\nconst MapTerrainUtils = require(\"../util/MapTerrainUtils\");\n\n/**\n *\n * A renderer that generates the meshes for the terrain of a map.\n *\n *\n * Requires a context previously populated by a\n * {{#crossLink \"EnvironmentRenderer\"}}{{/crossLink}}.\n *\n * @class TerrainRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"mapFile\", a GW2File.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nclass TerrainRenderer extends DataRenderer {\n  constructor(localReader, settings, context, logger) {\n    super(localReader, settings, context, logger);\n\n    this.mapFile = this.settings.mapFile;\n  }\n\n  /**\n   * Output fileds generated:\n   *\n   * - *terrainTiles* An array of THREE.Mesh objects visualizing terrain of the map.\n   *\n   * - *water* A THREE.Mesh object visualizing the bounds of the map.\n   *\n   * - *bounds* An object wiht x1, x2, y1, and y2 properties specifying the bounds of the map.\n   *\n   * @async\n   * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n   */\n  renderAsync(callback) {\n    /// Load all paged Images, requires inflation of other pack files!\n    const pagedImageId = this.mapFile.getChunk(\"trn\").data.materials.pagedImage;\n    this.localReader\n      .readFile(pagedImageId, false, false, undefined, undefined, true)\n      .then(result => {\n        return MapTerrainUtils.loadPagedImageCallback(\n          result.buffer,\n          this.mapFile,\n          this.settings.anisotropy,\n          this.getOutput(T3D.EnvironmentRenderer),\n          this.localReader\n        );\n      })\n      .then(terrainResult => {\n        // Populate the output\n        this.getOutput().terrainTiles = terrainResult.terrainTiles;\n        this.getOutput().water = terrainResult.water;\n        this.getOutput().bounds = terrainResult.mapRect;\n\n        callback();\n      });\n  }\n\n  /**\n   * TODO: write description. Used for export feature\n   *\n   * @param  {Function} callback [description]\n   * @return {*}            [description]\n   */\n  getFileIdsAsync(callback) {\n    callback(MapTerrainUtils.getTerrainFilesId(this.mapFile));\n  }\n}\n\nmodule.exports = TerrainRenderer;\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst DataRenderer = require(\"./DataRenderer\");\nconst MapZoneUtils = require(\"../util/MapZoneUtils\");\n\n/**\n *\n * A renderer that generates zone models for a map.\n *\n * @class ZoneRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"mapFile\", a GW2File.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nclass ZoneRenderer extends DataRenderer {\n  constructor(localReader, settings, context, logger) {\n    super(localReader, settings, context, logger);\n\n    this.mapFile = this.settings.mapFile;\n  }\n\n  /**\n   * Renders all zone meshes in a GW2 map described by the map's \"zon2\" chunk.\n   * Output fileds generated:\n   *\n   * - *meshes* An array of THREE.Mesh objects visualizing all zone models refered by this map.\n   *\n   * @async\n   * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n   */\n  renderAsync(callback) {\n    /// Set up output array\n    this.getOutput().meshes = [];\n\n    let zoneChunkData = this.mapFile.getChunk(\"zon2\").data;\n    let parameterChunkData = this.mapFile.getChunk(\"parm\").data;\n    // let terrainChunkData = this.mapFile.getChunk(\"trn\").data;\n    let mapRect = parameterChunkData.rect;\n\n    /// Zone data\n    let zones = zoneChunkData.zoneArray;\n    let zoneDefs = zoneChunkData.zoneDefArray;\n\n    /// Render each zone\n    let lastPct = -1;\n\n    const dataForUtils = {\n      localReader: this.localReader,\n      terrainTiles: this.getOutput(T3D.TerrainRenderer).terrainTiles,\n      output: { meshes: [] }\n    };\n\n    /// Main render loop, render each zone\n    const stepZone = i => {\n      let pct = Math.round((100.0 * i) / zones.length);\n      if (lastPct !== pct) {\n        T3D.Logger.log(\n          T3D.Logger.TYPE_PROGRESS,\n          \"Loading 3D Models (Zone)\",\n          pct\n        );\n        lastPct = pct;\n      }\n\n      if (i >= zones.length) {\n        callback();\n        return;\n      }\n\n      /// Main zone render function call\n      MapZoneUtils.renderZone(dataForUtils, zones[i], zoneDefs, mapRect, () => {\n        this.getOutput().meshes = this.getOutput().meshes.concat(\n          dataForUtils.output.meshes\n        );\n        stepZone(i + 1);\n      });\n    };\n\n    stepZone(0);\n  }\n}\n\nmodule.exports = ZoneRenderer;\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst HEAD_STRUCT = [\n  \"type\",\n  \"cstring:4\",\n  \"chunkDataSize\",\n  \"uint32\",\n  \"chunkVersion\",\n  \"uint16\",\n  \"chunkHeaderSize\",\n  \"uint16\",\n  \"offsetTableOffset\",\n  \"uint32\"\n];\n\n/**\n * Settings for resolving conflicting chunk names in different files.\n * @private\n * @property DUPLICATE_SETTINGS\n * @type {Object}\n */\nlet DUPLICATE_SETTINGS;\n\n// Replacement for DUPLICATE_SETTINGS, based on the name of the root property.\nconst PACKTOCHUNK = [\n  {\n    pack: \"MODL\",\n    chunk: \"ANIM\",\n    root: \"ModelFileAnimation\"\n  },\n  {\n    pack: \"MODL\",\n    chunk: \"GAME\",\n    root: \"ModelFileGame\"\n  },\n  {\n    pack: \"MODL\",\n    chunk: \"SKEL\",\n    root: \"ModelFileSkeleton\"\n  },\n  {\n    pack: \"MODL\",\n    chunk: \"TOOL\",\n    root: \"ModelFileTool\"\n  },\n  {\n    pack: \"cntc\",\n    chunk: \"Main\",\n    root: \"PackContent\"\n  },\n  {\n    pack: \"mMet\",\n    chunk: \"Main\",\n    root: \"PackMapMetadata\"\n  },\n  {\n    pack: \"AMAT\",\n    chunk: \"TOOL\",\n    root: \"AmatToolParams\"\n  },\n  {\n    pack: \"cmaC\",\n    chunk: \"main\",\n    root: \"CollideModelManifest\"\n  }\n];\n\n// Builds the DUPLICATE_SETTINGS based on the provided T3D.formats.\n// Required to be done dynamically since the 32 bit and 64bits have different ordering\nfunction genDuplicateSettings() {\n  // Early return if the settings have been already generated\n  if (DUPLICATE_SETTINGS) return;\n\n  function getRootName(Definition) {\n    let a = new Definition();\n    return Object.keys(a).filter(v => {\n      return a[v] === a.__root && v !== \"__root\";\n    })[0];\n  }\n\n  DUPLICATE_SETTINGS = {};\n  for (let setting of PACKTOCHUNK) {\n    let regex = new RegExp(`^${setting.root}(V[0-9]*)?$`);\n    let chunkDef = T3D.formats.filter(v => {\n      return v.name === setting.chunk;\n    });\n\n    for (let defsIdx in chunkDef) {\n      let defs = chunkDef[defsIdx].versions;\n      let lastVersion = defs[Object.keys(defs).pop()];\n      let rootName = getRootName(lastVersion);\n      if (rootName.match(regex)) {\n        if (!DUPLICATE_SETTINGS[setting.chunk])\n          DUPLICATE_SETTINGS[setting.chunk] = [];\n        DUPLICATE_SETTINGS[setting.chunk][defsIdx] = setting.pack;\n        break;\n      }\n    }\n  }\n}\n\n/**\n * Basic chunk parsing functionality for Guild Wars 2 file chunks\n *\n * @constructor\n * @param {DataStream} ds A DataStream containing deflated chunk binary data.\n * @param {Number} addr Offset of chunk start within the DataStream\n */\nclass GW2Chunk {\n  constructor(ds, addr) {\n    // Early returns if already called, it defines the DUPLICATE_SETTINGS variable\n    genDuplicateSettings();\n\n    /**\n     * @property {DataStream} ds The DataStream data source used by this chunk.\n     */\n    this.ds = ds;\n\n    /**\n     * @property {Number} addr The address to this Chunk within ds.\n     */\n    this.addr = addr;\n\n    /**\n     * @property {Object} data The typed data read from the body of this chunk.\n     */\n    this.data = null;\n\n    /**\n     * @property {Number} headerLength The length in bytes of the chunk header.\n     */\n    this.headerLength = NaN;\n\n    /**\n     * @property {Object} header Chunk header data.\n     */\n    this.loadHead();\n  }\n\n  /**\n   * Parses the chunk header data, populating the header property.\n   */\n  loadHead() {\n    this.ds.seek(this.addr);\n    this.header = this.ds.readStruct(HEAD_STRUCT);\n\n    this.headerLength = this.ds.position - this.addr;\n  }\n\n  /**\n   * @param  {String} fileType The main type of the pack file containing this chunk.\n   * Used for resolving chunk naming conflicts between pack file types.\n   * @return {Array}\tDataStream formatted array describing the data\n   * sctructures of this chunk\n   */\n  getDefinition(fileType) {\n    /// Normally we're looking for the 0th occurance\n    /// But some chunk names occur multiple times and we're interrested\n    /// in the N:th occurance of the definition.\n\n    /// I've no idea how this is automated, for now just use the\n    /// settings object I've put together from experience.\n    let useNthIndex = 0;\n\n    /// If this chunk has multiple definitions\n    /// get to know what def to use...\n    let fileTypes = DUPLICATE_SETTINGS[this.header.type];\n    if (fileTypes) {\n      useNthIndex = -1;\n\n      /// Check what file name entry matches this file name\n      for (let i = 0; i < fileTypes.length && useNthIndex === -1; i++) {\n        let ft = fileTypes[i];\n\n        if (ft === fileType) {\n          useNthIndex = i;\n        }\n      }\n\n      /// We didnt find this file name!\n      /// TODO: if you get this error, please update the DUPLICATE_SETTINGS above\n      if (useNthIndex === -1) {\n      }\n    }\n\n    let defsFound = 0;\n    for (let i = 0; i < T3D.formats.length; i++) {\n      let f = T3D.formats[i];\n\n      /// Chunk name needs to match\n      if (f.name === this.header.type) {\n        /// There needs to be a chunk def version matching the one specifiend\n\n        /// AND If this is the Nth occurance of the chunk definition\n        /// and we're looking for the Nth occurance, return it.\n\n        /// chunkVersion in the dat uses 0 indexing\n        if (defsFound === useNthIndex && f.versions[this.header.chunkVersion]) {\n          return new f.versions[this.header.chunkVersion]().__root;\n        }\n\n        defsFound++;\n      }\n    }\n  }\n\n  /**\n   * Parses the chunk main data, populating the data property.\n   *\n   * @param  {String} fileType The main type of the pack file containing this chunk.\n   * Used for resolving chunk naming conflicts between pack file types when\n   * looking up the structure definition for this chunk.\n   */\n  loadData(fileType) {\n    let def = this.getDefinition(fileType);\n\n    if (def) {\n      this.ds.seek(this.addr + this.headerLength);\n      this.data = this.ds.readStruct(def);\n    } else {\n      T3D.Logger.log(\n        T3D.Logger.TYPE_WARNING,\n        \"Could not find a definition for chunk\",\n        this.header.type,\n        \"version\",\n        this.header.chunkVersion,\n        \"file name\",\n        fileType\n      );\n    }\n  }\n\n  /**\n   * Retrieves the next chunk is the datastream. In practice this means the next chunk\n   * within the same pack file.\n   *\n   * @return {GW2Chunk} The next chunk if any, otherwise null.\n   */\n  next() {\n    try {\n      // Calculate actual data size, as mChunkDataSize\n      // does not count the size of some header variables\n      return new GW2Chunk(this.ds, this.addr + 8 + this.header.chunkDataSize);\n    } catch (e) {\n      /// Out of bounds probably\n    }\n    return null;\n  }\n}\n\nmodule.exports = GW2Chunk;\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst Chunk = require(\"./GW2Chunk\");\n\nconst HEAD_STRUCT = [\n  \"identifier\",\n  \"cstring:2\",\n  \"unknownField1\",\n  \"uint16\",\n  \"unknownField2\",\n  \"uint16\",\n  \"pkFileVersion\",\n  \"uint16\",\n  \"type\",\n  \"cstring:4\"\n];\n\n/**\n * Basic header and chunk parsing functionality for Guild Wars 2 pack files (PF)\n *\n * @constructor\n * @param {DataStream} ds A DataStream containing deflated file binary data.\n * @param {Number} addr Offset of file start within the DataStream\n * @param {boolean} noChunks If true, the file does not parse its\n * chunks on creation.\n */\nclass GW2File {\n  constructor(ds, addr, noChunks) {\n    /**\n     * @property {DataStream} ds The DataStream data source used by this file.\n     */\n    this.ds = ds;\n\n    /**\n     * @property {Number} addr The address to this File within ds.\n     */\n    this.addr = addr;\n\n    /// Not used anymore I think\n    this.data = null;\n\n    /**\n     * @property {Number} headerLength The length in bytes of the file header.\n     */\n    this.headerLength = NaN;\n\n    /**\n     * All {{#crossLink \"GW2Chunk\"}}chunks{{/crossLink}} contained in the file.\n     *\n     * @property chunks\n     * @type GW2Chunk[]\n     */\n    this.chunks = [];\n\n    /**\n     * @property {Object} header Chunk header data.\n     */\n    this.readHead();\n\n    if (!noChunks) {\n      this.readChunks();\n    }\n  }\n\n  /**\n   * Parses the file header data, populating the header property.\n   */\n  readHead() {\n    this.ds.seek(this.addr);\n    this.header = this.ds.readStruct(HEAD_STRUCT);\n    this.headerLength = this.ds.position - this.addr;\n  }\n\n  /**\n   * Parses the file headers and populates the chunks property.\n   */\n  readChunks() {\n    /// Reset chunks\n    this.chunks = [];\n\n    // var structs = this.getChunkStructs && this.getChunkStructs();\n\n    /// Load basic Chunk in order to read the chunk header.\n    let ch = new Chunk(this.ds, this.headerLength + this.addr);\n\n    // while(structs && ch!=null && ch.header.type){\n    while (ch != null && ch.header.type) {\n      /// Load data and pass file type if we need to determine what chunk entry to use\n      /// (Some chunks in different files share the same chunk name)\n      ch.loadData(this.header.type);\n      this.chunks.push(ch);\n\n      /// Load next basic Chunk in order to read the chunk header.\n      ch = ch.next();\n    }\n  }\n\n  /**\n   * Get a GW2Chunk from this file\n   *\n   * @param  {String} type The name, or type of the desired chunk.\n   * @return {GW2Chunk} The first GW2Chunk in this file matching the type name, or null if no matching GW2Chunk was found.\n   */\n  getChunk(type) {\n    for (let i = 0; i < this.chunks.length; i++) {\n      if (this.chunks[i].header.type.toLowerCase() === type.toLowerCase())\n        return this.chunks[i];\n    }\n    return null;\n  }\n\n  /**\n   * Provides a list of known header types and their parsing structure. Should be defined by each file type individually.\n   *\n   * @return {Object} An object mapping chunk identifiers to DataStream structure descriptors.\n   */\n  getChunkStructs() {\n    return {};\n  }\n}\n\nmodule.exports = GW2File;\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * Object describing the meaning of the bits in fvf integers.\n * @private\n * @type {Object}\n */\nlet fvfFormat = {\n  Position: 0x00000001,\n  /** < 12 bytes. Position as three 32-bit floats in the order x, y, z. */\n  Weights: 0x00000002,\n  /** < 4 bytes. Contains bone weights. */\n  Group: 0x00000004,\n  /** < 4 bytes. Related to bone weights. */\n  Normal: 0x00000008,\n  /** < 12 bytes. Normal as three 32-bit floats in the order x, y, z. */\n  Color: 0x00000010,\n  /** < 4 bytes. Vertex color. */\n  Tangent: 0x00000020,\n  /** < 12 bytes. Tangent as three 32-bit floats in the order x, y, z. */\n  Bitangent: 0x00000040,\n  /** < 12 bytes. Bitangent as three 32-bit floats in the order x, y, z. */\n  TangentFrame: 0x00000080,\n  /** < 12 bytes. */\n  UV32Mask: 0x0000ff00,\n  /** < 8 bytes for each set bit. Contains UV-coords as two 32-bit floats in the order u, v. */\n  UV16Mask: 0x00ff0000,\n  /** < 4 bytes for each set bit. Contains UV-coords as two 16-bit floats in the order u, v. */\n  Unknown1: 0x01000000,\n  /** < 48 bytes. Unknown data. */\n  Unknown2: 0x02000000,\n  /** < 4 bytes. Unknown data. */\n  Unknown3: 0x04000000,\n  /** < 4 bytes. Unknown data. */\n  Unknown4: 0x08000000,\n  /** < 16 bytes. Unknown data. */\n  PositionCompressed: 0x10000000,\n  /** < 6 bytes. Position as three 16-bit floats in the order x, y, z. */\n  Unknown5: 0x20000000\n  /** < 12 bytes. Unknown data. **/\n};\n\n/// Known material flags, not used yet\nconst knownflags = [\n  0, // 0 0000 0000 0000\t\tGround / Wall splashes\n  8, // 0 0000 0000 1000\t\tBroken Khylo roof DDS\n  9, // 0 0000 0000 1001\t\tTree leaves\n\n  520, // 0 0010 0000 1000\t\tSome LOD modules, fires, smoke, inside of tents (some DSS textures)\n\n  2056, // 0 1000 0000 1000\t\tSolid objects, also broken animations\n\n  /// Solids here are unhappy, or are they? could be animations etc\n  2057, // 0 1000 0000 1001\t\tWindmill sails, bushes, trees, but also a statue and a few pieces of wall\n\n  2060, // 0 1000 0000 1100\t\tA few solid objects, like wooden barricades, one(!) painting\n  2061, // 0 1000 0000 1101\t\tA few bushes, two paintings\n\n  2312, // 0 1001 0000 1000\t\tOpaque Clock tower main walls AND IVY\n  2316, // 0 1001 0000 1100\t\tBushes, inner flower walkway a ramp and a box\n\n  // Number 10\n  2568, // 0 1010 0000 1000\t\tLots of solids; walls, tents also some tent details WITH alpa\n\n  // Number 11\n  2569, // 0 1010 0000 1001\t\tSolids like walls and roofs and appernt non solids like ropes\n\n  2572, // 0 1010 0000 1100\t\tSolid wooden beems, lamp posts\n  2573, // 0 1010 0000 1101\t\tLamp holders, bushes, fences, apparent non solids\n  2584, // 0 1010 0001 1000\t\tFountain Well water\n\n  2824, // 0 1011 0000 1000\t\tWindows, sign arrows, cloth roofs (non solids) BUT straw roofs\n  2828, // 0 1011 0000 1100\t\tA few fence post (non solids)\n  2840, // 0 1011 0001 1000\t\tFountain running water + pipe water\n\n  4617, // 1 0010 0000 1001\t\tFound nothing\n  6664 // 1 1010 0000 1000\t\tTwo groups of solid boxes\n];\n\nmodule.exports = {\n  fvfFormat: fvfFormat\n};\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst MaterialUtils = require(\"./MaterialUtils\");\n\nfunction getMat(tex) {\n  return new THREE.MeshBasicMaterial({\n    map: tex,\n    side: THREE.BackSide,\n    fog: false,\n    depthWrite: false\n  });\n}\n\nfunction loadTextureWithFallback(\n  targetMatIndices,\n  materialArray,\n  filename,\n  fallbackFilename,\n  hazeColorAsInt,\n  localReader\n) {\n  function writeMat(mat) {\n    for (let i of targetMatIndices) {\n      materialArray[i] = mat;\n    }\n  }\n\n  function loadFallback() {\n    let mat = getMat(new THREE.TextureLoader().load(fallbackFilename));\n\n    writeMat(mat);\n  }\n\n  function errorCallback() {\n    setTimeout(loadFallback, 1);\n  }\n\n  let mat = getMat(\n    MaterialUtils.loadLocalTexture(\n      localReader,\n      filename,\n      null,\n      hazeColorAsInt,\n      errorCallback\n    )\n  );\n\n  writeMat(mat);\n}\n\nfunction getHazeColor(environmentChunkData) {\n  let hazes = environmentChunkData && environmentChunkData.dataGlobal.haze;\n\n  if (!hazes || hazes.length <= 0) {\n    return [190, 160, 60];\n  } else {\n    return hazes[0].farColor;\n  }\n}\n\nfunction parseLights(environmentChunkData) {\n  let lightOutput = [];\n\n  let lights = environmentChunkData\n    ? environmentChunkData.dataGlobal.lighting\n    : [\n        {\n          lights: [],\n          backlightIntensity: 1.0,\n          backlightColor: [255, 255, 255]\n        }\n      ];\n\n  let ambientLight;\n\n  let hasLight = false;\n\n  // Iterate on each light\n  for (let idx in lights) {\n    let light = lights[idx];\n\n    if (hasLight) break;\n\n    /// Directional lights\n    let sumDirLightIntensity = 0;\n\n    for (let dirLightData of light.lights) {\n      hasLight = true;\n\n      let color = new THREE.Color(\n        dirLightData.color[2] / 255.0,\n        dirLightData.color[1] / 255.0,\n        dirLightData.color[0] / 255.0\n      );\n\n      let directionalLight = new THREE.DirectionalLight(\n        color.getHex(),\n        dirLightData.intensity\n      );\n\n      directionalLight.position\n        .set(\n          -dirLightData.direction[0],\n          dirLightData.direction[2],\n          dirLightData.direction[1]\n        )\n        .normalize();\n\n      sumDirLightIntensity += dirLightData.intensity;\n\n      lightOutput.push(directionalLight);\n    } // END for each directional light in light\n\n    /// Add some random directional lighting if there was no, in order to se SOME depth on models\n    if (!light.lights || light.lights.length === 0) {\n      const directions = [[0, 1, 0, 0.3], [1, 2, 1, 0.3], [-1, -2, -1, 0.3]];\n\n      for (let lightDir of directions) {\n        const color = new THREE.Color(1, 1, 1);\n        let intensity = lightDir[3];\n        let directionalLight = new THREE.DirectionalLight(\n          color.getHex(),\n          intensity\n        );\n\n        directionalLight.position\n          .set(lightDir[0], lightDir[1], lightDir[2])\n          .normalize();\n\n        sumDirLightIntensity += intensity;\n\n        lightOutput.push(directionalLight);\n      }\n    }\n\n    /// Ambient light\n    // light.backlightIntensity /= sumDirLightIntensity +light.backlightIntensity;\n    light.backlightIntensity = sumDirLightIntensity; // light.backlightIntensity;\n    const color = new THREE.Color(\n      (light.backlightIntensity * (255.0 - light.backlightColor[2])) / 255.0,\n      (light.backlightIntensity * (255.0 - light.backlightColor[1])) / 255.0,\n      (light.backlightIntensity * (255.0 - light.backlightColor[0])) / 255.0\n    );\n\n    ambientLight = new THREE.AmbientLight(color);\n  } // END for each light in lighting\n\n  let ambientTotal = 0;\n  if (ambientLight) {\n    ambientTotal =\n      ambientLight.color.r + ambientLight.color.g + ambientLight.color.b;\n    lightOutput.push(ambientLight);\n  }\n\n  /// Parsing done, return hasLight flag and lights\n  return {\n    lights: lightOutput,\n    hasLight: hasLight || ambientTotal > 0\n  };\n}\n\nfunction parseSkybox(\n  environmentChunkData,\n  parameterChunkData,\n  hazeColorAsInt,\n  skyboxFallbackArray,\n  localReader\n) {\n  /// set up output array\n  let skyElements = [];\n\n  /// Grab sky texture.\n  /// index 0 and 1 day\n  /// index 2 and 3 evening\n  let skyModeTex =\n    this.environmentChunkData &&\n    this.environmentChunkData.dataGlobal.skyModeTex[0];\n\n  /// Fallback skyboxfrom dat.\n  if (!skyModeTex) {\n    skyModeTex = {\n      texPathNE: 1930687,\n      texPathSW: 193069,\n      texPathT: 193071\n    };\n  }\n\n  /// Calculate bounds\n  const bounds = parameterChunkData.rect;\n  let mapW = Math.abs(bounds.x1 - bounds.x2);\n  let mapD = Math.abs(bounds.y1 - bounds.y2);\n  let boundSide = Math.max(mapW, mapD);\n\n  let materialArray = [];\n\n  /// Load skybox textures, fallback to hosted png files.\n  loadTextureWithFallback(\n    [1, 4],\n    materialArray,\n    skyModeTex.texPathNE + 1,\n    skyboxFallbackArray[0],\n    hazeColorAsInt,\n    localReader\n  );\n  loadTextureWithFallback(\n    [0, 5],\n    materialArray,\n    skyModeTex.texPathSW + 1,\n    skyboxFallbackArray[1],\n    hazeColorAsInt,\n    localReader\n  );\n  loadTextureWithFallback(\n    [2],\n    materialArray,\n    skyModeTex.texPathT + 1,\n    skyboxFallbackArray[2],\n    hazeColorAsInt,\n    localReader\n  );\n  materialArray[3] = new THREE.MeshBasicMaterial({\n    visible: false\n  });\n\n  /// Create skybox geometry\n  const boxSize = 1024;\n  let skyGeometry = new THREE.BoxGeometry(boxSize, boxSize / 2, boxSize); // Width Height Depth\n\n  /// Ugly way of fixing UV maps for the skybox (I think)\n  for (let idx in skyGeometry.faceVertexUvs[0]) {\n    let vecs = skyGeometry.faceVertexUvs[0][idx];\n\n    let face = Math.floor(idx / 2);\n\n    // PX NX\n    // PY NY\n    // PZ NZ\n\n    /// PX - WEST \tNX - EAST\n    if (face === 0 || face === 1) {\n      for (let vec2 of vecs) {\n        vec2.x = 1 - vec2.x;\n        vec2.y /= 2.0;\n        vec2.y += 0.5;\n      }\n    }\n\n    /// NZ - SOUTH \tPZ - NORTH\n    else if (face === 5 || face === 4) {\n      for (let vec2 of vecs) {\n        vec2.y /= -2.0;\n        vec2.y += 0.5;\n      }\n    } else {\n      for (let vec2 of vecs) {\n        vec2.x = 1 - vec2.x;\n      }\n    }\n  }\n\n  skyGeometry.uvsNeedUpdate = true;\n\n  /// Generate final skybox\n  let skyBox = new THREE.Mesh(skyGeometry, materialArray);\n\n  /// Put horizon in camera center\n  skyBox.translateY(boxSize / 4);\n  // skyBox.translateY( -environmentChunk.data.dataGlobal.sky.verticalOffset );\n\n  /// Write to output\n  skyElements.push(skyBox);\n\n  /// And return\n  return {\n    skyElements: skyElements\n  };\n}\n\nmodule.exports = {\n  getHazeColor: getHazeColor,\n  parseLights: parseLights,\n  parseSkybox: parseSkybox\n};\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nfunction renderModels(rendererData, models, title, callback) {\n  let mat;\n  if (rendererData.settings && rendererData.settings.visible) {\n    mat = new THREE.MeshNormalMaterial({\n      side: THREE.DoubleSide\n    });\n  } else {\n    mat = new THREE.MeshBasicMaterial({\n      visible: false\n    });\n  }\n\n  parseAllModels(rendererData, models, mat, title, 200, 0, callback);\n}\n\nfunction getCollisionsForAnimation(animation, collisions) {\n  let ret = [];\n\n  for (let i = 0; i < animation.collisionIndices.length; i++) {\n    let index = animation.collisionIndices[i];\n    let collision = collisions[index];\n    collision.index = index;\n    ret.push(collision);\n  }\n\n  return ret;\n}\n\nfunction parseAllModels(\n  rendererData,\n  models,\n  mat,\n  title,\n  chunkSize,\n  offset,\n  callback\n) {\n  let i = offset;\n\n  for (; i < offset + chunkSize && i < models.length; i++) {\n    let p = Math.round((i * 100) / models.length);\n    if (p !== rendererData.lastP) {\n      T3D.Logger.log(\n        T3D.Logger.TYPE_PROGRESS,\n        \"Loading Collision Models (\" + title + \")\",\n        p\n      );\n      rendererData.lastP = p;\n    }\n\n    /// Get animation object\n    let animation = animationFromGeomIndex(\n      models[i].geometryIndex,\n      rendererData.geometries,\n      rendererData.animations\n    );\n\n    let collisions = getCollisionsForAnimation(\n      animation,\n      rendererData.havokChunkData.collisions\n    );\n\n    for (let j = 0; j < collisions.length; j++) {\n      let collision = collisions[j];\n      renderMesh(rendererData, collision, models[i], mat);\n    }\n  }\n\n  if (i < models.length) {\n    window.setTimeout(() => {\n      parseAllModels(\n        rendererData,\n        models,\n        mat,\n        title,\n        chunkSize,\n        offset + chunkSize,\n        callback\n      );\n    }, 10 /* time in ms to next call */);\n  } else {\n    callback(rendererData.output);\n  }\n}\n\nfunction animationFromGeomIndex(propGeomIndex, geometries, animations) {\n  // geometries is just list of all geometries.animations[end] for now\n  let l = geometries[propGeomIndex].animations.length;\n\n  return animations[geometries[propGeomIndex].animations[l - 1]];\n  // return animations[ geometries[propGeomIndex].animations[0] ];\n}\n\nfunction renderMesh(rendererData, collision, model, mat) {\n  let pos = model.translate;\n  let rot = model.rotate;\n  let scale = 32 * model.scale;\n\n  /// Generate mesh\n  let mesh = parseHavokMesh(rendererData, collision, mat);\n\n  /// Position mesh\n  /// \"x\",\"float32\",\"z\",\"float32\",\"y\",\"float32\"\n  mesh.position.set(pos[0], -pos[2], -pos[1]);\n\n  /// Scale mesh\n  if (scale) mesh.scale.set(scale, scale, scale);\n\n  /// Rotate mesh\n  if (rot) {\n    mesh.rotation.order = \"ZXY\";\n\n    // [\"x\",\"float32\",\"z\",\"float32\",\"y\",\"float32\"],\n    mesh.rotation.set(rot[0], -rot[2], -rot[1]);\n  }\n\n  /// Add mesh to scene and collisions\n  rendererData.output.meshes.push(mesh);\n}\n\nfunction parseHavokMesh(rendererData, collision, mat) {\n  let index = collision.index;\n\n  if (!rendererData.meshes[index]) {\n    let geom = new THREE.Geometry();\n\n    /// Pass vertices\n    for (let i = 0; i < collision.vertices.length; i++) {\n      let v = collision.vertices[i];\n      // \"x\",\"float32\",\"z\",\"float32\",\"y\",\"float32\"]\n      geom.vertices.push(new THREE.Vector3(v[0], v[2], -v[1]));\n    }\n\n    /// Pass faces\n    for (let i = 0; i < collision.indices.length; i += 3) {\n      let f1 = collision.indices[i];\n      let f2 = collision.indices[i + 1];\n      let f3 = collision.indices[i + 2];\n\n      if (\n        f1 <= collision.vertices.length &&\n        f2 <= collision.vertices.length &&\n        f3 <= collision.vertices.length\n      ) {\n        geom.faces.push(new THREE.Face3(f1, f2, f3));\n      } else {\n        T3D.Logger.log(\n          T3D.Logger.TYPE_ERROR,\n          \"Errorus index in havok model geometry.\"\n        );\n      }\n    }\n\n    /// Prepare geometry and pass new mesh\n    geom.computeFaceNormals();\n    // geom.computeVertexNormals();\n\n    rendererData.meshes[index] = new THREE.Mesh(geom, mat);\n\n    return rendererData.meshes[index];\n  } else {\n    return rendererData.meshes[index].clone();\n  }\n}\n\nmodule.exports = { renderModels };\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst ModelUtils = require(\"../util/ModelUtils\");\n\nconst renderIndex = function(\n  localReader,\n  propsArray,\n  idx,\n  callback,\n  lastPct = -1,\n  meshCache = {},\n  textureCache = {},\n  output = { meshes: [] }\n) {\n  if (idx >= propsArray.length) {\n    /// Empty mesh cache\n    meshCache = {};\n    textureCache = {};\n    callback(output);\n    return;\n  }\n\n  let pct = Math.round((1000.0 * idx) / propsArray.length);\n  pct /= 10.0;\n\n  /// Log progress\n  if (lastPct !== pct) {\n    let pctStr = pct + (pct.toString().indexOf(\".\") < 0 ? \".0\" : \"\");\n\n    T3D.Logger.log(\n      T3D.Logger.TYPE_PROGRESS,\n      \"Loading 3D Models (Props)\",\n      pctStr\n    );\n    lastPct = pct;\n  }\n\n  /// Read prop at index.\n  let prop = propsArray[idx];\n\n  /// Adds a single mesh to a group.\n  let addMeshToLOD = function(mesh, groups, lod, prop, needsClone) {\n    /// Read lod distance before overwriting mesh variable\n    let lodDist = prop.lod2 !== 0 ? prop.lod2 : mesh.lodOverride[1];\n\n    /// Read flags before overwriting mesh variable\n    let flags = mesh.flags;\n\n    /// Mesh flags are 0 1 4\n    /// For now, use flag 0 as the default level of detail\n    if (flags === 0) lodDist = 0;\n\n    /// Create new empty mesh if needed\n    if (needsClone) {\n      mesh = new THREE.Mesh(mesh.geometry, mesh.material);\n    }\n\n    mesh.updateMatrix();\n    mesh.matrixAutoUpdate = false;\n\n    // Find group for this LOD distance\n    if (groups[lodDist]) {\n      groups[lodDist].add(mesh);\n    }\n    // Or create LOD group and add to a level of detail\n    // WIP, needs some testing!\n    else {\n      let group = new THREE.Group();\n      group.updateMatrix();\n      group.matrixAutoUpdate = false;\n      group.add(mesh);\n      groups[lodDist] = group;\n      lod.addLevel(group, lodDist);\n    }\n\n    return lodDist;\n  };\n\n  /// Adds array of meshes to the scene, also adds transform clones\n  let addMeshesToScene = function(meshArray, needsClone, boundingSphere) {\n    /// Add original\n\n    /// Make LOD object and an array of groups for each LOD level\n    let groups = {};\n    let lod = new THREE.LOD();\n\n    /// Each mesh is added to a group corresponding to its LOD distane\n    let maxDist = 0;\n    meshArray.forEach(function(mesh) {\n      maxDist = Math.max(\n        maxDist,\n        addMeshToLOD(mesh, groups, lod, prop, needsClone)\n      );\n    });\n\n    /// Add invisible level (the raycaster crashes on lod without any levels)\n    lod.addLevel(new THREE.Group(), 100000);\n\n    /// Set position, scale and rotation of the LOD object\n    if (prop.rotation) {\n      lod.rotation.order = \"ZXY\";\n      // [\"x\",\"float32\",\"z\",\"float32\",\"y\",\"float32\"],\n      lod.rotation.set(prop.rotation[0], -prop.rotation[2], -prop.rotation[1]);\n    }\n    lod.scale.set(prop.scale, prop.scale, prop.scale);\n    lod.position.set(prop.position[0], -prop.position[2], -prop.position[1]);\n\n    lod.boundingSphereRadius =\n      (boundingSphere && boundingSphere.radius ? boundingSphere.radius : 1.0) *\n      prop.scale;\n\n    lod.updateMatrix();\n    lod.matrixAutoUpdate = false;\n\n    /// Show highest level always\n    // lod.update(lod);\n\n    // Add LOD containing mesh instances to scene\n    // self.getOutput().meshes.push(lod);\n    output.meshes.push(lod);\n\n    // Add one copy per transform, needs to be within it's own LOD\n    if (prop.transforms) {\n      prop.transforms.forEach(function(transform) {\n        /// Make LOD object and an array of groups for each LOD level\n        let groups = {};\n        let lod = new THREE.LOD();\n\n        /// Each mesh is added to a group corresponding to its LOD distane\n        let maxDist = 0;\n        meshArray.forEach(function(mesh) {\n          maxDist = Math.max(\n            maxDist,\n            addMeshToLOD(mesh, groups, lod, prop, true)\n          );\n        });\n\n        /// Add invisible level\n        // lod.addLevel(new THREE.Group(),10000);\n\n        /// Set position, scale and rotation of the LOD object\n        if (transform.rotation) {\n          lod.rotation.order = \"ZXY\";\n          lod.rotation.set(\n            transform.rotation[0],\n            -transform.rotation[2],\n            -transform.rotation[1]\n          );\n        }\n        lod.scale.set(transform.scale, transform.scale, transform.scale);\n        lod.position.set(\n          transform.position[0],\n          -transform.position[2],\n          -transform.position[1]\n        );\n\n        lod.updateMatrix();\n        lod.matrixAutoUpdate = false;\n\n        lod.boundingSphereRadius =\n          (boundingSphere && boundingSphere.radius\n            ? boundingSphere.radius\n            : 1.0) * prop.scale;\n\n        /// Show highest level always\n        lod.update(lod);\n\n        /// Add LOD containing mesh instances to scenerender: function(propertiesChunkHeader, map, localReader, renderCallback){\n        // self.getOutput().meshes.push(lod);\n        output.meshes.push(lod);\n      });\n    }\n  };\n\n  /// Get meshes\n  let showUnmaterialed = false;\n  ModelUtils.getMeshesForFilename(\n    prop.filename,\n    prop.color,\n    localReader,\n    meshCache,\n    textureCache,\n    showUnmaterialed,\n    false,\n    function(meshes, isCached, boundingSphere) {\n      if (meshes) {\n        addMeshesToScene(meshes, isCached, boundingSphere);\n      }\n\n      /// Render next prop\n      renderIndex(\n        localReader,\n        propsArray,\n        idx + 1,\n        callback,\n        lastPct,\n        meshCache,\n        textureCache,\n        output\n      );\n    }\n  );\n};\n\nconst getIdsForProp = function(props, idx, callback, fileIds = []) {\n  if (idx >= props.length) {\n    callback(fileIds);\n    return;\n  }\n\n  if (idx % 100 === 0) {\n    T3D.Logger.log(\n      T3D.Logger.TYPE_MESSAGE,\n      \"getting ids for entry\",\n      idx,\n      \"of\",\n      props.length\n    );\n  }\n\n  let prop = props[idx];\n  ModelUtils.getFilesUsedByModel(prop.filename, this.localReader, function(\n    propFileIds\n  ) {\n    fileIds = fileIds.concat(propFileIds);\n    getIdsForProp(props, idx + 1, callback, fileIds);\n  });\n};\n\nmodule.exports = {\n  renderIndex: renderIndex,\n  getIdsForProp: getIdsForProp\n};\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst RenderUtils = require(\"./RenderUtils\");\nconst MaterialUtils = require(\"./MaterialUtils\");\nconst TerrainShader = require(\"./TerrainShader\");\nconst GW2File = require(\"../format/file/GW2File\");\n\nfunction drawWater(rect) {\n  /// Add Water\n  const material = new THREE.MeshBasicMaterial({\n    color: 0x5bb1e8,\n    wireframe: false,\n    opacity: 0.35\n  });\n\n  material.transparent = true;\n  return RenderUtils.renderRect(rect, 0, material);\n}\n\nfunction parseNumChunks(terrainData) {\n  terrainData.numChunksD_1 = Math.sqrt(\n    (terrainData.dims[0] * terrainData.chunkArray.length) / terrainData.dims[1]\n  );\n  terrainData.numChunksD_2 =\n    terrainData.chunkArray.length / terrainData.numChunksD_1;\n}\n\n/**\n *\n * @param {*} inflatedBuffer\n * @param {*} mapFile\n * @param {*} anisotropy\n * @param {*} envOutput\n * @param {*} localReader\n * @returns {Promise<{terrainTiles: Array, water: *, mapRect: *}>}\n */\nasync function loadPagedImageCallback(\n  inflatedBuffer,\n  mapFile,\n  anisotropy,\n  envOutput,\n  localReader\n) {\n  // Prep output variables\n  let terrainTiles = [];\n\n  let pimgDS = new DataStream(inflatedBuffer);\n  let pimgFile = new GW2File(pimgDS, 0);\n  let pimgTableDataChunk = pimgFile.getChunk(\"pgtb\");\n  let pimgData = pimgTableDataChunk && pimgTableDataChunk.data;\n\n  let mapRect = null;\n\n  /// Fetch chunks\n  let terrainData = mapFile.getChunk(\"trn\").data;\n  let parameterData = mapFile.getChunk(\"parm\").data;\n\n  /// Read settings\n  let maxAnisotropy = anisotropy || 1;\n\n  let chunkW = 35;\n\n  /// Calculate numChunksD_1 and _2\n  parseNumChunks(terrainData);\n\n  let xChunks = terrainData.numChunksD_1;\n  let yChunks = terrainData.numChunksD_2;\n\n  let allMaterials = terrainData.materials.materials;\n  let allTextures = terrainData.materials.texFileArray;\n\n  // Total map dx and dy\n  let dx = parameterData.rect[2] - parameterData.rect[0];\n  let dy = parameterData.rect[3] - parameterData.rect[1];\n\n  // Each chunk dx and dy\n  let cdx = (dx / terrainData.numChunksD_1) * 1; //  35/33;\n  let cdy = (dy / terrainData.numChunksD_2) * 1; // 35/33;\n  let n = 0;\n  let allMats = [];\n  let customMaterial = new THREE.MeshLambertMaterial({\n    side: THREE.DoubleSide,\n    color: 0x666666,\n    flatShading: true\n  });\n\n  /// Load textures from PIMG and inject as material maps (textures)\n  let chunkTextures = {};\n\n  /// Load textures\n  if (pimgData) {\n    let strippedPages = pimgData.strippedPages;\n\n    /// Only use layer 0\n    strippedPages.forEach(function(page) {\n      /// Only load layer 0 and 1\n      if (page.layer <= 1) {\n        let filename = page.filename;\n        let coord = page.coord;\n\n        let matName = coord[0] + \",\" + coord[1];\n        if (page.layer === 1) matName += \"-2\";\n\n        /// Add texture to list, note that coord name is used, not actual file name\n        if (!chunkTextures[matName]) {\n          /// Load local texture, here we use file name!\n          let chunkTex = MaterialUtils.loadLocalTexture(localReader, filename);\n\n          if (chunkTex) {\n            /// Set repeat, antistropy and repeat Y\n            chunkTex.anisotropy = maxAnisotropy;\n            chunkTex.wrapS = THREE.RepeatWrapping;\n            chunkTex.wrapT = THREE.RepeatWrapping;\n          }\n\n          /// ...But store in coord name\n          chunkTextures[matName] = chunkTex;\n        }\n      }\n    }); /// end for each stripped page in pimgData\n  }\n\n  /// Render Each chunk\n  /// We'll make this async in order for the screen to be able to update\n\n  let renderChunk = function(cx, cy) {\n    let chunkIndex = cy * xChunks + cx;\n\n    let pageX = Math.floor(cx / 4);\n    let pageY = Math.floor(cy / 4);\n\n    // TODO: Terrain texture LOD ?\n    let chunkTextureIndices =\n      allMaterials[chunkIndex].loResMaterial.texIndexArray;\n\n    // var chunkTextureIndices = allMaterials[chunkIndex].hiResMaterial.texIndexArray;\n    // var matFileName = allMaterials[chunkIndex].hiResMaterial.materialFile;\n\n    let mat = customMaterial;\n\n    /// TODO: just tick invert y = false...?\n    let pageOffetX = (cx % 4) / 4.0;\n    let pageOffetY = 0.75 - (cy % 4) / 4.0;\n\n    // offset 0 -> 0.75\n\n    // Make sure we have shared textures\n\n    /// Load and store all tiled textures\n    let fileNames = [];\n    for (let gi = 0; gi < chunkTextureIndices.length / 2; gi++) {\n      let textureFileName = allTextures[chunkTextureIndices[gi]].filename;\n\n      fileNames.push(textureFileName);\n\n      /// If the texture is not already loaded, read it from the .dat!\n      if (!chunkTextures[textureFileName]) {\n        /// Load local texture\n        let chunkTex = MaterialUtils.loadLocalTexture(\n          localReader,\n          textureFileName\n        );\n\n        if (chunkTex) {\n          /// Set repeat, antistropy and repeat Y\n          chunkTex.anisotropy = maxAnisotropy;\n          chunkTex.wrapS = THREE.RepeatWrapping;\n          chunkTex.wrapT = THREE.RepeatWrapping;\n        }\n\n        chunkTextures[textureFileName] = chunkTex;\n      }\n    } /// End for each chunkTextureIndices\n\n    /// Create Composite texture material, refering the shared textures\n    let pageTexName = pageX + \",\" + pageY;\n    let pageTexName2 = pageX + \",\" + pageY + \"-2\";\n\n    // var fog = SceneUtils.getScene().fog;\n    let fog = {\n      color: {\n        r: 1,\n        g: 1,\n        b: 1\n      },\n      near: 0,\n      far: 0\n    };\n\n    /// Set the haze from the environment output\n    if (envOutput.hazeColor) {\n      fog.color.r = envOutput.hazeColor[2] / 255.0;\n      fog.color.g = envOutput.hazeColor[1] / 255.0;\n      fog.color.b = envOutput.hazeColor[0] / 255.0;\n    }\n\n    let uniforms = THREE.UniformsUtils.merge([THREE.UniformsLib[\"lights\"]]);\n\n    /// TODO: READ FROM VO, don't default to hard coded scale\n    uniforms.uvScale = {\n      type: \"v2\",\n      value: new THREE.Vector2(8.0, 8.0)\n    };\n    uniforms.offset = {\n      type: \"v2\",\n      value: new THREE.Vector2(pageOffetX, pageOffetY)\n    };\n\n    uniforms.texturePicker = {\n      type: \"t\",\n      value: chunkTextures[pageTexName]\n    };\n    uniforms.texturePicker2 = {\n      type: \"t\",\n      value: chunkTextures[pageTexName2]\n    };\n\n    uniforms.texture1 = {\n      type: \"t\",\n      value: chunkTextures[fileNames[0]]\n    };\n    uniforms.texture2 = {\n      type: \"t\",\n      value: chunkTextures[fileNames[1]]\n    };\n    uniforms.texture3 = {\n      type: \"t\",\n      value: chunkTextures[fileNames[2]]\n    };\n    uniforms.texture4 = {\n      type: \"t\",\n      value: chunkTextures[fileNames[3]]\n    };\n\n    mat = new THREE.ShaderMaterial({\n      uniforms: uniforms,\n      fragmentShader: TerrainShader.getFragmentShader(),\n      vertexShader: TerrainShader.getVertexShader()\n    });\n\n    /// Store referenceto each material\n    allMats.push(mat);\n\n    /// -1 for faces -> vertices , -2 for ignoring outer faces\n    let chunkGeo = new THREE.PlaneBufferGeometry(\n      cdx,\n      cdy,\n      chunkW - 3,\n      chunkW - 3\n    );\n\n    let cn = 0;\n\n    /// Render chunk\n\n    /// Each chunk vertex\n    for (let y = 0; y < chunkW; y++) {\n      for (let x = 0; x < chunkW; x++) {\n        if (x !== 0 && x !== chunkW - 1 && y !== 0 && y !== chunkW - 1) {\n          chunkGeo.getAttribute(\"position\").array[cn * 3 + 2] =\n            terrainData.heightMapArray[n];\n          cn++;\n        }\n\n        n++;\n      }\n    } // End each chunk vertex\n\n    /// Flip the plane to fit wonky THREE js world axes\n    let mS = new THREE.Matrix4().identity();\n    mS.elements[5] = -1;\n    chunkGeo.applyMatrix(mS);\n\n    /// Compute face normals for lighting, not used when textured\n    chunkGeo.computeFaceNormals();\n    // chunkGeo.computeVertexNormals();\n\n    /// Build chunk mesh!\n    let chunk;\n    chunk = new THREE.Mesh(chunkGeo, customMaterial);\n    if (mat.length) {\n      chunk = THREE.SceneUtils.createMultiMaterialObject(chunkGeo, mat);\n    } else {\n      chunk = new THREE.Mesh(chunkGeo, mat);\n    }\n\n    /// Move and rotate Mesh to fit in place\n    chunk.rotation.set(Math.PI / 2, 0, 0);\n\n    /// Last term is the new one: -cdx*(2/35)\n    let globalOffsetX = parameterData.rect[0] + cdx / 2;\n    let chunkOffsetX = cx * cdx;\n\n    chunk.position.x = globalOffsetX + chunkOffsetX;\n\n    /// Adjust for odd / even number of chunks\n    if (terrainData.numChunksD_2 % 2 === 0) {\n      /// Last term is the new one: -cdx*(2/35)\n      const globalOffsetY = parameterData.rect[1] + cdy / 2 - 0; // -cdy*(1/35);\n      const chunkOffsetY = cy * cdy * 1; // 33/35;\n\n      chunk.position.z = chunkOffsetY + globalOffsetY;\n    } else {\n      const globalOffsetY = parameterData.rect[1] - cdy / 2 + 0; // cdy*(1/35);\n      const chunkOffsetY = cy * cdy * 1; // 33/35;\n\n      chunk.position.z = globalOffsetY + chunkOffsetY;\n    }\n\n    let px = chunk.position.x;\n    let py = chunk.position.z;\n\n    if (!mapRect) {\n      mapRect = {\n        x1: px - cdx / 2,\n        x2: px + cdx / 2,\n        y1: py - cdy / 2,\n        y2: py + cdy / 2\n      };\n    }\n\n    mapRect.x1 = Math.min(mapRect.x1, px - cdx / 2);\n    mapRect.x2 = Math.max(mapRect.x2, px + cdx / 2);\n\n    mapRect.y1 = Math.min(mapRect.y1, py - cdy / 2);\n    mapRect.y2 = Math.max(mapRect.y2, py + cdy / 2);\n\n    chunk.updateMatrix();\n    chunk.updateMatrixWorld();\n\n    /// Add to list of stuff to render\n    /// TODO: Perhaps use some kind of props for each entry instead?\n    terrainTiles.push(chunk);\n  }; /// End render chunk function\n\n  let cx = 0;\n\n  let cy = 0;\n\n  while (cy < yChunks) {\n    // Process chunk\n    renderChunk(cx, cy);\n\n    // Step to next chunk\n    cx += 1;\n    if (cx >= xChunks) {\n      cx = 0;\n      cy++;\n    }\n\n    await new Promise(resolve => setTimeout(resolve, 1));\n\n    // Log\n    let pct = Math.floor((100 * (cy * xChunks + cx)) / (xChunks * yChunks));\n    T3D.Logger.log(T3D.Logger.TYPE_PROGRESS, \"Loading Terrain\", pct);\n  }\n\n  return {\n    terrainTiles: terrainTiles,\n\n    // Draw water surface using map bounds:\n    water: drawWater(mapRect),\n\n    // Return bounds:\n    mapRect: mapRect\n  };\n}\n\nfunction getTerrainFilesId(mapFile) {\n  let terrainChunk = mapFile.getChunk(\"trn\");\n  let pimgTableDataChunk = mapFile.getChunk(\"pimg\");\n  let fileIds = [];\n\n  /// ------------ SPLASH TEXTURES ------------\n  let pimgData = pimgTableDataChunk && pimgTableDataChunk.data;\n  let strippedPages = pimgData.strippedPages;\n\n  /// Only use layer 0\n  strippedPages.forEach(function(page) {\n    /// Only load layer 0 and 1\n    if (page.layer <= 1 && page.filename > 0) {\n      fileIds.push(page.filename);\n    }\n  });\n  /// ------------ END SPLASH TEXTURES ------------\n\n  /// ------------ TILED IMAGES ------------\n  let terrainData = terrainChunk.data;\n  let allTextures = terrainData.materials.texFileArray;\n  allTextures.forEach(function(texture) {\n    if (texture.filename > 0) fileIds.push(texture.filename);\n  });\n  /// ------------ END TILED IMAGES ------------\n\n  return fileIds;\n}\n\nmodule.exports = {\n  loadPagedImageCallback: loadPagedImageCallback,\n  getTerrainFilesId: getTerrainFilesId\n};\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\nconst ModelUtils = require(\"../util/ModelUtils\");\n\nfunction renderZone(rendererData, zone, zoneDefs, mapRect, renderZoneCallback) {\n  /// Get Zone Definition\n  let zoneDef = null;\n  zoneDefs.forEach(function(zd) {\n    if (!zoneDef && zd.token === zone.defToken) zoneDef = zd;\n  });\n\n  /// Create array of all models to add:\n  let modelGroups = getModelGroups(rendererData, zone, zoneDef, mapRect);\n\n  /// Create empty mesh cache\n  rendererData.meshCache = {};\n  rendererData.textureCache = {};\n\n  /*\n   * ---Keeping this out of the doc for now---\n   * Steps trough each model and renders it to the scene, allowing for efficient caching.\n   * @param  {Number} i - Current index within the models array\n   */\n  // var lastPct = -1;\n  let groupKeys = Object.keys(modelGroups);\n\n  function stepModels(i) {\n    /* var pct = Math.round(100.0*i / groupKeys.length);\n    if(lastPct!=pct){\n      console.log(\"Rendering ZONE models \"+pct);\n      lastPct = pct;\n    } */\n\n    if (i >= groupKeys.length) {\n      /// Empty mesh cache\n      rendererData.meshCache = {};\n      rendererData.textureCache = {};\n\n      /// Tell caller this zone is done loading\n      renderZoneCallback();\n      return;\n    }\n\n    /// Read model at index\n    /// var model = models[i];\n    let key = groupKeys[i]; /// key is model filename\n    let group = modelGroups[key];\n\n    let meshGroups = [];\n\n    /// Get model just once for this group\n    let showUnmaterialed = false;\n    ModelUtils.getMeshesForFilename(\n      key,\n      null,\n      rendererData.localReader,\n      rendererData.meshCache,\n      rendererData.textureCache,\n      showUnmaterialed,\n      false,\n\n      function(meshes, isCached) {\n        /// If there were meshes, add them to the scene with correct scaling rotation etc.\n        if (meshes /* && meshes.length == 3 */) {\n          /// Add one copy per model instance\n          /// TODO: add rotation!\n          /// TODO: fine tune position?\n          /// TODO: POTIMIZE!\n\n          group.forEach(function(model, instanceIdx) {\n            /// For each Mesh in the model\n            meshes.forEach(function(mesh, meshIdx) {\n              if (\n                mesh.materialFlags ===\n                525 /* || mesh.materialFlags == 520 || mesh.materialFlags == 521 */\n              ) {\n                // console.log(\"Skipping lod\");\n                return;\n              }\n\n              let move = {\n                x: 0,\n                y: 0,\n                z: 0\n              };\n\n              /// Add to big mesh\n              if (!meshGroups[meshIdx]) {\n                let mg = mesh.geometry.clone();\n                meshGroups[meshIdx] = {\n                  readVerts: mg.getAttribute(\"position\").array,\n                  verts: new Float32Array(\n                    group.length * mg.getAttribute(\"position\").array.length\n                  ),\n\n                  readIndices: mg.getIndex().array,\n                  indices: new Uint32Array(\n                    group.length * mg.getIndex().array.length\n                  ),\n\n                  readUVs: mg.getAttribute(\"uv\").array,\n                  uvs: new Float32Array(\n                    group.length * mg.getAttribute(\"uv\").array.length\n                  ),\n\n                  readNormals: mg.getAttribute(\"normal\").array,\n                  normals: new Float32Array(\n                    group.length * mg.getAttribute(\"normal\").array.length\n                  ),\n\n                  material: mesh.material,\n                  // material:new THREE.MeshBasicMaterial( {color: 0xffcccc, wireframe:true} ),\n                  /* material : new THREE.PointCloudMaterial ({\n                  color: 0xFF0000,\n                  size: 20\n                  }), */\n                  position: {\n                    x: model.x,\n                    y: model.y,\n                    z: model.z\n                  }\n                };\n              } else {\n                /// Translate\n                move.x = model.x - meshGroups[meshIdx].position.x;\n                move.y = model.z - meshGroups[meshIdx].position.z;\n                move.z = model.y - meshGroups[meshIdx].position.y;\n              }\n\n              /// Add geom verts\n              let readVerts = meshGroups[meshIdx].readVerts;\n              let writeVerts = meshGroups[meshIdx].verts;\n              let stride = readVerts.length;\n\n              for (\n                let i = 0, j = instanceIdx * stride;\n                i < stride;\n                i += 3, j += 3\n              ) {\n                writeVerts[j + 0] = readVerts[i + 0] + move.x;\n                writeVerts[j + 1] = readVerts[i + 1] + move.y;\n                writeVerts[j + 2] = readVerts[i + 2] + move.z;\n              }\n\n              let readIndices = meshGroups[meshIdx].readIndices;\n              let writeIndices = meshGroups[meshIdx].indices;\n              let strideIndices = readIndices.length;\n              let shift = (stride * instanceIdx) / 3;\n\n              for (\n                let i = 0, j = instanceIdx * strideIndices;\n                i < strideIndices;\n                i++, j++\n              ) {\n                writeIndices[j] = readIndices[i] + shift;\n              }\n\n              let readUVs = meshGroups[meshIdx].readUVs;\n              let writeUvs = meshGroups[meshIdx].uvs;\n              let uvStride = readUVs.length;\n              for (\n                let i = 0, j = instanceIdx * uvStride;\n                i < uvStride;\n                i++, j++\n              ) {\n                writeUvs[j] = readUVs[i];\n              }\n\n              let readNormals = meshGroups[meshIdx].readNormals;\n              let writeNormals = meshGroups[meshIdx].normals;\n              let normalStride = readNormals.length;\n              for (\n                let i = 0, j = instanceIdx * normalStride;\n                i < normalStride;\n                i++, j++\n              ) {\n                writeNormals[j] = readNormals[i];\n              }\n            });\n          }); // End for each model in group\n        } /// End if meshes\n\n        /// Add each cluster of merged meshes to scene\n        meshGroups.forEach(function(meshGroup) {\n          let mergedGeom = new THREE.BufferGeometry();\n\n          mergedGeom.addAttribute(\n            \"position\",\n            new THREE.BufferAttribute(meshGroup.verts, 3)\n          );\n          // mergedGeom.addAttribute( 'index', new THREE.BufferAttribute( meshGroup.indices, 1) );\n          mergedGeom.setIndex(new THREE.BufferAttribute(meshGroup.indices, 1));\n          mergedGeom.addAttribute(\n            \"normal\",\n            new THREE.BufferAttribute(meshGroup.normals, 3)\n          );\n          mergedGeom.addAttribute(\n            \"uv\",\n            new THREE.BufferAttribute(meshGroup.uvs, 2)\n          );\n\n          mergedGeom.buffersNeedUpdate = true;\n\n          let mesh = new THREE.Mesh(mergedGeom, meshGroup.material);\n          mesh.position.set(\n            meshGroup.position.x,\n            meshGroup.position.z,\n            meshGroup.position.y\n          );\n\n          rendererData.output.meshes.push(mesh);\n        }); // End for each meshgroup\n\n        /// Rendering is done, render next.\n        stepModels(i + 1);\n      }\n    );\n  } /// End function stepModels\n\n  /// Begin stepping trough the models, rendering them.\n  stepModels(0);\n}\n\nfunction getModelGroups(rendererData, zone, zoneDef, mapRect) {\n  /// Calculate rect in global coordinates\n\n  let mapX = mapRect[0];\n  let mapY = mapRect[1];\n  let c = 32 + 16;\n\n  // [\"x1\",\"uint32\",\"y1\",\"uint32\",\"x2\",\"uint32\", \"y2\", \"uint32\"]\n  let zoneRect = {\n    x1: zone.vertRect[0] * c + mapX,\n    x2: zone.vertRect[2] * c + mapX,\n    y1: zone.vertRect[1] * -c - mapY,\n    y2: zone.vertRect[3] * -c - mapY\n  };\n\n  /// Zone width and depth in local corrdinates\n  /* var zdx = zone.vertRect.x1-zone.vertRect.x2;\n  var zdy = zone.vertRect.y1-zone.vertRect.y2; */\n\n  /// These zones seems to overflow :/\n  if (zone.encodeData.length === 0) {\n    return {};\n  }\n\n  let zdx = zone.vertRect[0] - zone.vertRect[2];\n  // let zdy = zone.vertRect[1] - zone.vertRect[3];\n\n  /// Zone Flags increases a linear position, used to step trough the Zone.\n  let linearPos = 0;\n\n  let modelGroups = {};\n\n  let terrainTiles = rendererData.terrainTiles;\n\n  for (let i = 0; i < zone.flags.length; i += 2) {\n    /// Step forward\n    linearPos += zone.flags[i];\n\n    /// Check if a model should be placed\n    let flag = zone.flags[i + 1];\n    if (flag !== 0) {\n      /// Extract flag data\n      /// Layer is written in the last 4 bytes\n      let zoneDefLayer = flag >> 4;\n\n      /// Get Zone Definition Layer\n      let layer = zoneDef.layerDefArray[zoneDefLayer - 1];\n\n      /// TESTING Only show layers with height >= 3\n      if (layer /* && layer.height >= 0 */) {\n        /// Get X and Y from linear position\n        let modelX = (linearPos % zdx) * c + zoneRect.x1;\n        let modelY = Math.floor(linearPos / zdx) * c + zoneRect.y1;\n\n        /// Get Z from intersection with terrain\n        let modelZ = null;\n\n        const startZ = 100000;\n\n        const raycaster = new THREE.Raycaster(\n          new THREE.Vector3(modelX, startZ, modelY),\n          new THREE.Vector3(0, -1, 0)\n        );\n\n        /// TODO: OPT?\n        terrainTiles.forEach(function(chunk) {\n          if (modelZ === null) {\n            let intersections = raycaster.intersectObject(chunk);\n            if (intersections.length > 0) {\n              modelZ = startZ - intersections[0].distance;\n            }\n          }\n        });\n\n        /// Get model id\n        /// TODO: check with modelIdx = flag & 0xf;\n        let modelIdx = 0;\n        let model = layer.modelArray[modelIdx];\n        let modelFilename = model.filename;\n        // let zOffsets = model.zOffsets;\n\n        // let layerFlags = layer.layerFlags; // NOrmaly 128, 128\n\n        // TODO: flip z,y?\n        let rotRangeX = layer.rotRangeX; // max min\n        let rotRangeY = layer.rotRangeY; // max min\n        let rotRangeZ = layer.rotRangeZ; // max min\n        let scaleRange = layer.scaleRange; // max min\n        let fadeRange = layer.fadeRange; // max min\n\n        // Unused\n        // tiling: 3\n        // type: 1\n        // width: 2\n        // radiusGround: 2\n\n        /// Create modelGroup (this zone only)\n        if (!modelGroups[modelFilename]) {\n          modelGroups[modelFilename] = [];\n        }\n\n        /// Add entry to model group\n        modelGroups[modelFilename].push({\n          x: modelX,\n          y: modelY,\n          z: modelZ,\n          rotRangeX: rotRangeX,\n          rotRangeY: rotRangeY,\n          rotRangeZ: rotRangeZ,\n          scaleRange: scaleRange,\n          fadeRange: fadeRange\n        });\n      } /// End if layer\n    } /// End if flag != 0\n  } /// End for each flag\n\n  return modelGroups;\n}\n\nmodule.exports = { renderZone };\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/*\n\tguid 1683952224941671000 is fucked up floor in SAB HUB\n\tmaterialFilename for that mesh is 564821, shared with lots of stuff\n\tlod 1 and 2 are both 0\n\tmaterial flags is 2056\n*/\n\n/**\n * Collection of methods for generating THREE materials and textures\n * from Guild Wars 2 data formats.\n * @namespace MaterialUtils\n */\n\n/**\n * Builds a custom vertex shader for a given number of uv cannels.\n * WIP not implemented yet!\n *\n * @memberof MaterialUtils\n * @param  {Number} numUv Number of UV channels used by this shader\n * @return {String}       Genereted vertex shader source\n */\nfunction buildVS(numUv) {\n  let vdefs = \"\";\n  let adefs = \"\";\n  let reads = \"\";\n  for (let i = 0; i < numUv; i++) {\n    vdefs += \"varying vec2 vUv_\" + (i + 1) + \";\\n\";\n\n    /// uv and uv2 are defined by THREE\n    if (i > 1) adefs += \"attribute vec2 uv\" + (i + 1) + \";\\n\";\n\n    reads += \"vUv_\" + (i + 1) + \" = uv\" + (i > 0 ? i + 1 : \"\") + \";\\n\";\n  }\n\n  return (\n    adefs +\n    vdefs +\n    \"void main()\\n\" +\n    \"{\\n\" +\n    reads +\n    \"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\" +\n    \"gl_Position = projectionMatrix * mvPosition;\\n\" +\n    \"}\"\n  );\n}\n\n/**\n * Generate a texture of a specified color, used to be part of THREEjs\n *\n * @memberof MaterialUtils\n * @param {Number} width\n * @param {Number} height\n * @param {THREE.Color} color\n * @returns {THREE.DataTexture}\n */\nfunction generateDataTexture(width, height, color) {\n  // create a buffer with color data\n  let size = width * height;\n  let data = new Uint8Array(4 * size);\n  let r = Math.floor(color.r * 255);\n  let g = Math.floor(color.g * 255);\n  let b = Math.floor(color.b * 255);\n  let a = 255;\n\n  for (let i = 0; i < size; i++) {\n    let stride = i * 4;\n\n    data[stride] = r;\n    data[stride + 1] = g;\n    data[stride + 2] = b;\n    data[stride + 3] = a;\n  }\n  // used the buffer to create a DataTexture\n  return new THREE.DataTexture(data, width, height, THREE.RGBAFormat);\n}\n\n/**\n * Builds a custom pixel shader for a given number of uv cannels.\n * WIP not implemented yet!\n *\n * @memberof MaterialUtils\n * @param  {Array}  textures  THREE textures\n * @param  {Number} numUv     Number of UV channels used by this shader\n * @param  {Number} alphaTest Texture see-trough alpha treshold\n * @param  {any} lightMap  TODO\n * @returns {string}\n */\nfunction buildPS(textures, numUv, alphaTest, lightMap) {\n  let t1uv = \"vUv_\" + (textures[0].uvIdx + 1);\n\n  let discard = \"\";\n\n  if (alphaTest) {\n    discard = \"    if (c1.a < 0.5) \\n\" + \"       discard;\\n\";\n  }\n\n  /// Color from 1st text or lighted by 2nd?\n  let writeColor = \"gl_FragColor = c1;\\n\";\n\n  if (lightMap) {\n    let texIdx = 0;\n    // var t2uv = \"vUv_4\";//+(3-textures[texIdx].uvIdx+1);\n    let t2uv = \"vUv_1\"; // + (textures[texIdx].uvIdx+1);\n    // console.log(\"t2uv\",t2uv);\n\n    writeColor =\n      \"   vec4 c2 = texture2D( texture\" +\n      (texIdx + 1) +\n      \", \" +\n      t2uv +\n      \" );\\n\" +\n      \"     gl_FragColor = c2;\\n\";\n    // \"     gl_FragColor = vec4(c2.rgb * c1.r/.5, c2.a);\\n\";\n  }\n\n  let uniforms = \"\";\n  textures.forEach(function(t, idx) {\n    uniforms += \"uniform sampler2D texture\" + (idx + 1) + \";\\n\";\n  });\n  /* uniforms += \"uniform sampler2D texture1;\\n\";\n\tif(lightMap)\n\t\tuniforms += \"uniform sampler2D texture2;\\n\"; */\n\n  let varyings = \"\";\n  for (let i = 0; i < numUv; i++) {\n    varyings += \"varying vec2 vUv_\" + (i + 1) + \";\\n\";\n  }\n\n  return (\n    uniforms +\n    varyings +\n    \"void main( void ) {\\n\" +\n    \"    vec4 c1 = texture2D( texture1, \" +\n    t1uv +\n    \" );\\n\" +\n    discard +\n    writeColor +\n    \"}\"\n  );\n}\n\n/**\n * WIP, concept for generatin materials to render multi UV chanelled meshes.\n *\n * @memberof MaterialUtils\n * @param  {Array} \ttextures  THREE texture\n * @param  {Number} numUV     Number of UV channels used by this shader\n * @param  {Number} alphaTest Texture see-trough alpha treshold\n * @return {THREE.ShaderMaterial} Generated shader\n */\nfunction getUVMat(textures, numUV, alphaTest) {\n  let lightMap = false;\n  let uniforms = {};\n\n  textures.forEach(function(t, idx) {\n    uniforms[\"texture\" + idx] = {\n      type: \"t\",\n      value: t\n    };\n  });\n\n  if (textures.length > 1) {\n    lightMap = true;\n  }\n\n  let attributes = {};\n\n  for (let i = 2; i < numUV; i++) {\n    attributes[\"uv\" + (i + 1)] = {\n      type: \"v2\",\n      value: []\n    };\n  }\n\n  let vs = buildVS(numUV);\n\n  return new THREE.ShaderMaterial({\n    uniforms: uniforms,\n    vertexShader: vs,\n    fragmentShader: buildPS(textures, numUV, alphaTest, lightMap),\n    attributes: attributes,\n    side: THREE.FrontSide\n  });\n}\n\n/**\n * Builds a THREE texture from a ModelMaterialData by reading settings and\n * loading any required data from the localReader. Uses sharedTextures for\n * texture caching.\n *\n * This method is full of guesses and estimations, and could be improved on\n * a lot, allowing rendering of multi UV channeled materials, or special\n * materials like custom color chanelled gear.\n *\n * @memberof MaterialUtils\n * @param  {ModelMaterialData} material \tA value object often automaticaly\n *                                       \tgenerated by a\n *                                       \t{{#crossLink \"GW2Chunk\"}}{{/crossLink}}\n *                                       \tstructure definitions can be found in\n *                                       \tAllFormats.js, look for the latest\n *                                       \tversion of ModelMaterialData\n *\n * @param  {GW2File} materialFile   A GW2File instance, must be of type AMAT\n * @param  {LocalReader} localReader The LocalReader to load the file contents from.\n * @param  {Object} sharedTextures  Value Object for keeping the texture cache\n * @return {THREE.Material}         A THREE Material with the generated contents and settings.\n */\nfunction getMaterial(material, materialFile, localReader, sharedTextures) {\n  if (!materialFile) return;\n\n  const dxChunk = materialFile.getChunk(\"dx9s\");\n  const grChunk = materialFile.getChunk(\"grmt\");\n\n  /// Append all textures to the custom material\n  let finalTextures = [];\n\n  // Some materials don't use textures..\n  if (\n    material &&\n    material.textures.length /* && material.textures[texIndex] */\n  ) {\n    /// TODO: check for flags!\n    //\n    /// techinques[] -> passes[] -> effects[] -> samplerIndex[]\n    //\n    // console.log(\"num effects\",dxChunk.data.techniques[0].passes[0].effects.length);\n\n    // if(grChunk.data.flags!=76)\n    //\treturn;\n\n    /// 3 teqs : high medium low\t\t\t\t\t\t\t\tGRAPHICS LEVEL SETTINGS\n    /// 1 passes\t\t\t\t\t\t\t\t\t\t\t\tDON'T CARE\n    /// 15 effects\t\t\tEach effect has a pixel shader \t\tHOW??\n    /// 1 or 2 sampler indices \t\t\t\t\t\t\t\t\tUSE ALL! (Multi material)\n\n    let effects = dxChunk.data.techniques[0].passes[0].effects;\n    // var effect = effects[10];\n    let effect = effects[0];\n\n    // let shader = dxChunk.data.shaders[effect.pixelShader];\n\n    /* effects.forEach(function (eff) {\n\t\t\tif(eff.samplerIndex.length > effect.samplerIndex.length)\n\t\t\t\teffect = eff;\n\t\t}); */\n    // var samplerIdx = effect.samplerIndex[0];\n\n    let samplerTextures = [];\n    for (let i = 0; i < effect.samplerIndex.length; i++) {\n      let samplerIdx = effect.samplerIndex[i];\n      let sampler = dxChunk.data.samplers[samplerIdx];\n\n      /// SHOULD NEVER HAPPEN, hide mesh!\n      if (!sampler) continue; // return;\n\n      let textureToken =\n        sampler && grChunk.data.texTokens[sampler.textureIndex];\n      if (!textureToken) textureToken = \"0-0\";\n      /* else\n\t\t\t\ttextureToken =textureToken.val */\n\n      /// Find the texture reffered by this sampler\n      let samplerTex = null;\n\n      material.textures.forEach(function(tex, index) {\n        /// Seems like only 1st part of token is used...\n        if (\n          !samplerTex &&\n          tex.token.split(\"-\")[0] === textureToken.split(\"-\")[0]\n        ) {\n          // console.log(\"TEX match\",tex.token, textureToken)\n          samplerTex = tex;\n        }\n      });\n\n      /// Add this sampler's texture to the collection of all textures\n      if (samplerTex) {\n        samplerTextures.push(samplerTex);\n      } else {\n        /// FALLBACK, just guess what texture we should use\n        if (sampler)\n          samplerTextures.push(material.textures[sampler.textureIndex]);\n        else if (material.textures.length > 0)\n          samplerTextures.push(material.textures[0]);\n        else return;\n      }\n    } /// END for each sampler index in effect\n\n    /// We now have all textures\n    // console.log(\"textures from sampler\", samplerTextures);\n\n    /// Fallback to using whatever texture there is.\n    if (samplerTextures.length <= 0) {\n      return;\n      // mainTex =  material.textures[0];\n    }\n\n    // console.log(\"num samplers \",samplerTextures.length);\n    samplerTextures.forEach(function(texture, idx) {\n      if (!texture) return;\n\n      /// Set texture \"URL\"\n      let texURL = texture && texture.filename;\n\n      /// Load texture from RAM or local reader:\n      finalTextures[idx] = getTexture(texURL, localReader, sharedTextures);\n      if (finalTextures[idx]) {\n        finalTextures[idx].uvIdx = texture.uvPSInputIndex;\n      }\n    });\n  } /// End if material and texture\n\n  let finalMaterial;\n\n  /// Create custom shader material if there are textures\n  if (finalTextures) {\n    // TODO: make this work!\n    if (false && finalTextures.length > 0) {\n      finalMaterial = getUVMat(\n        finalTextures,\n        material.texCoordCount,\n        grChunk.data.flags != 16460\n      );\n    } else {\n      let ft = false;\n      let nt = false;\n      material.textures.forEach(function(t) {\n        // Flag for diffuse map\n        if (!ft && t.token.split(\"-\")[0] == \"1733499172\") ft = t;\n\n        // Flag for normal map\n        if (!nt && t.token.split(\"-\")[0] == \"404146670\") nt = t;\n      });\n\n      if (!ft || ft.filename <= 0) return;\n\n      finalMaterial = new THREE.MeshPhongMaterial({\n        side: THREE.FrontSide,\n        map: getTexture(ft.filename, localReader, sharedTextures)\n      });\n      if (nt) {\n        let normalMap = getTexture(nt.filename, localReader, sharedTextures);\n        normalMap.flipY = true;\n        finalMaterial.normalMap = normalMap;\n      }\n\n      finalMaterial.textureFilename = ft.filename;\n      if (grChunk.data.flags != 16460) {\n        // console.log(\"Setting alpha flag for \",grChunk.data.flags)\n        finalMaterial.alphaTest = 0.05;\n      }\n    }\n  }\n\n  /// Fallback material is monocolored red\n  else {\n    finalMaterial = new THREE.MeshBasicMaterial({\n      side: THREE.FrontSide,\n      color: 0xff0000,\n      shading: THREE.FlatShading\n    });\n  }\n\n  finalMaterial.needsUpdate = true;\n\n  /// Set material props\n  /// disable for now in order for custom shaders not to fuck up\n\n  if (material) {\n    let alphaMask0 = 0x0001; // + 0x0100 + 0x0200;\n    let alphaMask1 = 0x0010;\n    let alphaMask2 = 0x0100 + 0x0200;\n\n    const grChunk = materialFile.getChunk(\"grmt\");\n\n    // Enable alpha test for transparent flags\n    if (\n      material.materialFlags & alphaMask0 ||\n      material.materialFlags & alphaMask1 ||\n      material.materialFlags & alphaMask2 // && solidColor != null\n    ) {\n      // return;\n      // mesh.material.transparent = true;\n      // mesh.material.opacity = 2.0;\n      // var clr = solidColor;\n      // var propAlpha = 0;\n      /// Backgroud color adds to alpha\n      // if( mesh.materialFlags == 2569  ){\n      /// This is rly just guesswork\n      /// Check material flag  2568 (as int) and compare material filename 27353 to 20041\n      /// Same flags but some have alpha and some don't\n      // if( mesh.materialFlags & alphaMask2b  ){\n      //\tpropAlpha =  (clr[3] - 128)/128;\n      //\t//propAlpha = Math.max(0,propAlpha);\n      // }\n      // mesh.material.alphaTest = Math.max(0, 0.1 );//- propAlpha*2);\n    }\n\n    /// GRCHUNK -> DATA -> FLAGS\n\n    /// HAS LIGHT - TEX - ? - EMISSIVE16460\n    ///\n\n    /// 56533 LOD FOR TOMBSTONE?\n\n    //\t16460\t\t\t0100 0000 0100 1100\t\t\t\"standard\" stuff rendering OK in SAB (no alpha test)\n\n    //\n    //\t16452(SAB)\t\t0100 0000 0100 0100\t\t\tyellow numbers in sab signs\n    //\t16448(SAB)\t\t0100 0000 0100 0000\t\t\tfaces on rocks, cloudmen, skybox portal images, holes in walls, floor plates...\n    //\t\t\t\t\t\t\t\t\t\t\t\tno lighting??\n    //\n    //\t 8268\t\t\t0010 0000 0100 1100\n    //\t 3392\t\t\t0000 1101 0100 0000\t\t\tMoto machine light bulbs\n    //\t 2380\t\t\t0000 1001 0100 1100\n    //\t 2368\t\t\t0000 1001 0100 0000\t\t\tFountain water with rings, portal border and circular \"light\"\n    //\t  332\t\t\t0000 0001 0100 1100\n    //\t  324\t\t\t0000 0001 0100 0100\t\t\tMoto face sprites\n    //\n    //\t  320(SAB)\t\t0000 0001 0100 0000\t\t\tportal textures (normal maps ish)\n    //\n    //\t   76\t\t\t0000 0000 0100 1100\t\t\tLOTS OF STUFF\n    //\t   \t\t\t\t\t\t\t\t\t\t\tTree leaves, ground, hills, some roofs, flags, street lights\n    //\t   \t\t\t\t\t\t\t\t\t\t\tsheild textures, some fences, water tops, waterfall\n    //\n    //\t   \t\t\t\t\t\t\t\t\t\t\tIN KHYLO \"everything with alpha\"\n    //\n    //\n    //\t   68\t\t\t0000 0000 0100 0100\t\t\tSome flowers (lo res?) fountain edges foam\n    //\n    //\t   64(SAB)\t\t0000 0000 0100 0000\t\t\tclouds, sun iamge\n\n    let lightMask = 8;\n\n    let knownFileFlags = [\n      16460,\n      16452,\n      16448,\n      8268,\n      3392,\n      2380,\n      2368,\n      332,\n      324,\n      320,\n      76,\n      68,\n      64\n    ];\n\n    if (knownFileFlags.indexOf(grChunk.data.flags) < 0) {\n      T3D.Logger.log(\n        T3D.Logger.TYPE_WARNING,\n        \"unknown GR flag\",\n        grChunk.data.flags\n      );\n    }\n\n    if (!(grChunk.data.flags & lightMask)) {\n      // debugger;\n      // console.log(\"no light\");\n      finalMaterial = new THREE.MeshBasicMaterial({\n        side: THREE.FrontSide,\n        map: finalMaterial.map\n      });\n    }\n\n    if (grChunk.data.flags != 16460) {\n      finalMaterial.alphaTest = 0.05;\n    }\n  } /// End if material\n\n  return finalMaterial;\n}\n\n/**\n * Load image data into a THREE.Texture from a texture file in the .dat file, using a LocalReader.\n * Any loaded tetures are added to sharedTextures, allowing for texture caching and fewer reads.\n *\n * @memberof MaterialUtils\n * @param  {Number} texURL         The fileId or baseId of the file to load image data from.\n * @param  {LocalReader} localReader    The LocalReader to load the file contents from.\n * @param  {Object} sharedTextures Value Object for keeping the texture cache\n * @return {THREE.Texture} A texture that will be populated by the file data when it is loaded.\n */\nfunction getTexture(texURL, localReader, sharedTextures) {\n  let finalTexture;\n\n  /// Read texture from shared array of loaded textures\n  /// or read it from URL and add to shared ones!\n  if (texURL && sharedTextures[texURL]) {\n    /// Just read from already loaded textures.\n    finalTexture = sharedTextures[texURL];\n  } else if (texURL) {\n    /// Load and add to shared array.\n    finalTexture = loadLocalTexture(localReader, texURL);\n\n    /// Set standard texture functionality.\n    finalTexture.wrapT = THREE.RepeatWrapping;\n    finalTexture.wrapS = THREE.RepeatWrapping;\n    finalTexture.flipY = false;\n\n    sharedTextures[texURL] = finalTexture;\n  }\n\n  return finalTexture;\n}\n\n/**\n * Load image data into a THREE.Texture from a texture file in the .dat file, using a LocalReader.\n * If you're loading multiple textures, make sure to use\n * {{#crossLink \"MaterialUtils/getTexture\"}}{{/crossLink}} that allows you to cache textures.\n * \n * @memberof MaterialUtils\n * @param {LocalReader} localReader - The LocalReader to load the file contents from.\n * @param {Number} fileId - The fileId or baseId of the file to load image data from.\n * @param {Number} mapping - What THREE mapping the returned texture will use, not implemented.\n \n * @return {THREE.Texture} A texture that will be populated by the file data when it is loaded.\n */\nfunction loadLocalTexture(localReader, fileId, mapping, defaultColor, onerror) {\n  if (defaultColor === undefined) {\n    defaultColor = Math.floor(0xffffff * Math.random());\n  }\n\n  /// Temporary texture that will be returned by the function.\n  /// Color is randomized in order to differentiate different textures during loading.\n  let texture = generateDataTexture(\n    1, // Width\n    1, // Height\n    new THREE.Color(defaultColor) // Color\n  );\n\n  // Threejs r71 is using these settings by default, r72+ changed it\n  texture.minFilter = THREE.LinearMipMapLinearFilter;\n  texture.magFilter = THREE.LinearFilter;\n  texture.generateMipmaps = true;\n  texture.flipY = true;\n\n  /// Only allow non-zero fileId, otherwise jsut return static texture\n  if (parseInt(fileId) <= 0) {\n    if (onerror) onerror();\n    return texture;\n  }\n\n  /// Load file using LocalReader.\n  localReader\n    .readFile(fileId, true, false, undefined, undefined, true)\n    .then(result => {\n      /// Require infalted data to be returned.\n      if (!result.buffer) {\n        if (onerror) onerror();\n        return;\n      }\n\n      /// Create image using returned data.\n      let image = {\n        data: new Uint8Array(result.buffer),\n        width: result.imageWidth,\n        height: result.imageHeight\n      };\n\n      /// Use RGBA for all textures for now...\n      /// TODO: don't use alpha for some formats!\n      texture.format =\n        result.dxtType == 3 || result.dxtType == 5 || true\n          ? THREE.RGBAFormat\n          : THREE.RGBFormat;\n\n      /// Update texture with the loaded image.\n      texture.image = image;\n      texture.needsUpdate = true;\n    });\n\n  /// Return texture with temporary content.\n  return texture;\n}\n\nmodule.exports = {\n  buildVS: buildVS,\n  generateDataTexture: generateDataTexture,\n  buildPS: buildPS,\n  getUVMat: getUVMat,\n  getMaterial: getMaterial,\n  loadLocalTexture: loadLocalTexture\n};\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst base32Max = Math.pow(2, 32);\n\n/**\n * Collection Math and sorting methods\n * @namespace MathUtils\n */\n\n/**\n * Takes an integer and calculates what the 16 bit float\n * representation of the binary data used to read the integer is.\n *\n * @memberof MathUtils\n * @param  {Number} h Integer value\n * @return {Number} Float value\n */\nfunction f16(h) {\n  let s = (h & 0x8000) >> 15;\n  let e = (h & 0x7c00) >> 10;\n  let f = h & 0x03ff;\n\n  if (e === 0) {\n    return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));\n  } else if (e === 0x1f) {\n    return f ? NaN : (s ? -1 : 1) * Infinity;\n  }\n\n  return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + f / Math.pow(2, 10));\n}\n\n/**\n * Calculates the number of binary ones present in the data used to\n * generate the input integer.\n *\n * @memberof MathUtils\n * @param  {Number} bits Integer\n * @return {Number}      Number of binary ones in the data\n */\nfunction popcount(bits) {\n  const SK5 = 0x55555555;\n  const SK3 = 0x33333333;\n  const SKF0 = 0x0f0f0f0f;\n\n  bits -= (bits >> 1) & SK5;\n  bits = (bits & SK3) + ((bits >> 2) & SK3);\n  bits = (bits & SKF0) + ((bits >> 4) & SKF0);\n  bits += bits >> 8;\n\n  return (bits + (bits >> 15)) & 63;\n}\n\n/**\n * Calculates the 64 bit integer value of two 32 bit integers. Only works up to\n * the limit of the javascript Number maximum value.\n *\n * @memberof MathUtils\n * @param  {Number[]} arr     Input integers, length should be 2.\n * @return {Number}      64 bit representation of the two integers.\n */\nfunction arr32To64(arr) {\n  /// Re-read as uint64 (still little endian)\n  /// Warn: this will not work for ~50+ bit longs cus all JS numbers are 64 bit floats...\n  return base32Max * arr[1] + arr[0];\n}\n\n/**\n * Sorts an array and returns unique values only.\n *\n * @memberof MathUtils\n * @param  {Array} arr_in     Input array\n * @param  {Function} comparator A comparator function between the objects in arr_in\n * @return {Array}            Sorted and unique value.\n */\nfunction sort_unique(arr_in, comparator) {\n  let arr = Array.prototype.sort.call(arr_in, comparator);\n\n  let u = {};\n\n  const a = [];\n  for (let i = 0, l = arr.length; i < l; ++i) {\n    if (u.hasOwnProperty(arr[i])) {\n      continue;\n    }\n    a.push(arr[i]);\n    u[arr[i]] = 1;\n  }\n\n  return a;\n}\n\nmodule.exports = {\n  f16: f16,\n  popcount: popcount,\n  arr32To64: arr32To64,\n  sort_unique: sort_unique\n};\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst GW2File = require(\"../format/file/GW2File\");\nconst MaterialUtils = require(\"./MaterialUtils\");\nconst MathUtils = require(\"./MathUtils\");\n\n// TODO: Remove this local cache!!\nlet matFiles = {};\n\nconst fvfFormat = require(\"./Constants\").fvfFormat;\n\n/**\n * Returns a THREE representation of the data contained by a GW2 model file.\n * The data is read using a LocalReader reference into the GW2 .dat.\n *\n * @memberof ModelUtils\n * @param {LocalReader} localReader The LocalReader to load the file contents from.\n * @param {Object} chunk Model GEOM chunk.\n * @param {Object} modelDataChunk Model MODL chunk.\n * @param {Object} sharedTextures  Value Object for keeping the texture cache.\n * @param {boolean} showUnmaterialed If false does not render any models with missing materials.\n *\n * @return {Array} Each geometry in the model file represented by a textured THREE.Mesh object\n */\nfunction renderGeomChunk(\n  localReader,\n  chunk,\n  modelDataChunk,\n  sharedTextures,\n  showUnmaterialed\n) {\n  let rawMeshes = chunk.data.meshes;\n  let meshes = [];\n  let mats = modelDataChunk.data.permutations[0].materials;\n\n  for (let rawMesh of rawMeshes) {\n    let rawGeom = rawMesh.geometry;\n    let fvf = rawGeom.verts.mesh.fvf; // rawGeom.fvf;\n\n    let numVerts = rawGeom.verts.vertexCount; // rawGeom.vertexCount;\n\n    let rawVerts = rawGeom.verts.mesh.vertices; // rawGeom.vertices\n\n    let indices = rawGeom.indices.indices;\n\n    let geom = new THREE.BufferGeometry();\n\n    let vertDS = new DataStream(rawVerts.buffer);\n\n    // Dirty step length for now:\n    let stride = rawVerts.length / numVerts;\n\n    // Each vertex\n    // DO UV as well\n    let vertices = new Float32Array(numVerts * 3);\n    let uvs = [];\n\n    /// Calculate the distance to the first pair of UV data from the\n    /// start of the vertex entry\n    let distToNormals =\n      !!(fvf & fvfFormat.Position) * 12 +\n      !!(fvf & fvfFormat.Weights) * 4 +\n      !!(fvf & fvfFormat.Group) * 4;\n\n    let distToTangent =\n      distToNormals +\n      !!(fvf & fvfFormat.Normal) * 12 +\n      !!(fvf & fvfFormat.Color) * 4;\n\n    let distToBittangent = distToTangent + !!(fvf & fvfFormat.Tangent) * 12;\n\n    let distToTangentFrame =\n      distToBittangent + !!(fvf & fvfFormat.Bitangent) * 12;\n\n    let distToUV = distToTangentFrame + !!(fvf & fvfFormat.TangentFrame) * 12;\n\n    /// Check if the UV is 32 bit float or 16 bit float.\n    let uv32Flag = (fvf & fvfFormat.UV32Mask) >> 8;\n    let uv16Flag = (fvf & fvfFormat.UV16Mask) >> 16;\n    let isUV32 = !!uv32Flag;\n    let hasUV = !!uv16Flag || !!uv32Flag;\n\n    /// Popcount (count the number of binary 1's) in the UV flag\n    /// to get the number of UV pairs used in this vertex format.\n    let masked = isUV32 ? uv32Flag : uv16Flag;\n    let numUV = MathUtils.popcount(masked);\n\n    numUV = Math.min(numUV, 1.0);\n\n    /// Create typed UV arrays\n    if (hasUV) {\n      for (let i = 0; i < numUV; i++) {\n        uvs[i] = new Float32Array(numVerts * 2);\n      }\n    }\n\n    // if (!!(fvf & fvfFormat.Normal)) {\n    // \tconsole.log(\"HAS Normal\");\n    // }\n    // if (!!(fvf & fvfFormat.Tangent)) {\n    // \tconsole.log(\"HAS Tangent\");\n    // }\n    // if (!!(fvf & fvfFormat.Bitangent)) {\n    // \tconsole.log(\"HAS Bitangent\");\n    // }\n    // if (!!(fvf & fvfFormat.TangentFrame)) {\n    // \tconsole.log(\"HAS TangentFrame\");\n    // }\n\n    /// Read data from each vertex data entry\n    for (let i = 0; i < numVerts; i++) {\n      /// Go to vertex memory position\n      vertDS.seek(i * stride);\n\n      /// Read position data\n      /// (we just hope all meshes has 32 bit position...)\n      let x = vertDS.readFloat32();\n      let z = vertDS.readFloat32();\n      let y = vertDS.readFloat32();\n\n      /// Write position data, transformed to Tyria3D coordinate system.\n      vertices[i * 3 + 0] = x; // - c.x;\n      vertices[i * 3 + 1] = -y; // + c.y;\n      vertices[i * 3 + 2] = -z; // + c.z;\n\n      /// Read data at UV position\n      if (hasUV) {\n        for (let uvIdx = 0; uvIdx < numUV; uvIdx++) {\n          vertDS.seek(i * stride + distToUV + uvIdx * (isUV32 ? 8 : 4));\n\n          /// Add one UV pair:\n\n          let u, v;\n          if (isUV32) {\n            u = vertDS.readUint32();\n            v = vertDS.readUint32();\n          } else {\n            u = MathUtils.f16(vertDS.readUint16());\n            v = MathUtils.f16(vertDS.readUint16());\n          }\n\n          /// Push to correct UV array\n          uvs[uvIdx][i * 2 + 0] = u;\n          uvs[uvIdx][i * 2 + 1] = v;\n        }\n      } /// End if has UV\n    } /// End each vertex\n\n    /// Each face descripbed in indices\n    let faces = new Uint16Array(indices.length);\n    for (let i = 0; i < indices.length; i += 3) {\n      // This is ONE face\n      faces[i + 0] = indices[i + 2];\n      faces[i + 1] = indices[i + 1];\n      faces[i + 2] = indices[i + 0];\n    } // End each index aka \"face\"\n\n    /// Add position, index and uv props to buffered geometry\n    geom.addAttribute(\"position\", new THREE.BufferAttribute(vertices, 3));\n    // geom.addAttribute( 'index', new THREE.BufferAttribute( faces, 1) );\n    geom.setIndex(new THREE.BufferAttribute(faces, 1));\n\n    /// Calculate normals\n    /// Not all models have normals included, so we ask THREE to do the math at runtime.\n    geom.computeVertexNormals();\n\n    if (hasUV) {\n      for (let uvIdx = 0; uvIdx < numUV; uvIdx++) {\n        /// Names are \"uv\", \"uv2\", \"uv3\", ... , \"uvN\"\n        let uvName = \"uv\" + (uvIdx > 0 ? uvIdx + 1 : \"\");\n\n        /// Set \"custom\" attribute uvN\n        geom.addAttribute(uvName, new THREE.BufferAttribute(uvs[uvIdx], 2));\n\n        /// Flag for update\n        geom.attributes[uvName].needsUpdate = true;\n      }\n\n      /// Not needed anymore?\n      geom.uvsNeedUpdate = true;\n    }\n\n    /// Tell geometry to update its UVs and buffers\n    geom.buffersNeedUpdate = true;\n\n    /// DONE READING VERTEX DATA\n\n    /// Get material used for this mesh\n    let matIdx = rawMesh.materialIndex;\n    let mat = mats[matIdx];\n    let materialFile = null;\n\n    if (mat && matFiles[mat.filename]) {\n      materialFile = matFiles[mat.filename];\n    }\n\n    let finalMaterial = MaterialUtils.getMaterial(\n      mat,\n      materialFile,\n      localReader,\n      sharedTextures\n    );\n\n    /// IF we could not find a material abort OR use a wireframe placeholder.\n    if (!finalMaterial) {\n      if (showUnmaterialed) {\n        finalMaterial = new THREE.MeshLambertMaterial({\n          color: 0x5bb1e8,\n          wireframe: false,\n          side: THREE.DoubleSide\n        });\n      } else {\n        return [];\n      }\n    }\n\n    /// Create the final mesh from the BufferedGeometry and MeshBasicMaterial\n    let finalMesh = new THREE.Mesh(geom, finalMaterial);\n\n    /// Set material info on the returned mesh\n    if (mat) {\n      finalMesh.materialFlags = mat.materialFlags;\n      finalMesh.materialFilename = mat.filename;\n    }\n\n    finalMesh.materialName = rawMesh.materialName;\n\n    /// Use materialFilename, materialName, and material.textureFilename in order to build export\n\n    /// Set lod info on the returned mesh\n    finalMesh.numLods = rawMesh.geometry.lods.length;\n    finalMesh.lodOverride = modelDataChunk.data.lodOverride;\n\n    /// Set flag and UV info on the returned mehs\n    finalMesh.flags = rawMesh.flags;\n    finalMesh.numUV = numUV;\n\n    /// Add mesh to returned Array\n    meshes.push(finalMesh);\n  } /// End rawMeshes forEach\n\n  return meshes;\n}\n\n/**\n * Loads mesh array from Model file and sends as argument to callback.\n * \n * @memberof ModelUtils\n * @async\n * @param  {Number} filename Name of the model file to load data from.\n * @param  {Array} solidColor RGBA array of 4 integers\n * @param {LocalReader} localReader The LocalReader to load the file contents from.\n * @param {Object} sharedTextures  Value Object for keeping the texture cache.\n * @param {boolean} showUnmaterialed If false does not render any models with missing materials.\n \n * @param  {Function} callback Fired once all meshes have been loaded.\n * two arguments are passed to the callback function.\n * \n * The first argument is an Array with each textured THREE.Mesh objects.\n * \n * The second argument is the bounding spehere of this model file.\n * \n */\n\nfunction loadMeshFromModelFile(\n  filename,\n  solidColor,\n  localReader,\n  sharedTextures,\n  showUnmaterialed,\n  hideLOD,\n  callback\n) {\n  // Short handles prop attributes\n  let finalMeshes = [];\n\n  /// Load file\n  localReader\n    .readFile(filename, false, false, undefined, undefined, true)\n    .then(result => {\n      let inflatedData = result.buffer;\n\n      try {\n        if (!inflatedData) {\n          throw new Error(\"Could not find MFT entry for \" + filename);\n        }\n\n        let ds = new DataStream(inflatedData);\n\n        let modelFile = new GW2File(ds, 0);\n\n        // MODL for materials -> textures\n        let modelDataChunk = modelFile.getChunk(\"modl\");\n\n        // GEOM for geometry\n        let geometryDataChunk = modelFile.getChunk(\"geom\");\n\n        /// Hacky fix for not being able to adjust for position\n        let boundingSphere = modelDataChunk.data.boundingSphere;\n        let bsc = boundingSphere.center;\n        boundingSphere.radius += Math.sqrt(\n          bsc[0] * bsc[0] + Math.sqrt(bsc[1] * bsc[1] + bsc[2] * bsc[2])\n        );\n\n        /// Load all material files\n        let allMats = modelDataChunk.data.permutations[0].materials;\n\n        const loadMaterialIndex = function(mIdx, matCallback) {\n          if (mIdx >= allMats.length) {\n            matCallback();\n            return;\n          }\n\n          let mat = allMats[mIdx];\n\n          /// Skip if file is loaded\n          if (matFiles[mat.filename]) {\n            loadMaterialIndex(mIdx + 1, matCallback);\n            return;\n          }\n\n          localReader\n            .readFile(mat.filename, false, false, undefined, undefined, true)\n            .then(result => {\n              let inflatedData = result.buffer;\n              if (inflatedData) {\n                let ds = new DataStream(inflatedData);\n                let materialFile = new GW2File(ds, 0);\n                matFiles[mat.filename] = materialFile;\n              }\n\n              loadMaterialIndex(mIdx + 1, matCallback);\n            });\n        };\n\n        loadMaterialIndex(0, function() {\n          /// Create meshes\n          let meshes = renderGeomChunk(\n            localReader,\n            geometryDataChunk,\n            modelDataChunk,\n            sharedTextures,\n            showUnmaterialed\n          );\n\n          // Build mesh group\n          for (let mesh of meshes) {\n            let texMask = 0x8 + 0x0800;\n\n            // Must have texture\n            if (!showUnmaterialed && !(mesh.materialFlags & texMask)) {\n              return;\n            }\n\n            // Hide LOD meshes if hideLOD is true\n            if (hideLOD && (mesh.flags === 4 || mesh.flags === 1)) {\n              continue;\n            }\n\n            // Add to final colection\n            finalMeshes.push(mesh);\n          } /// END FOR EACH meshes\n\n          callback(finalMeshes, boundingSphere);\n        }); /// END LOAD MATERIALS CALLBACK\n      } catch (e) {\n        console.warn(\"Failed rendering model \" + filename, e);\n        let mesh = new THREE.Mesh(\n          new THREE.BoxGeometry(200, 2000, 200),\n          new THREE.MeshNormalMaterial()\n        );\n        mesh.flags = 4;\n        mesh.materialFlags = 2056;\n        mesh.lodOverride = [1000000, 1000000];\n        finalMeshes.push(mesh);\n\n        /// Send the final meshes to callback function\n        callback(finalMeshes);\n      }\n    }); /// END FILE LOADED CALLBACK FUNCTION\n}\n\n/**\n * Gets a mesh array from Model file and sends as argument to callback. Uses a cache of meshes in order\n * to never read the same model file twice.\n *\n * @memberof ModelUtils\n * @async\n * @param  {Number} filename The fileId or baseId of the Model file to load\n * @param  {Array} color RGBA array of 4 integers\n * @param  {LocalReader} localReader The LocalReader object used to read data from the GW2 .dat file.\n * @param {Object} sharedMeshes  Value Object for keeping the texture cache.\n * @param {Object} sharedTextures  Value Object for keeping the texture cache.\n * @param {boolean} showUnmaterialed If false does not render any models with missing materials.\n * @param  {Function} callback Fired once all meshes have been loaded.\n * three arguments are passed to the callback function.\n *\n * The first argument is an Array with each textured THREE.Mesh objects.\n *\n * The second argument is a boolean, true indicates that these meshes were not\n * loaded from the dat file, but retrieved from the run time cache.\n *\n * The third argument is the bounding spehere of this model file.\n */\nfunction getMeshesForFilename(\n  filename,\n  color,\n  localReader,\n  sharedMeshes,\n  sharedTextures,\n  showUnmaterialed,\n  hideLOD,\n  callback\n) {\n  /// If this file has already been loaded, just return a reference to the meshes.\n  /// isCached will be set to true to inform the caller the meshes will probably\n  /// have to be cloned in some way.\n  if (sharedMeshes[filename]) {\n    callback(\n      sharedMeshes[filename].meshes,\n      true,\n      sharedMeshes[filename].boundingSphere\n    );\n  }\n\n  /// If this file has never been loaded, load it using loadMeshFromModelFile\n  /// the resulting mesh array will be cached within this model's scope.\n  else {\n    loadMeshFromModelFile(\n      filename,\n      color,\n      localReader,\n      sharedTextures,\n      showUnmaterialed,\n      hideLOD,\n      function(meshes, boundingSphere) {\n        /// Cache result if any.\n        if (meshes) {\n          sharedMeshes[filename] = {\n            meshes: meshes,\n            boundingSphere: boundingSphere\n          };\n        }\n\n        /// Allways fire callback.\n        callback(meshes, false, boundingSphere);\n      }\n    );\n  }\n}\n\n/**\n * WIP, Tries to find all fileIds refered by a model file.\n *\n * @memberof ModelUtils\n * @async\n * @param  {Number}   filename    Model file Id\n * @param  {LocalReader}   localReader LocalReader instance to read from\n * @param  {Function} callback   First argument is list of used file IDs\n */\nfunction getFilesUsedByModel(filename, localReader, callback) {\n  let fileIds = [filename];\n\n  /// Load model file\n  localReader\n    .readFile(filename, false, false, undefined, undefined, true)\n    .then(result => {\n      let inflatedData = result.buffer;\n\n      try {\n        if (!inflatedData) {\n          throw new Error(\"Could not find MFT entry for \" + filename);\n        }\n\n        let ds = new DataStream(inflatedData);\n        let modelFile = new GW2File(ds, 0);\n\n        // MODL for materials -> textures\n        let modelDataChunk = modelFile.getChunk(\"modl\");\n\n        /// Get materials used by model\n        let mats = modelDataChunk.data.permutations[0].materials;\n\n        /// Add each material file AND referenced TEXTURES\n        for (let mat of mats) {\n          /// Add material file id\n          let matFileName = mat.filename;\n          fileIds.push(matFileName);\n\n          /// Add each texture file id\n          mat.textures.forEach(function(tex) {\n            fileIds.push(tex.filename);\n          });\n        }\n      } catch (e) {\n        console.warn(\"Could not export any data\", e);\n      }\n\n      callback(fileIds);\n    });\n}\n\nmodule.exports = {\n  renderGeomChunk: renderGeomChunk,\n  getMeshesForFilename: getMeshesForFilename,\n  getFilesUsedByModel: getFilesUsedByModel\n};\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * @namespace ParserUtils\n */\n\n/**\n * Collection of methods used for parsing complex data types from the .dat\n *\n * Most of these methods are only refered by the automatically generated script\n * AllFormats.js\n *\n */\n\nmodule.exports = {\n  /**\n   * Generates a function for reading an array using DataStream\n   *\n   * @param  {Array} structDef DataStream formatted structure definition\n   *                           for the items in the array.\n   * @param  {Number} maxCount The maximum allowed length of the array.\n   *                           Allows any length if left unspecified.\n   * @return {Function}        The generated parsing function.\n   */\n  getArrayReader: function(structDef, maxCount) {\n    return function(ds, struct) {\n      let ret = [];\n      try {\n        let arrLen = ds.readUint32();\n        let offset = ds.readUint32();\n        if (offset === 0) {\n          return ret;\n        }\n        let arrPtr = ds.position - 4 + offset;\n        let pos = ds.position;\n\n        if (maxCount && arrLen > maxCount) {\n          throw new Error(\n            \"Array length \" + arrLen + \" exceeded allowed maximum \" + maxCount\n          );\n        }\n\n        pos = ds.position;\n\n        ds.seek(arrPtr);\n        ret = ds.readType([\"[]\", structDef, arrLen], struct);\n        ds.seek(pos);\n      } catch (e) {\n        console.warn(\"getArrayReader Failed loading array\", e);\n        console.warn(\n          \"getArrayReader Failed loading array, structDef\",\n          structDef\n        );\n      }\n      return ret;\n    };\n  },\n\n  /**\n   * Generates a function for reading a refered array using DataStream\n   *\n   * @param  {Array} structDef DataStream formatted structure definition\n   *                           for the items in the array.\n   * @return {Function}        The generated parsing function.\n   */\n  getRefArrayReader: function(structDef) {\n    return function(ds, struct) {\n      let retArr = [];\n\n      /// Read array of offsets\n      let arrLen = ds.readUint32();\n      let arrPtr = ds.position + ds.readUint32();\n\n      if (arrLen === 0) {\n        return retArr;\n      }\n\n      let orgPos = ds.position;\n\n      /// Go to pointer and read an array of offsets!\n      ds.seek(arrPtr);\n      let offsets = ds.readInt32Array(arrLen);\n\n      // p_data is after having read array\n      // var pointer = p_data - 4;\n      let pointer = orgPos - 4;\n\n      // auto offset  = *reinterpret_cast<const int32*>(pointer);\n      ds.seek(pointer);\n      let offset = ds.readUint32(); /// this should be the same as arr_ptr\n\n      // pointer     += offset;\n      pointer += offset;\n\n      for (let i = 0; i < offsets.length; i++) {\n        if (offsets[i] !== 0) {\n          let pos = pointer + i * 4 + offsets[i];\n          ds.seek(pos);\n\n          try {\n            retArr.push(ds.readStruct(structDef));\n          } catch (e) {\n            // debugger;\n            retArr.push(null);\n            console.warn(\n              \"getRefArrayReader could not find refered data at offset\",\n              offsets[i],\n              e\n            );\n          }\n        }\n      } /// End for each offset\n\n      ds.seek(orgPos);\n      return retArr;\n    };\n  },\n\n  /**\n   * Generates a function for reading a 64bit initeger. For now just reads each\n   * 32 bit integer and glues together as a string.\n   *\n   * @return {Function}        The generated parsing function.\n   */\n  getQWordReader: function() {\n    // let base32Max = 4294967296;\n    return function(ds, struct) {\n      return ds.readUint32() + \"-\" + ds.readUint32();\n\n      /*\n      let p0 = ds.readUint32();\n      let p1 = ds.readUint32();\n      return base32Max * p1 + p0;\n      */\n    };\n  },\n\n  /**\n   * Generates a function for reading a string of 8 bit chars.\n   *\n   * @return {Function}        The generated parsing function.\n   */\n  getStringReader: function() {\n    return function(ds, struct) {\n      let ptr = ds.position + ds.readUint32();\n      let pos = ds.position;\n\n      /// Go to pointer\n      ds.seek(ptr);\n\n      let ret = ds.readCString();\n\n      /// Go back to where we were\n      ds.seek(pos);\n\n      return ret;\n    };\n  },\n\n  /**\n   * Generates a function for reading a string of 16 bit chars.\n   *\n   * @return {Function}        The generated parsing function.\n   */\n  getString16Reader: function(stringOffset) {\n    return function(ds, struct) {\n      let ptr = ds.position + ds.readUint32() + (stringOffset || 0);\n      let pos = ds.position;\n\n      /// Go to pointer\n      ds.seek(ptr);\n\n      let ret = \"\";\n      let num;\n      while (ds.position + 2 < ds.byteLength && (num = ds.readUint16()) !== 0) {\n        ret += String.fromCharCode(num);\n      }\n      // ds.readCString();\n\n      /// Go back to where we were\n      ds.seek(pos);\n\n      return ret;\n    };\n  },\n\n  /**\n   * Generates a function for reading a pointer.\n   *\n   * @param  {Array} structDef DataStream formatted structure definition\n   *                           for the item pointed to.\n   * @return {Function}        The generated parsing function.\n   */\n  getPointerReader: function(structDef) {\n    return function(ds, struct) {\n      let offset = ds.readUint32();\n\n      if (offset === 0) {\n        return {};\n      }\n\n      let ptr = ds.position - 4 + offset;\n      let pos = ds.position;\n\n      /// Go to pointer\n      ds.seek(ptr);\n\n      let ret = ds.readStruct(structDef);\n\n      /// Go back to where we were\n      ds.seek(pos);\n\n      return ret;\n    };\n  },\n\n  /**\n   * Generates a function for reading a filename/file Id.\n   *\n   * @return {Function}        The generated parsing function.\n   */\n  getFileNameReader: function() {\n    return function(ds, struct) {\n      let pos;\n      try {\n        let ptr = ds.position + ds.readUint32();\n        pos = ds.position;\n\n        /// Go to pointer\n        ds.seek(ptr);\n\n        let fileRef = ds.readStruct([\n          \"m_lowPart\",\n          \"uint16\", // uint16 m_lowPart;\n          \"m_highPart\",\n          \"uint16\", // uint16 m_highPart;\n          \"m_terminator\",\n          \"uint16\" // uint16 m_terminator;\n        ]);\n\n        /// Getting the file name...\n        /// Both need to be >= than 256 (terminator is 0)\n        let ret =\n          0xff00 * (fileRef.m_highPart - 0x100) +\n          (fileRef.m_lowPart - 0x100) +\n          1;\n        // var ret = (fileRef.m_highPart - 0x100) * 0xff00 + (fileRef.m_lowPart - 0xff);\n\n        if (ret < 0) {\n          ret = 0;\n          // console.log(\"FR negative\", fileRef.m_highPart, fileRef.m_lowPart, fileRef.m_terminator);\n          // debugger;\n        }\n\n        /// Go back to where we were\n        ds.seek(pos);\n\n        return ret;\n      } catch (e) {\n        /// Go back to where we were\n        ds.seek(pos);\n\n        return -1;\n      }\n    };\n  }\n};\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * Collection of methods used for generating THREE meshes from Guild Wars 2 data formats.\n * @namespace RenderUtils\n */\n\n/**\n * Creates a mesh representing a single plane.\n *\n * @memberof RenderUtils\n * @param  {Object} rect     An object with x1,x2,y1 and y2 properties.\n * @param  {Number} yPos     Vertical position of the rectangle.\n * @param  {THREE.Material} material \tMesh material to apply.\n * @param  {Number} dy       Mesh height.\n * @return {THREE.Mesh}      The generated mesh.\n */\nfunction renderRect(rect, yPos, material, dy) {\n  let dx = rect.x1 - rect.x2;\n  let dz = rect.y1 - rect.y2;\n  if (!dy) dy = 1;\n\n  let cx = (rect.x1 + rect.x2) / 2;\n  let cz = (rect.y1 + rect.y2) / 2;\n  let cy = yPos;\n\n  let geometry = new THREE.BoxGeometry(dx, dy, dz);\n\n  material =\n    material ||\n    new THREE.MeshBasicMaterial({\n      color: 0xff0000,\n      wireframe: true\n    });\n  let plane = new THREE.Mesh(geometry, material);\n  plane.overdraw = true;\n\n  plane.position.x = cx;\n  plane.position.y = cy;\n  plane.position.z = cz;\n\n  return plane;\n}\n\nmodule.exports = {\n  renderRect: renderRect\n};\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nmodule.exports = {\n  /// TODO: port fog from in-engine\n\n  getFragmentShader: function() {\n    return [\n      \"uniform vec2 uvScale;\",\n      \"uniform vec2 offset;\",\n      \"uniform sampler2D texturePicker;\",\n      \"uniform sampler2D texturePicker2;\",\n      \"uniform sampler2D texture1;\",\n      \"uniform sampler2D texture2;\",\n      \"uniform sampler2D texture3;\",\n      \"uniform sampler2D texture4;\",\n\n      THREE.ShaderChunk[\"logdepthbuf_pars_fragment\"],\n\n      \"varying vec2 vUv;\",\n      \"varying vec3 vecNormal;\",\n\n      \"vec3 blend(\",\n      \"vec4 texture1, float a1, vec4 texture2, float a2,\",\n      \"vec4 texture3, float a3, vec4 texture4, float a4)\",\n      \"{\",\n      \"float depth = 2.0;\",\n      \"float alphaMult = 1.0;\",\n      \"float alphaAdd  = 0.0;\",\n      \"a1 *= 4.0;\",\n      \"a2 *= 4.0;\",\n      \"a3 *= 4.0;\",\n      \"a4 *= 4.0;\",\n      \"a1 =  a1+(1.5+texture1.a);\",\n      \"a2 =  a2+(1.5+texture2.a);\",\n      \"a3 =  a3+(1.5+texture3.a);\",\n      \"a4 =  a4+(1.5+texture4.a);\",\n      \"float ma = max(a1,a2);\",\n      \"ma = max(ma,a3);\",\n      \"ma = max(ma,a4);\",\n      \"ma -= depth;\",\n      \"float b1 = max(a1 - ma, 0.0);\",\n      \"float b2 = max(a2 - ma, 0.0);\",\n      \"float b3 = max(a3 - ma, 0.0);\",\n      \"float b4 = max(a4 - ma, 0.0);\",\n      \"return (\",\n      \"texture1.rgb * b1 + texture2.rgb * b2 +\",\n      \"texture3.rgb * b3 + texture4.rgb * b4 \",\n      \") / (b1 + b2 + b3 + b4);\",\n      \"}\",\n\n      \"void main( void ) {\",\n      \"vec2 position = vUv*uvScale;\",\n      \"float edge = 1.0/1024.0;\",\n      \"vec2 compPos = edge + (vUv*0.25 + offset) * (1.0-edge*2.0);\",\n      \"vec4 tp1 = texture2D( texturePicker, compPos);\",\n      \"vec4 tp2 = texture2D( texturePicker2, compPos);\",\n      \"vec4 composite = tp1;\",\n      \"vec4 t1 = texture2D( texture1, position );\",\n      \"vec4 t2 = texture2D( texture2, position );\",\n      \"vec4 t3 = texture2D( texture3, position );\",\n      \"vec4 t4 = texture2D( texture4, position );\",\n      \"vec3 color = blend(\",\n      \"t1, tp1.a,\",\n      \"t2, tp1.b,\",\n      \"t3, tp1.g,\",\n      \"t4, tp1.r\",\n      \");\",\n      \"color *= 0.5+tp2.r;\",\n      \"gl_FragColor = vec4(color,1.0);\",\n      THREE.ShaderChunk[\"logdepthbuf_fragment\"],\n      \"}\"\n    ].join(\"\\n\");\n  },\n  getVertexShader: function() {\n    return [\n      \"varying vec2 vUv;\",\n      \"varying vec3 vecNormal;\",\n      THREE.ShaderChunk[\"logdepthbuf_pars_vertex\"],\n      \"void main()\",\n      \"{\",\n\n      \"vUv =  uv;\",\n      \"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n      \"vecNormal = (modelMatrix * vec4(normal, 0.0)).xyz;\",\n      \"gl_Position = projectionMatrix * mvPosition;\",\n      THREE.ShaderChunk[\"logdepthbuf_vertex\"],\n      \"}\"\n    ].join(\"\\n\");\n  }\n};\n"]}