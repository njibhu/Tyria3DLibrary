{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/LocalReader/Archive.js","src/LocalReader/ArchiveParser.js","src/LocalReader/DataReader.js","src/LocalReader/FileTypes.js","src/LocalReader/LocalReader.js","src/LocalReader/PersistantStore.js","src/Logger.js","src/MapFileList.js","src/T3DLib.js","src/dataRenderer/DataRenderer.js","src/dataRenderer/EnvironmentRenderer.js","src/dataRenderer/HavokRenderer.js","src/dataRenderer/PropertiesRenderer.js","src/dataRenderer/SingleModelRenderer.js","src/dataRenderer/StringRenderer.js","src/dataRenderer/TerrainRenderer.js","src/dataRenderer/ZoneRenderer.js","src/format/definition/ANDAT.js","src/format/definition/MFT.js","src/format/file/GW2Chunk.js","src/format/file/GW2File.js","src/util/MaterialUtils.js","src/util/MathUtils.js","src/util/ParserUtils.js","src/util/PromiseUtils.js","src/util/RenderUtils.js","src/util/TerrainShader.js"],"names":["f","exports","module","define","amd","window","global","self","this","T3D","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","ArchiveParser","FileTypes","PersistantStore","DataReader","PromiseUtils","FETCHLIMIT","[object Object]","settings","_dataReader","path","t3dtoolsWorker","workers","concurrentTasks","_concurrentTasks","_file","_archiveMeta","_mftTable","_mftIndex","_persistantStore","_persistantCache","undefined","_fileTypeCache","file","callback","readArchive","data","ANDatHeader","MFTTable","table","_mftTableSize","header","nbOfEntries","_mftIndexTable","MFTIndex","baseIdToMFT","_baseIdRegister","MFTbaseIds","fileId","isMftID","mftId","offset","size","compressed","crc","baseId","isImage","Promise","resolve","reject","Logger","log","TYPE_ERROR","getFilePart","ds","len","inflate","buffer","id","Math","min","_size","inflatedData","DataStream","resultType","getFileType","archive","disableLog","logs","persistantList","iterateList","Object","keys","map","Number","limitedAsyncIterator","index","done","fail","limit","fetchingData","getFiles","then","slice","oldSlice","_cleanFileList","dataIndex","_callUpdateItem","catch","persistantData","logArray","currentData","getFileMeta","compareData","readFileType","push","putFile","fileType","getFile","actualKeys","oldKeys","includes","deleteFile","_updateFileListItem","MathUtils","parseANDatHeader","mftOffset","mftSize","parseMFTTable","mftIndexOffset","mftIndexSize","parseMFTIndex","version","readUint8","magic","readString","headerSize","readUint32","seek","position","chunkSize","arr32To64","flags","TYPE_DEBUG","fullTable","item","readUint16","mftIndex","reader","FileReader","onerror","fileEvent","onload","target","result","endianness","LITTLE_ENDIAN","readAsArrayBuffer","_settings","_workerPool","_workerLoad","_inflateCallbacks","_startWorker","handle","capLength","arrayBuffer","byteLength","TYPE_WARNING","workerId","_getBestWorkerIndex","postMessage","worker","Worker","selfWorkerId","onmessage","message_event","split","indexOf","GW2File","TYPE","getTypeName","typeID","key","first4","readCString","TEXTURE_ATEC","TEXTURE_ATEP","TEXTURE_ATET","TEXTURE_ATEU","TEXTURE_ATEX","TEXTURE_ATTX","TEXTURE_DDS","TEXTURE_PNG","type","PACK_ABIX","PACK_ABNK","PACK_AFNT","PACK_AMAT","PACK_AMSP","PACK_ANIC","PACK_ASND","PACK_CDHS","PACK_CINP","PACK_CMAC","PACK_CMPC","PACK_CNTC","PACK_EMOC","PACK_EULA","PACK_HVKC","PACK_MAPC","PACK_MMET","PACK_MODL","PACK_MPSD","PACK_PIMG","PACK_PRLT","PACK_STAR","PACK_TXTM","PACK_TXTV","PACK_UNSORTED","BINARIES","STRINGS","UNKNOWN","defANDAT","defMFT","MapFileList","LocalReader","datFile","logger","fileListeners","dat","prototype","parseHeaderAsync","onFullyLoaded","loadFilePart","readANDatHeader","connectInflater","inflater","addEventListener","listener","forEach","fileHeader","readStruct","readMFTHeader","mft","numEntries","entryDict","Float64Array","Uint32Array","Uint16Array","offset_0","offset_1","readMFTIndexFile","ids","mftIndices","m_entryToId_baseId","m_entryToId_fileFileId","baseToMft","fileToMft","id2index","entryIndex","entry","temp","m_entryToId","loadFileList","datName","name","lastModified","str","localStorage","getItem","JSON","parse","loadMapList","mapName","storeFileList","fileList","stringrep","stringify","setItem","storeMapList","mapList","readFileListAsync","uniqueIdxs","sort_unique","b","maxLength","listFiles","readMapListAsync","searchAll","Date","getTime","TYPE_PROGRESS","maps","mapCol","mapEntry","entryBaseId","fileName","getFileIndex","dt","round","localMapList","mapc","group","localGroup","start","N","maxlen","lastPct","pctM","threadsDone","readUniqueId","pct","floor","peekCallback","baseOrFileId","parseInt","loadTextureFile","loadFile","raw","end","DB_VERSION","_dbConnection","_getConnection","request","indexedDB","open","onblocked","event","onupgradeneeded","db","currentVersion","oldVersion","createObjectStore","keyPath","unique","createIndex","autoIncrement","onsuccess","isReady","error","Resolve","transaction","objectStore","get","itemId","getAll","IDBKeyRange","only","reqCount","count","range","bound","lowerBound","upperBound","returnArray","put","delete","init","openCursor","cursor","continue","mos","TYPE_MESSAGE","logFunctions","Array","arguments","argArr","argsToArr","unshift","severity","max","shift","apply","args","console","warn","debug","numErrors","navigator","hardwareConcurrency","GW2Chunk","Archive","DataRenderer","EnvironmentRenderer","HavokRenderer","PropertiesRenderer","SingleModelRenderer","TerrainRenderer","ZoneRenderer","StringRenderer","MaterialUtils","ParserUtils","RenderUtils","getLocalReader","lrInstance","getFileListAsync","localReader","getMapListAsync","renderMapContentsAsync","renderers","context","mapFile","runAllRenderers","runRenderer","renderClass","assign","bind","cb","renderAsync","getContextValue","clazz","propName","defaultValue","output","hasWebGL","return_context","WebGLRenderingContext","canvas","document","createElement","names","getContext","getParameter","gl","THREE","constructor","getOutput","otherClass","rawData","uarr","Uint8Array","rawStrings","String","fromCharCode","subarray","rawString","join","dxtType","imageWidth","imageHeigth","image","width","height","getMat","tex","MeshBasicMaterial","side","BackSide","fog","depthWrite","loadTextureWithFallback","targetMatIndices","materialArray","filename","fallbackFilename","hazeColorAsInt","writeMat","mat","loadFallback","TextureLoader","load","loadLocalTexture","setTimeout","getHazeColor","environmentChunkData","hazes","dataGlobal","haze","farColor","parseLights","lights","ambientLight","hasLight","lighting","backlightIntensity","backlightColor","light","idx","dirLightData","color","Color","directionalLight","DirectionalLight","getHex","intensity","set","direction","normalize","lightDir","AmbientLight","ambientTotal","g","parseSkybox","parameterChunkData","skyElements","skyModeTex","texPathNE","texPathSW","texPathT","bounds","rect","mapW","abs","x1","x2","mapD","y1","y2","visible","skyGeometry","BoxGeometry","boxSize","faceVertexUvs","vecs","face","vec2","x","y","uvsNeedUpdate","skyBox","Mesh","translateY","create","getChunk","hazeColor","lastP","seed","meshes","renderModels","models","title","MeshNormalMaterial","DoubleSide","parseAllModels","getCollisionsForAnimation","animation","collisions","ret","collisionIndices","collision","p","animationFromGeomIndex","geometryIndex","geometries","animations","havokChunkData","j","renderMesh","propGeomIndex","model","pos","translate","rot","rotate","scale","mesh","parseHavokMesh","rotation","order","seedRandom","sin","clone","geom","Geometry","vertices","v","Vector3","indices","f1","f2","f3","faces","Face3","computeFaceNormals","boundingBox","boundsMax","propModels","zoneModels","obsModels","mdl","renderZoneModelsCB","propertiesChunkData","props","propArray","animProps","propAnimArray","instanceProps","propInstanceArray","metaProps","propMetaArray","concat","meshCache","textureCache","renderIndex","pctStr","toString","prop","addMeshToLOD","groups","lod","needsClone","lodDist","lod2","lodOverride","geometry","material","updateMatrix","matrixAutoUpdate","add","Group","addLevel","getMeshesForFilename","isCached","boundingSphere","meshArray","LOD","maxDist","boundingSphereRadius","radius","transforms","transform","update","addMeshesToScene","renderCallback","getFileIdsAsync","fileIds","getIdsForProp","Utils","getFilesUsedByModel","propFileIds","strings","entryHeaderDef","decryptionOffset","bitsPerSymbol","value","readUCS2String","recid","language","TerrainShader","drawWater","wireframe","opacity","transparent","renderRect","parseNumChunks","terrainData","numChunksD_1","sqrt","dims","chunkArray","numChunksD_2","loadPagedImageCallback","infaltedBuffer","terrainTiles","pimgDS","pimgTableDataChunk","pimgData","mapRect","parameterData","maxAnisotropy","anisotropy","xChunks","yChunks","allMaterials","materials","allTextures","texFileArray","dx","dy","cdx","cdy","allMats","customMaterial","MeshLambertMaterial","flatShading","chunkTextures","strippedPages","page","layer","coord","solidColor","matName","chunkTex","wrapS","RepeatWrapping","wrapT","stepChunk","cx","cy","water","chunkIndex","pageX","pageY","chunkTextureIndices","loResMaterial","texIndexArray","pageOffetX","materialFile","pageOffetY","fileNames","gi","textureFileName","pageTexName","pageTexName2","near","far","envOutput","uniforms","UniformsUtils","merge","UniformsLib","uvScale","Vector2","texturePicker","texturePicker2","texture1","texture2","texture3","texture4","ShaderMaterial","fragmentShader","getFragmentShader","vertexShader","getVertexShader","chunkGeo","PlaneBufferGeometry","chunkW","cn","attributes","array","heightMapArray","chunk","mS","Matrix4","identity","elements","applyMatrix","SceneUtils","createMultiMaterialObject","PI","globalOffsetX","chunkOffsetX","globalOffsetY","chunkOffsetY","z","px","py","updateMatrixWorld","renderChunk","pagedImageId","pagedImage","terrainChunk","texture","renderZone","zone","zoneDefs","renderZoneCallback","zoneDef","zd","token","defToken","modelGroups","getModelGroups","groupKeys","stepModels","meshGroups","instanceIdx","meshIdx","materialFlags","move","mg","mga","readVerts","verts","Float32Array","readIndices","getIndex","readUVs","uv","uvs","readNormals","normal","normals","writeVerts","stride","writeIndices","strideIndices","writeUvs","uvStride","writeNormals","normalStride","meshGroup","mergedGeom","BufferGeometry","addAttribute","BufferAttribute","setIndex","buffersNeedUpdate","zPos","mapX","mapY","c","zoneRect","vertRect","encodeData","zdx","linearPos","flag","zoneDefLayer","layerDefArray","modelX","modelY","modelZ","raycaster","Raycaster","intersections","intersectObject","distance","modelArray","modelFilename","rotRangeX","zOffsets","layerFlags","rotRangeY","rotRangeZ","scaleRange","fadeRange","zoneChunkData","zones","zoneArray","zoneDefArray","stepZone","HEAD_STRUCT","DUPLICATE_SETTINGS","ANIM","GAME","Main","SKEL","TOOL","main","nvms","Chunk","addr","headerLength","NaN","loadHead","getDefinition","useNthIndex","fileTypes","defsFound","formats","versions","chunkVersion","__root","loadData","def","next","chunkDataSize","File","noChunks","chunks","readHead","readChunks","ch","toLowerCase","getChunkStructs","ME","getMaterial","sharedTextures","finalMaterial","dxChunk","grChunk","finalTextures","textures","effect","techniques","passes","effects","samplerTextures","shaders","pixelShader","samplerIndex","samplerIdx","sampler","samplers","textureToken","texTokens","textureIndex","samplerTex","texURL","getTexture","uvIdx","uvPSInputIndex","ft","nt","MeshPhongMaterial","FrontSide","normalMap","flipY","textureFilename","alphaTest","shading","FlatShading","needsUpdate","finalTexture","mapping","defaultColor","random","DataTexture","RGBAFormat","generateDataTexture","minFilter","LinearMipMapLinearFilter","magFilter","LinearFilter","generateMipmaps","format","f16","h","pow","Infinity","popcount","bits","base32Max","arr","arr_in","comparator","sort","hasOwnProperty","getArrayReader","structDef","maxCount","struct","arr_len","arr_ptr","readType","getRefArrayReader","ret_arr","orgPos","offsets","readInt32Array","pointer","getQWordReader","getStringReader","ptr","getString16Reader","stringOffset","num","getPointerReader","getFileNameReader","fileRef","m_highPart","m_lowPart","promiseTask","logPrefix","returned","startNewPromise","amount","prefix","matFiles","fvfFormat","renderGeomChunk","yPos","dz","cz","plane","overdraw","modelDataChunk","showUnmaterialed","rawMeshes","mats","permutations","rawMesh","rawGeom","fvf","numVerts","vertexCount","rawVerts","vertDS","distToUV","uv32Flag","uv16Flag","isUV32","hasUV","masked","numUV","readFloat32","computeVertexNormals","uvName","matIdx","materialIndex","finalMesh","materialFilename","materialName","numLods","lods","loadMeshFromModelFile","finalMeshes","modelFile","geometryDataChunk","bsc","center","loadMaterialIndex","mIdx","matCallback","sharedMeshes","matFileName","ShaderChunk"],"mappings":"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,SAAA/K,EAAAzD,EAAAhW,GACA,IAAAqkB,GAAA5K,GAGAzD,EAAA/E,SAAAwI,EAAA,SAAAnX,GAEA,IACA,IAAAA,EACA,KAAA,gCAAAmX,EAGA,IAAA3X,EAAA,IAAAS,WAAAD,GACA,IAAAgG,EAAAxG,EAAA,GAGAic,SAAA,QAGA7d,KAAA65B,aAAA,GAAAnT,UAGAza,QAAA,SAAA0N,GAGA,IAAAqiB,EAAAriB,EAAAJ,SACA4K,EAAA9f,KAAA23B,GAGAriB,EAAAga,SAAA1nB,QAAA,SAAA6M,GACAqL,EAAA9f,KAAAyU,EAAAS,cAMA,MAAAhc,GACAiX,QAAAC,KAAA,4BAAAlX,GAGAuC,EAAAqkB,gGCpqBApnB,EAAAD,SAGAqtB,kBAAA,WACA,OACA,wBACA,uBACA,mCACA,oCACA,8BACA,8BACA,8BACA,8BAEAzS,MAAAukB,YAAA,0BAEA,oBACA,0BAEA,cACA,oDACA,oDACA,IACA,qBACA,yBACA,yBACA,aACA,aACA,aACA,aACA,6BACA,6BACA,6BACA,6BACA,yBACA,mBACA,mBACA,eACA,gCACA,gCACA,gCACA,gCACA,WACA,0CACA,yCACA,2BACA,IAEA,sBACA,+BACA,2BACA,8DACA,iDACA,kDACA,wBACA,6CACA,6CACA,6CACA,6CACA,sBACA,aACA,aACA,aACA,YACA,KACA,sBACA,kCACAvkB,MAAAukB,YAAA,qBACA,KAEA3jB,KAAA,OAEA+R,gBAAA,WACA,OACA,oBACA,0BACA3S,MAAAukB,YAAA,wBACA,cACA,IAEA,aACA,6DACA,qDACA,+CACAvkB,MAAAukB,YAAA,mBACA,KACA3jB,KAAA,qB3B9GA","file":"T3D-1.1.0.js","sourcesContent":["(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/// Includes\nconst ArchiveParser = require('./ArchiveParser');\nconst FileTypes = require('./FileTypes');\nconst PersistantStore = require('./PersistantStore');\nconst DataReader = require('./DataReader');\nconst PromiseUtils = require('../util/PromiseUtils');\n/// EndIncludes\n\nconst FETCHLIMIT = 100000;\n\n\n/****\n * This current model doesn't work so well on the performance side\n * IndexedDB is not meant to be used to store a huge array of 500 000+ items\n * containing just 4 numbers.\n * Next iteration will be one item = Full List\n *   The last item is the most up to date version\n * During the scanning, the archive may upload incomplete versions of the list.\n ****/\n\n\n\n/**\n * TODO - doc\n * One of the big main advantages of this new API is that there is just only one nummeric ID \n * for the files.\n */\nclass Archive {\n    constructor(settings) {\n        this._dataReader = new DataReader({\n            path: settings.t3dtoolsWorker,\n            workers: settings.concurrentTasks\n        });\n\n        this._concurrentTasks = settings.concurrentTasks;\n\n        this._file;\n        this._archiveMeta;\n        this._mftTable;\n        this._mftIndex;\n\n        this._persistantStore = new PersistantStore();\n        this._persistantCache = undefined;\n        this._fileTypeCache = [];\n    }\n\n    loadArchive(file, callback){\n        if(!callback) callback = () => {};\n        let self = this;\n        \n        ArchiveParser.readArchive(file, function(data){\n            if(!data) callback(true);\n            self._file = file;\n            self._archiveMeta = data.ANDatHeader;\n            self._mftTable = data.MFTTable.table;\n            self._mftTableSize = data.MFTTable.header.nbOfEntries;\n            self._mftIndexTable = data.MFTIndex.baseIdToMFT;\n            self._baseIdRegister = data.MFTIndex.MFTbaseIds;\n            callback(false);\n        });\n        \n    }\n\n    getFileMeta(fileId, isMftID){\n        if(!isMftID)\n            fileId = this._mftIndexTable[fileId];\n\n        return {\n            mftId: fileId,\n            offset: this._mftTable.offset[fileId],\n            size: this._mftTable.size[fileId],\n            compressed: this._mftTable.compressed[fileId],\n            crc: this._mftTable.crc[fileId]\n        }\n    }\n\n    getFile(baseId, isImage){\n        let self = this;\n\n        return new Promise((resolve, reject) => {\n            let mftId = this._mftIndexTable[baseId];\n            if(!mftId){\n                T3D.Logger.log(T3D.Logger.TYPE_ERROR, \"Specified baseId is invalid\");\n                reject();\n            }\n\n            let offset = this._mftTable.offset[mftId];\n            let size = this._mftTable.size[mftId];\n            let compressed = this._mftTable.compressed[mftId];\n\n            if(offset <= 0) {\n                T3D.Logger.log(T3D.Logger.TYPE_ERROR, \"File location in archive is invalid\");\n                reject();\n            }        \n\n            ArchiveParser.getFilePart(this._file, offset, size, function(ds, len){\n                //If the file is not compressed, return the data already\n                if(!compressed){\n                    resolve(ds.buffer);\n                } else {\n                    self._dataReader.inflate(ds, len, baseId, resolve, isImage);\n                }\n            })\n        });\n        \n    }\n\n    readFileType(id, isMftID){\n        let self = this;\n        return new Promise((resolve, reject) => {\n            if(!isMftID)\n                id = self._mftIndexTable[id];\n            \n            if(self._fileTypeCache[id] != undefined)\n                return resolve(self._fileTypeCache[id]);\n\n            let offset = self._mftTable.offset[id];\n            let size = self._mftTable.size[id];\n            let compressed = self._mftTable.compressed[id];\n    \n            ArchiveParser.getFilePart(self._file, offset, Math.min(size,2000), function(ds, _size){\n                if(compressed){\n                    self._dataReader.inflate(\n                        ds,\n                        _size,\n                        id,\n                        function(inflatedData){\n                            let ds = new DataStream(inflatedData);\n                            let resultType = FileTypes.getFileType(ds);\n                            self._fileTypeCache[id] = resultType;\n                            resolve(resultType);\n                        }, \n                        false, 0x20\n                    );\n                } else {\n                    let resultType = FileTypes.getFileType(ds);\n                    self._fileTypeCache[id] = resultType;\n                    resolve(resultType);\n                }\n            });\n        });\n    }\n\n    updatePersistant(archive, disableLog) {\n        let self = this;\n        let logs = [];\n\n        let persistantList = [];\n\n        return new Promise((resolve, reject) => {\n            let iterateList = Object.keys(this._mftIndexTable).map(i => Number(i));\n\n            //Iterate through all the archive baseIds\n            PromiseUtils.limitedAsyncIterator(iterateList, (id, index) => {\n                \n                return new Promise((done, fail) => {\n\n                    if(index % FETCHLIMIT == 0){\n                        let offset = id;\n                        let limit = (index+FETCHLIMIT < iterateList.length) ? iterateList[index+FETCHLIMIT] : iterateList[iterateList.length - 1];\n\n\n                        let fetchingData = self._persistantStore.getFiles(offset, limit);\n                        fetchingData.then((data) => {\n                            //just checking for deleted index in the current slice\n                            let slice = iterateList.slice(index, (index + FETCHLIMIT + 1 < iterateList.length) ? \n                                index + FETCHLIMIT + 1 : iterateList.length);\n                            let oldSlice = Object.keys(data).map(i => Number(i));\n                            self._cleanFileList(slice, oldSlice, logs);\n\n                            //Adding the newly fetched data\n                            for (let dataIndex in data){\n                                persistantList[dataIndex] = data[dataIndex];\n                            }\n                            \n                            //Update the current item\n                            self._callUpdateItem(persistantList, id, logs).then(done).catch(fail);\n                        })\n                        fetchingData.catch(reject); //Failing to fetch will call a reject\n                    } else {\n                        self._callUpdateItem(persistantList, id, logs).then(done).catch(fail);\n                    }\n\n                });\n            }, self._concurrentTasks, \"Finding types\"\n            ).then(() => {\n                self._persistantCache = persistantList;\n                resolve();\n            }).catch(reject);\n        });\n    }\n\n    _updateFileListItem(baseId, persistantData, logArray){\n        let self = this;\n        if(!logArray)\n            logArray = [];\n\n        return new Promise((resolve, reject) => {\n            let currentData = self.getFileMeta(baseId);\n\n            function compareData(){\n                //If the item has an invalid offset\n                if(currentData.offset<=0)\n                    return reject();\n    \n                //If the baseId didn't exist before\n                if(persistantData !== undefined && currentData.size === undefined){\n                    self.readFileType(currentData.mftId, true).then((resultType) => {\n                        logArray.push(`NewItem: { baseId: ${baseId}, type: ${resultType}, size: ${currentData.size} }`);\n                        self._persistantStore.putFile({ \n                            baseId: baseId, size: currentData.size, crc: currentData.crc, fileType: resultType\n                        }).then(resolve);\n                    });\n                }\n                //If the size or checksum of the current don't match the old one\n                else if(currentData.size !== persistantData.size ||\n                        currentData.crc !== persistantData.crc\n                ){\n                    self.readFileType(currentData.mftId, true).then((resultType) => {\n                        logArray.push(`ItemModified: { baseId: ${baseId}, type: ${resultType}, size: ${currentData.size} }`);\n                        self._persistantStore.putFile({ \n                            baseId: baseId, size: currentData.size, crc: currentData.crc, fileType: resultType\n                        }).then(resolve);\n                    });\n                }\n                //If nothing changed\n                else {\n                    resolve();\n                }\n            }\n\n            //If the persistantData is not already loaded\n            if(!persistantData)\n                self._persistantStore.getFile(baseId).then((persistantData) => {\n                    compareData();\n                });\n            else\n                compareData();\n        });\n    }\n\n    _cleanFileList(actualKeys, oldKeys, logArray) {\n        let self = this;\n        if(!logArray)\n            logArray = [];\n\n        return new Promise((resolve, reject) => {\n            function checkAndClean(id) {\n                return new Promise((done, fail) => {\n                    if(!actualKeys.includes(id)){\n                        logArray.push(`ItemDeleted: { baseId: ${id}}`);\n                        self._persistantStore.deleteFile(id)\n                            .then(done)\n                            .catch(done);\n                    }\n                })\n            }\n            PromiseUtils.limitedAsyncIterator(oldKeys, checkAndClean, \n                                              self._concurrentTasks * 4)\n                .then(resolve)\n                .catch(reject);\n        });\n    } \n\n    _callUpdateItem(data, id, logs){\n        let persistantData = data[id] ? data[id] : {};\n        return this._updateFileListItem(id, persistantData, logs);\n    }\n}\n\n\n\nmodule.exports = Archive;","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/// Includes\nconst MathUtils = require('../util/MathUtils');\nconst defANDAT = require('../format/definition/ANDAT');\nconst defMFT = require('../format/definition/MFT');\n/// EndIncludes\n\n/**\n * TODO - doc\n * The ArchiveParser module is a set of tools for the Archive class to\n * correctly read the Archive\n */\n\nreadArchive = function(file, callback){\n    var ANDatHeader, MFTTable, MFTIndex;\n    \n    // Get the header from the file then parse it\n    getFilePart(file, 0, 40, function(ds, len){\n        ANDatHeader = parseANDatHeader(ds);\n\n        // Get the MFTTable and then parse it\n        getFilePart(file, ANDatHeader.mftOffset, ANDatHeader.mftSize, function(ds, len){\n            MFTTable = parseMFTTable(ds, len);\n\n            // Get the MFTIndex table and then parse it\n            getFilePart(file, MFTTable.mftIndexOffset, MFTTable.mftIndexSize, function(ds, len){\n                MFTIndex = parseMFTIndex(ds, len);\n\n                //Then callback\n                callback({\n                    ANDatHeader: ANDatHeader,\n                    MFTTable: MFTTable,\n                    MFTIndex: MFTIndex\n                });\n            });\n        })\n    });\n\n}\n\nparseANDatHeader = function(ds){\n    var header = {};\n\n    // Header parsing\n    header.version = ds.readUint8();\n    header.magic = ds.readString(3);\n    header.headerSize = ds.readUint32();\n    ds.seek(ds.position + 4); //Skip uint32\n    header.chunkSize = ds.readUint32();\n    header.crc = ds.readUint32();\n    ds.seek(ds.position + 4); //Skip uint32\n    header.mftOffset = MathUtils.arr32To64([ds.readUint32(), ds.readUint32()]);\n    header.mftSize = ds.readUint32();\n    header.flags = ds.readUint32();\n    // End header parsing\n\n    //Check MAGIC\n    if(header.magic != \"AN\\u001A\"){\n        T3D.Logger.log(\n            T3D.Logger.TYPE_ERROR, \"ANDat header is not valid\", header.magic);\n        return null;\n    }\n\n    T3D.Logger.log(\n        T3D.Logger.TYPE_DEBUG,\n        \"Loaded Main .dat header\"\n    );\n\n    return header;\n}\n\nparseMFTTable = function(ds){\n    // Parse the table header\n    var header = {};\n    header.magic = ds.readString(4);\n    ds.seek(ds.position + 8) //Skip uint64\n    header.nbOfEntries = ds.readUint32();\n    ds.seek(ds.position + 4 + 4); //Skip uint32 * 2\n\n    //check MAGIC\n    if(header.magic != \"Mft\\u001A\"){\n        T3D.Logger.log(\n            T3D.Logger.TYPE_ERROR, \"MFTTable header is not valid\", header.magic);\n        return null;\n    }\n\n    //Where we put all the parsed data\n    //We don't pre-alloc anymore since not having the data aligned together procs too many\n    //cache misses during a fullscan\n    let fullTable = [];\n    \n    // Go through the table\n    for(let i=0; i<header.nbOfEntries - 1; i++){ // -1 is the header that we already parsed\n        let item = {};\n        item['offset'] = MathUtils.arr32To64([ds.readUint32(), ds.readUint32()]);\n        item['size'] = ds.readUint32();\n        item['compressed'] = ds.readUint16();\n        ds.seek(ds.position + 4 + 2); //Skip uint16 + uint32\n        item['crc'] = ds.readUint32();\n        fullTable.push(item);\n    }\n\n    T3D.Logger.log(\n\t\tT3D.Logger.TYPE_DEBUG,\n\t\t\"Loaded MFTTable\"\n\t);\n\n    return {\n        header: header, \n        table: fullTable, \n        //Register the MFTIndex table position and size\n        mftIndexOffset: table[1].offset, \n        mftIndexSize: table[1].size\n    };\n}\n\n/**\n * TODO - doc\n *   This function used to be much more complex with the use of\n *   a \"fileId\" which in the end was just the equivalent of \n *   MFTbaseIds[mftId].sort().reverse()[0] (aka the bigger baseId found)\n * @param {*} ds \n * @param {*} size \n */\nparseMFTIndex = function(ds, size){\n    var length = size / 8;\n\n    var baseIdToMFT = [];\n    var MFTbaseIds = [];\n\n    for(var i=0; i<length; i++){\n        //Parse table\n        var id = ds.readUint32();\n        var mftIndex = ds.readUint32();\n        //Store the values\n        baseIdToMFT[id] = mftIndex;\n        if(!MFTbaseIds[mftIndex])\n            MFTbaseIds[mftIndex] = [];\n        MFTbaseIds[mftIndex].push(id);\n    }\n\n    T3D.Logger.log(\n\t\tT3D.Logger.TYPE_DEBUG,\n\t\t\"Finished indexing MFT\"\n\t);\n\n    return {\n        baseIdToMFT: baseIdToMFT, \n        MFTbaseIds: MFTbaseIds\n    };\n}\n\ngetFilePart = function(file, offset, length, callback){\n    var reader = new FileReader();\n\t\t\n\treader.onerror = function(fileEvent){\n\t\tthrow new Error(fileEvent);\n\t}\n\treader.onload  = function(fileEvent){\n\t\tvar buffer = fileEvent.target.result;\n\t\tvar ds = new DataStream(buffer);\n\t  \tds.endianness = DataStream.LITTLE_ENDIAN;\n        /// Pass data stream and data length to callback function, keeping \"this\" scope\n        callback(ds, length);\n\t}\n\t\n\treader.readAsArrayBuffer(file.slice(offset, offset + length));\n}\n\nmodule.exports = {\n    readArchive: readArchive,\n    parseANDatHeader: parseANDatHeader,\n    parseMFTTable: parseMFTTable,\n    parseMFTIndex: parseMFTIndex,\n    getFilePart: getFilePart\n};","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * TODO - doc\n */\nclass DataReader {\n    constructor(settings){\n        this._settings = settings;\n        this._workerPool = [];\n        this._workerLoad = [];\n        this._inflateCallbacks = [];\n        for (let i = 0; i<settings.workers; i++){\n            this._startWorker(settings.path);\n        }\n    }\n\n    inflate(ds, size, handle, callback, isImage, capLength){\n        let arrayBuffer = ds.buffer;\n\n        //If no capLength then inflate the whole file\n        if(!capLength){\n            capLength = 0;\n        }\n\n        //Buffer length size check\n        if(arrayBuffer.byteLength < 12){\n            T3D.Logger.log(\n                T3D.Logger.TYPE_WARNING,\n                `not inflating, length is too short (${arrayBuffer.byteLength})`, handle\n            );\n            callback(null);\n            return;\n        }\n\n        // Register the callback\n        if(this._inflateCallbacks[handle]){\n            this._inflateCallbacks[handle].push(callback);\n    \n            ///No need to make another call, just wait for callback event to fire.\n            return;\n        }\n        else{\n            this._inflateCallbacks[handle] = [callback];\t\n        }\n\n        // Add the load to the worker\n        let workerId = this._getBestWorkerIndex();\n        this._workerLoad[workerId] += 1;\n        this._workerPool[workerId].postMessage(\n            [handle, arrayBuffer, isImage===true, capLength]\n        );\n    }\n\n    _startWorker(path){\n        let self = this;\n        let worker = new Worker(path);\n        let selfWorkerId = this._workerPool.push(worker) - 1;\n        if(this._workerLoad.push(0) != selfWorkerId + 1) \n            throw new Error(\"WorkerLoad and WorkerPool don't have the same length\");\n\n        worker.onmessage = function(message_event){\n            let handle;\n            // Remove load\n            self._workerLoad[selfWorkerId] -= 1;\n\n            // If error\n            if( typeof message_event.data === 'string'){\n                T3D.Logger.log(\n                    T3D.Logger.TYPE_WARNING,\n                    \"Inflater threw an error\", message_event.data\n                );\n                handle = message_event.data.split(':')[0];\n                for(let callback of self._inflateCallbacks[handle]){\n                    callback(null);\n                }\n            } \n            else {\n                handle = message_event.data[0];\n                // On success\n                if(self._inflateCallbacks[handle]){\n                    for(let callback of self._inflateCallbacks[handle]) {\n                        let data = message_event.data;\n                        // Array buffer, dxtType, imageWidth, imageHeigh\t\t\t\n                        callback(data[1], data[2], data[3], data[4]);\t\n                    }\n                    // Remove triggered listeners\n                    self._inflateCallbacks[handle] = null;\n                } \n                \n                // Unknown error\n                else {\n                    T3D.Logger.log(\n                        T3D.Logger.TYPE_ERROR,\n                        \"Inflater threw an error\", message_event.data\n                    );\n                }\n            }\n\n        };\n\n    }\n\n    _getBestWorkerIndex(){\n        return this._workerLoad.indexOf(Math.min(...this._workerLoad));\n    }\n\n}\n\nmodule.exports = DataReader;","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/// Includes\nlet GW2File = require('../format/file/GW2File.js');\n/// EndIncludes\n\nlet FileTypes = {};\n\nFileTypes.TYPE = {};\n\nFileTypes.TYPE['UNKNOWN'] = 0x000;\n\nFileTypes.TYPE['TEXTURE_ATEC'] = 0x101;\nFileTypes.TYPE['TEXTURE_ATEP'] = 0x102;\nFileTypes.TYPE['TEXTURE_ATET'] = 0x103;\nFileTypes.TYPE['TEXTURE_ATEU'] = 0x104;\nFileTypes.TYPE['TEXTURE_ATEX'] = 0x105;\nFileTypes.TYPE['TEXTURE_ATTX'] = 0x106;\nFileTypes.TYPE['TEXTURE_DDS'] = 0x120;\nFileTypes.TYPE['TEXTURE_PNG'] = 0x121;\n\nFileTypes.TYPE['STRINGS'] = 0x200;\n\nFileTypes.TYPE['BINARIES'] = 0x300;\n\nFileTypes.TYPE['PACK_UNSORTED'] = 0x400;\nFileTypes.TYPE['PACK_ABIX'] = 0x401; //ABIX\nFileTypes.TYPE['PACK_ABNK'] = 0x402; //ABNK\nFileTypes.TYPE['PACK_AFNT'] = 0x403; //AFNT\nFileTypes.TYPE['PACK_AMAT'] = 0x404; //AMAT\nFileTypes.TYPE['PACK_AMSP'] = 0x405; //AMSP\nFileTypes.TYPE['PACK_ANIC'] = 0x406; //anic\nFileTypes.TYPE['PACK_ASND'] = 0x407; //ASND\nFileTypes.TYPE['PACK_CDHS'] = 0x408; //CDHS\nFileTypes.TYPE['PACK_CINP'] = 0x409; //CINP\nFileTypes.TYPE['PACK_CMAC'] = 0x410; //cmaC\nFileTypes.TYPE['PACK_CMPC'] = 0x411; //cmpc\nFileTypes.TYPE['PACK_CNTC'] = 0x412; //cntc\nFileTypes.TYPE['PACK_EMOC'] = 0x413; //emoc\nFileTypes.TYPE['PACK_EULA'] = 0x414; //eula\nFileTypes.TYPE['PACK_HVKC'] = 0x415; //hvkC\nFileTypes.TYPE['PACK_MAPC'] = 0x416; //mapc\nFileTypes.TYPE['PACK_MMET'] = 0x417; //mMet\nFileTypes.TYPE['PACK_MODL'] = 0x418; //MODL\nFileTypes.TYPE['PACK_MPSD'] = 0x419; //mpsd\nFileTypes.TYPE['PACK_PIMG'] = 0x420; //PIMG\nFileTypes.TYPE['PACK_PRLT'] = 0x421; //prlt\nFileTypes.TYPE['PACK_STAR'] = 0x422; //STAR\nFileTypes.TYPE['PACK_TXTM'] = 0x423; //txtm\nFileTypes.TYPE['PACK_TXTV'] = 0x424; //txtv && txtV\n\n/**\n * TODO\n * @function getTypeName\n */\nFileTypes.getTypeName = function(typeID){\n    for (let key in FileTypes.TYPE){\n        if(FileTypes.TYPE[key] === typeID){\n            return key;\n        }\n    }\n    return undefined;\n}\n\n/**\n * TODO\n * @function getFileType \n * @param {DataStream} ds \n */\nFileTypes.getFileType = function(ds){\n    let first4 = ds.readCString(4);\n\n    //Parse textures\n    switch(first4){\n        case 'ATEC':\n            return FileTypes.TYPE.TEXTURE_ATEC;\n        case 'ATEP':\n            return FileTypes.TYPE.TEXTURE_ATEP;\n        case 'ATET':\n            return FileTypes.TYPE.TEXTURE_ATET;\n        case 'ATEU':\n            return FileTypes.TYPE.TEXTURE_ATEU;\n        case 'ATEX':\n            return FileTypes.TYPE.TEXTURE_ATEX;\n        case 'ATTX':\n            return FileTypes.TYPE.TEXTURE_ATTX;\n    };\n\n    if (first4.indexOf(\"DDS\") === 0)\n        return FileTypes.TYPE.TEXTURE_DDS;\n    \n    if (first4.indexOf(\"PNG\") === 0)\n        return FileTypes.TYPE.TEXTURE_PNG;\n\n    // PackFiles\n    if (first4.indexOf(\"PF\") === 0){\n        let file = new GW2File(ds, 0, true);/// true for \"plz no load chunkz\"\n        switch(file.header.type) {\n            case 'ABIX':\n                return FileTypes.TYPE.PACK_ABIX;\n            case 'ABNK':\n                return FileTypes.TYPE.PACK_ABNK;\n            case 'AFNT':\n                return FileTypes.TYPE.PACK_AFNT;\n            case 'AMAT':\n                return FileTypes.TYPE.PACK_AMAT;\n            case 'AMSP':\n                return FileTypes.TYPE.PACK_AMSP;\n            case 'anic':\n                return FileTypes.TYPE.PACK_ANIC\n            case 'ASND':\n                return FileTypes.TYPE.PACK_ASND;\n            case 'CDHS':\n                return FileTypes.TYPE.PACK_CDHS;\n            case 'CINP':\n                return FileTypes.TYPE.PACK_CINP;\n            case 'cmaC':\n                return FileTypes.TYPE.PACK_CMAC;\n            case 'cmpc':\n                return FileTypes.TYPE.PACK_CMPC;\n            case 'cntc':\n                return FileTypes.TYPE.PACK_CNTC;\n            case 'emoc':\n                return FileTypes.TYPE.PACK_EMOC\n            case 'eula':\n                return FileTypes.TYPE.PACK_EULA;\n            case 'hvkC':\n                return FileTypes.TYPE.PACK_HVKC;\n            case 'mapc':\n                return FileTypes.TYPE.PACK_MAPC;\n            case 'mMet':\n                return FileTypes.TYPE.PACK_MMET;\n            case 'MODL':\n                return FileTypes.TYPE.PACK_MODL;\n            case 'mpsd':\n                return FileTypes.TYPE.PACK_MPSD;\n            case 'PIMG':\n                return FileTypes.TYPE.PACK_PIMG;\n            case 'prlt':\n                return FileTypes.TYPE.PACK_PRLT;\n            case 'STAR':\n                return FileTypes.TYPE.PACK_STAR;\n            case 'txtm':\n                return FileTypes.TYPE.PACK_TXTM;\n            case 'txtv':\n            case 'txtV':\n                return FileTypes.TYPE.PACK_TXTV;\n            default:\n                return FileTypes.TYPE.PACK_UNSORTED;\n        }\n    }\n    \n    // Binaries\n    if (first4.indexOf(\"MZ\") === 0)\n        return FileTypes.TYPE.BINARIES;\n    \n    // Strings\n    if (first4.indexOf(\"strs\") === 0)\n        return FileTypes.TYPE.STRINGS;\n\n    // Unknown\n    return FileTypes.TYPE.UNKNOWN;\n}\n\nfunction isCorrectItem(item){\n    return (\n        Object.keys(item).length === 4 &&\n        item[baseId] != undefined &&\n        item[size] != undefined &&\n        item[type] != undefined &&\n        item[crc] != undefined\n    );\n}\n\nmodule.exports = FileTypes;","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/// Generic ArenaNet File with basic header functionality\nvar GW2File = require('../format/file/GW2File.js');\n\n/// Definition of main dat file header\nvar defANDAT = require('../format/definition/ANDAT');\n\n/// Definition of the MFT index\nvar defMFT = require('../format/definition/MFT');\n\n/// Small collection of Math and Sort algorithms\nvar MathUtils = require('../util/MathUtils.js');\n\n/// List of known GW2 maps used to make lookup faster\nvar MapFileList =  require('../MapFileList');\n\n/// Utilities to handle the whole archive file list\nvar FileTypes = require('./FileTypes');\n\n/**\n * A statefull class that handles reading and inflating data from a local GW2 dat file.\n * @class LocalReader\n * @constructor\n * @param {File}\tdatFile A core JS File instance, must refer to the GW2 .dat\n * @param {Object} logger {{#crossLink \"Logger\"}}{{/crossLink}} object responsible for UI logging.\n */\nvar LocalReader = function(datFile, logger){\n\n\t/// Initiate list of file inflation listeners\n\tthis.fileListeners = [];\n\n\t/// Add reference to file object to DAT\n\tthis.dat = datFile;\n\tthis.version = T3D.version;\n\n\tif(logger)\n\t\tthis.logger = logger;\n\telse\n\t\tthis.logger = T3D.Logger;\n};\n\n/**\n * Parses the dat file main header and parses the MFT index\n * @method parseHeaderAsync \n * @async\n * @param  {Function} callback Fires when mft indexing is complete. No arguments\n */\nLocalReader.prototype.parseHeaderAsync = function(callback){\n\n\tthis.onFullyLoaded = callback;\n\n\t///Read dat file header, 40 bytes should always be the length\n\tthis.loadFilePart(this.dat, 0, 40, this.readANDatHeader);\t\n}\n\n/**\n * Registers an inflater webworker from the DOM to this instance.\n * @method connectInflater\n * @param  {HTMLElement} inflater   The embed element for the t3dtools.js webworker\n */\nLocalReader.prototype.connectInflater = function(inflater){\n\tvar self = this;\n\n\t//HTML webworker Element\n\tthis.inflater = inflater;\t\n\n    /// Set up a listener for any messages passed by the webworker component\n    this.inflater.addEventListener(\n    \t'message',\n    \tfunction(message_event){\n    \t\tself.listener.call(self, message_event);\n    \t},\n    \ttrue\n\t);\n\n}\n\n/**\n * Listener for the inflater.\n * @method listener\n * @param {Object} message_event data received from the webworker\n */\nLocalReader.prototype.listener = function(message_event){\n\tif( typeof message_event.data === 'string' ) {\n\t\t\n\t\tthis.logger.log(\n\t\t\tT3D.Logger.TYPE_WARNING,\n\t\t\t\"Inflater threw an error\", message_event.data\n\t\t);\n\t\treturn;\n\t}\n\n\tvar handle = message_event.data[0];\n\n\tif(this.fileListeners[handle]){\n\t\tthis.fileListeners[handle].forEach(function(callback){\n\t\t\tvar data = message_event.data;\n\t\t\t/// Array buffer, dxtType, imageWidth, imageHeigh\t\t\t\n\t\t\tcallback(data[1], data[2], data[3], data[4]);\t\n\t\t});\n\n\t\t// Remove triggered listeners\n\t\tthis.fileListeners[handle] = null;\n\t}\n\t\n}\n\n/**\n * Reads the main header of this dat file and calls readMFTHeader\n * in order to parse the MFT index.\n * @method readANDatHeader\n * @param  {DataStream} ds DataStream instance holding header data\n */\nLocalReader.prototype.readANDatHeader = function(ds){\n\n\n\t/// Read file header data struct\n\tthis.fileHeader = ds.readStruct(defANDAT);\n\n\tthis.logger.log(\n\t\tT3D.Logger.TYPE_DEBUG,\n\t\t\"Loaded Main .dat header\", this.fileHeader\n\t);\n\n\t/// Get pointer to MFT chunk header\n\tthis.fileHeader.mftOffset =  MathUtils.arr32To64(this.fileHeader.mftOffset);\n\n\t/// Load MFT\n\tthis.loadFilePart(\n\t\tthis.dat,\n\t\tthis.fileHeader.mftOffset,\n\t\tthis.fileHeader.mftSize,\n\t\tthis.readMFTHeader );\n\n};\n\n/**\n * Reads the MFT header and calls readMFTIndexFile\n * in order to parse the MFT index.\n * @method readMFTHeader\n * @param  {DataStream} ds DataStream instance holding header data\n */\nLocalReader.prototype.readMFTHeader = function(ds){\n\n\t/// Read MFT header data struct\n\t/// Global variable mft\n\tthis.mft = ds.readStruct(defMFT);\n\n\tvar entryStartPtr = ds.position;\n\tvar numEntries = this.mft.nbOfEntries;\n\n\t/// MFT has entries with offset, size, compression flag and crc\n\t/// for all files in the .dat\n\n\tthis.mft.entryDict = {\n\t\toffset:new Float64Array(numEntries),\n\t\tsize:new Uint32Array(numEntries),\n\t\tcompressed:new Uint16Array(numEntries),\n\t\tcrc: new Uint32Array(numEntries),\n\t}\n\n\n\t/// Read offset, size and compressed flag of the entries.\n\tthis.logger.log(\n\t\tT3D.Logger.TYPE_DEBUG,\n\t\t\"reading MFT entries\"\n\t);\n\tfor(var i=0; i<numEntries-1; i++){\n\t\t\n\t\t/// Read the 64bit offset\n\t\tvar offset_0 = ds.readUint32();\n\t\tvar offset_1 = ds.readUint32();\n\t\tthis.mft.entryDict.offset[i] =  MathUtils.arr32To64(\n\t\t\t[ offset_0, offset_1 ] );\n\n\t\t/// Size is 32bit int and compression flags are 16bits\n\t\tthis.mft.entryDict.size[i] = ds.readUint32();\n\t\tthis.mft.entryDict.compressed[i] = ds.readUint16();\n\t\t\n\t\t/// Skip 6 unknown bytes\n\t\tds.seek(ds.position + 6);\n\n\t\t/// CRC is 32bit int\n\t\tthis.mft.entryDict.crc[i] = ds.readUint32();\n\t}\n\n\t/// Read data pointed to by 2nd mft entry\n\t/// This entry maps file ID to MFT index\t\n\tvar offset = this.mft.entryDict.offset[1];\n\tvar size = this.mft.entryDict.size[1];\n\n\tthis.loadFilePart(this.dat, offset, size, this.readMFTIndexFile);\n\n};\n\n/**\n * Reads the main MFT index file and builds MFT indices used for acceccing\n * files refered to by MFT index, File ID or Base ID.\n * @method readMFTIndexFile\n * @param  {DataStream} ds DataStream instance holding header data\n * @param  {Number} size The size of the index file\n */\nLocalReader.prototype.readMFTIndexFile = function(ds, size){\n\t\n\tvar length = size / 8;\n\n\t/// fileIdTable\n\tvar ids = new Uint32Array(length); // x -> id\n\tvar mftIndices = new Uint32Array(length); // x -> mft\n\n\t/// m_entryToId\n\tvar m_entryToId_baseId = new Uint32Array(length); //mft -> baseId\n\tvar m_entryToId_fileFileId = new Uint32Array(length); //mft -> fileid\n\n\tthis.mft.baseToMft = new Uint32Array(2e6); // -> mft\n\tthis.mft.fileToMft = new Uint32Array(2e6); // -> mft\n\t\n\tfor(var i=0; i<length; i++){\n\t\tids[i] = ds.readUint32();\n\t\tmftIndices[i] = ds.readUint32();\n\t}\n\t\n\t/// Raw map of \"ID\" to mft index\n\tthis.mft.id2index = {\n\t\tids:ids,\n\t\tmftIndices:mftIndices\n\t}\n\n\t/// m_entryToId has both base and filed id\n\tfor(var i=0; i<length; i++){\n\n\n\t\tif (ids[i] == 0 && mftIndices[i] == 0) {\n            continue;\n        }\n \t\t\n \t\tvar entryIndex = mftIndices[i];\n        var entry     = {\n        \tfileId : m_entryToId_fileFileId[entryIndex],\n        \tbaseId : m_entryToId_baseId[entryIndex]\n        }\n\n        if (entry.baseId == 0) {\n            entry.baseId = ids[i];            \n        } else if (entry.fileId == 0) {\n            entry.fileId = ids[i];\n        }\n\n        if (entry.baseId > 0 && entry.fileId > 0) {\n            if (entry.baseId > entry.fileId) {\n            \t//std::swap(entry.baseId, entry.fileId);\n            \tvar temp = entry.baseId;\n            \tentry.baseId = entry.fileId;\n            \tentry.fileId = temp;                \n            }\n        }\n\n        this.mft.baseToMft[entry.baseId] = entryIndex;\n        this.mft.fileToMft[entry.fileId] = entryIndex;\n\n        //Write back\n        m_entryToId_fileFileId[entryIndex] = entry.fileId;\n        m_entryToId_baseId[entryIndex] = entry.baseId;\n\t}\n\n\t/// Populate global VO with finished dicts\n\tthis.mft.m_entryToId = {\n\t\tbaseId:m_entryToId_baseId,\n\t\tfileId:m_entryToId_fileFileId\n\t}\n\n\n\tthis.logger.log(\n\t\tT3D.Logger.TYPE_DEBUG,\n\t\t\"Finished indexing MFT \", this.mft\n\t);\n\n\tif(this.onFullyLoaded)\n\t\tthis.onFullyLoaded();\n};\n\n/**\n * Reads the cached list of files corresponding to the reader's .dat from the localStorage.\n * @method loadFileList\n * @return {Array} Grouped List of files\n */\nLocalReader.prototype.loadFileList = function(){\n\tvar datFile = this.dat;\n\tvar datName = \"fileList_\" + this.version + \".\" + datFile.name + \"_\" + datFile.lastModified + \"_\" + datFile.size;\n\tvar str = localStorage.getItem(datName);\n\tif(!str)\n\t\treturn null;\n\ttry{\n\t\treturn JSON.parse(str);\t\n\t}\n\tcatch(e){\t\t\n\t}\n\treturn null;\t\n}\n\n/**\n * Reads the cached list of maps corresponding to the reader's .dat from the localStorage.\n * @method loadMapList\n * @return {Array} Grouped List of maps\n */\nLocalReader.prototype.loadMapList = function(){\n\tvar datFile = this.dat;\n\tvar mapName = \"mapList_\" + this.version + \".\" + datFile.name + \"_\" + datFile.lastModified + \"_\" + datFile.size;\n\tvar str = localStorage.getItem(mapName);\n\tif(!str)\n\t\treturn null;\n\ttry{\n\t\treturn JSON.parse(str);\t\n\t}\n\tcatch(e){\n\t\t\n\t}\n\treturn null;\t\n}\n\n/**\n * Stores a files list array in the browser's local storage.\n * @method storeFileList\n * @param  {File} datFile  The File instance used to build the file list.\n * @param  {Object} fileList The list to store.\n */\nLocalReader.prototype.storeFileList = function(datFile, fileList){\n\tdebugger;\n\tvar stringrep = JSON.stringify(fileList);\n\tvar datName = \"fileList_\" + this.version + \".\" + datFile.name + \"_\" + datFile.lastModified + \"_\" + datFile.size;\n\tlocalStorage.setItem(datName, stringrep);\n}\n\n\n/**\n * Stores a map list array in the browser's localStorage.\n * @method storeMapList\n * @param  {File} datFile  The File instance used to build the map list.\n * @param  {Object} mapList The list to store.\n */\nLocalReader.prototype.storeMapList = function(datFile, mapList){\n\tvar mapName = \"mapList_\" + this.version + \".\" + datFile.name + \"_\" + datFile.lastModified + \"_\" + datFile.size;\n\tlocalStorage.setItem(mapName, JSON.stringify(mapList) );\n}\n\n\n/**\n * Reads the file type of each file in the dat and stores the resulting list in \n * the browser's local storage.\n * @method readFileListAsync\n * @async\n * @param  {Function} callback Fired when the list is generated and stores\n *\n * First argument is the a list of mft indices grouped by file type.\n */\nLocalReader.prototype.readFileListAsync = function(callback){\n\n\tvar self = this;\n\n\t/// Get a list of unique indices based on file addresses\n\tvar mftIndices = this.mft.id2index.mftIndices;\n\tvar uniqueIdxs = MathUtils.sort_unique(mftIndices, function(a, b) {\n\t\treturn self.mft.entryDict.offset[a] - self.mft.entryDict.offset[b];\n\t});\n\n\t/// Set total ammount of files to list\n\tvar maxLength = uniqueIdxs.length;\n\t//maxLength = 1e4;\n\n\tthis.logger.log(\n\t\tT3D.Logger.TYPE_DEBUG,\n\t\t\"Scanning \",maxLength, \"files\"\n\t);\n\n\t/// Number of parallel event chains for file lookup\n\tvar N = 8;\n\n\tthis.listFiles(uniqueIdxs, null, 0, maxLength, N, \n\t\tfunction(result){\n\n\t\t\t/// Callback for listFiles\n\t\t\t/// should be an object grouped by header type\n\n\t\t\t/// Clear listeners used during indexing\n\t\t\tself.fileListeners = [];\n\t\t\t\n\t\t\tself.storeFileList(self.dat, result);\n\n\t\t\t/// Fire callback and pass the map list\n\t\t\tcallback(result);\n\t\t}\n\t);\n}\n\n/**\n * Looks up mft indices for all mapc pack files in the dat. Either looks trough all files or\n * only the list defined in {{#crossLink \"T3D/MapFileList:property\"}}{{/crossLink}}.\n * @method readMapListAsync\n * @async\n * @param  {boolean}   searchAll if true forces re-indexing of entire dat.\n * If false only reads indices specified in {{#crossLink \"T3D/MapFileList:property\"}}{{/crossLink}}.\n * @param  {Function} callback Fired when the list is generated\n *\n * First argument is the a list of mft indices grouped by file type. For exmample:\n * \n * \t\t{\t\n * \t\t\tmaps:[\n * \t\t\t\t{\n * \t\t\t\t\tname: 'Heart of Maguuma',\n * \t\t\t\t\tmaps: [\n * \t\t\t\t\t\t{fileName:1151420, name:'HoT BWE3 Raid'},\n * \t\t\t\t\t\t{fileName:969663, name:'Verdant Brink}\n * \t\t\t\t\t]\n * \t\t\t\t},\n * \t\t\t\t{\n * \t\t\t\t\tname: 'Unknown maps',\n * \t\t\t\t\tmaps: [\n * \t\t\t\t\t\t{fileName:12345678, name:'Unknown map 12345678'}\n * \t\t\t\t\t]\n * \t\t\t\t}\n * \t\t\t]\n \n *\t    };\n */\nLocalReader.prototype.readMapListAsync = function(searchAll, callback){\n\tvar self = this;\n\tvar datFile = this.dat;\n\tvar mftIndices = [];\n\n\t/// Number of threads for map lookup\n\tvar N = 8; \n\n\t/// Time spent looking up maps\n\tvar t = new Date().getTime();\n\n\tthis.logger.log(\n\t\tT3D.Logger.TYPE_PROGRESS,\n\t\t\"Finding maps (first visit only)\",\n\t\t\"initializing\"\n\t)\n\n\t/// Only look for known maps\n\tif(!searchAll){\n\n\t\tMapFileList.maps.forEach(function(mapCol){\n\t\t\tmapCol.maps.forEach(function(mapEntry){\n\t\t\t\tvar entryBaseId = mapEntry.fileName.split(\".\")[0];\n\t\t\t\tvar mftIndex = self.getFileIndex(entryBaseId)\n\t\t\t\tmftIndices.push(mftIndex);\n\t\t\t});\n\t\t});\n\t}\n\n\t/// Look for all maps\n\telse{\n\t\tmftIndices = this.mft.id2index.mftIndices;\n\t}\n\n\t/// Get a list of unique indices based on file addresses\n\tvar uniqueIdxs = MathUtils.sort_unique(mftIndices, function(a, b) {\n\t\treturn self.mft.entryDict.offset[a] - self.mft.entryDict.offset[b];\n\t});\n\n\t/// Callback for map lookup\n\tvar cb = function(result){\n\t\tvar dt = new Date().getTime() - t;\n\n\t\tself.logger.log(\n\t\t\tT3D.Logger.TYPE_DEBUG,\n\t\t\t\"Time elapsed \", Math.round(0.001*dt),\" seconds\"\n\t\t);\n\n\t\t/// Clear listeners used during indexing\n\t\tself.fileListeners = [];\n\n\t\tvar localMapList = {maps:[]};\n\n\t\t/// Arrange each found map into a grouped list\n\t\tif(result.mapc){\n\n\t\t\tresult.mapc.forEach(function(mftIndex){\n\n\t\t\t\t/// Base Id is used by gw2browser and is therefore the de facto identifier\n\t\t\t\t/// in the community. Let's use it here too!\n\t\t\t\tvar baseId = self.mft.m_entryToId.baseId[mftIndex+1];\n\n\t\t\t\t/// Hack to avoid releasing maps newer than VB\n\t\t\t\t/*if(baseId > 11542000){\n\t\t\t\t\treturn;\n\t\t\t\t}*/\n\n\t\t\t\tvar name = \"\";\n\t\t\t\tvar group = \"\";\n\n\t\t\t\tMapFileList.maps.forEach(function(mapCol){\n\t\t\t\t\tmapCol.maps.forEach(function(mapEntry){\n\t\t\t\t\t\tif(name.length == 0 && mapEntry.fileName.indexOf(baseId+\".\")>=0){\n\t\t\t\t\t\t\tname = mapEntry.name;\n\t\t\t\t\t\t\tgroup = mapCol.name;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t});\n\n\t\t\t\tif(name.length == 0){\n\t\t\t\t\tname = \"Unknown map \"+baseId;\n\t\t\t\t}\n\n\t\t\t\tif(group.length == 0){\n\t\t\t\t\tgroup = \"Unknown maps\";\n\t\t\t\t}\n\n\t\t\t\tvar localGroup = null;\n\t\t\t\tlocalMapList.maps.forEach(function(mapCol){\n\t\t\t\t\tif(mapCol.name == group){\n\t\t\t\t\t\tlocalGroup = mapCol;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif(!localGroup){\n\t\t\t\t\tlocalGroup = {name:group,maps:[]};\n\t\t\t\t\tlocalMapList.maps.push(localGroup);\n\t\t\t\t}\n\n\t\t\t\tlocalGroup.maps.push({fileName:baseId, name:name});\n\t\t\t\t\n\t\t\t});\n\n\t\t} /// end if result.mapc\n\t\t\t\t\n\t\t/// Store map list into local storage.\n\t\tself.storeMapList(datFile, localMapList);\n\n\t\t/// Fire callback and pass the map list\n\t\tcallback(localMapList);\n\n\t}/// End of map lookup callback.\n\n\n\t/// Start map lookup:\n\tvar maxLength = uniqueIdxs.length;\n\tthis.logger.log(\n\t\tT3D.Logger.TYPE_DEBUG,\n\t\t\"Scanning \",maxLength, \" files for maps...\"\n\t);\n\tthis.listFiles(uniqueIdxs, \"mapc\", 0, maxLength, N, cb);\n}\n\n/**\n * Lists all MFT indices grouped by file type. If a file type is specified only files of that type\n * is added to the list.\n * \n * @method listFiles\n * @param  {Array}   uniqueIdxs File MFT indices to look in.\n * @param  {String}  type       Pack file type or file type to accept. If not set adds all files. \n * @param  {[type]}   start     uniqueIdxs start ofset \n * @param  {[type]}   length    number of entries to scan in uniqueIdxs\n * @param  {[type]}   N         Number of parallel event listeners to run while scanning. (Kinda like parallelism but not quite)\n * @param  {Function} callback  Fired when all files have been indexed. First argument is a list of \n * MFT indices grouped by file type, for example\n * \t{\n *\t  \t\"Unknown\"\t: [444, 555, 333],\n *\t  \t\"MODL\"\t\t: [444, 555, 333],\n * \t  \t\"String\"\t: [666, 777, 888]\n * \t}\n */\nLocalReader.prototype.listFiles = function(uniqueIdxs, type, start, length, N ,callback){\n\tvar self = this;\n\tvar maxlen = start+length;\n\tvar lastPct = 0;\n\tvar pctM = 100.0 / Math.min(length, uniqueIdxs.length - start);\n\tvar threadsDone = 0;\n\n\tvar result = {};\n\n\t/// Fires when file has beed inflated.\n\t/// Pushes matching file types into the result array\n\tvar peekCallback=function(inflatedData, i, mftIndex){\n\t\tif(!inflatedData){\n\t\t\tself.logger.log(\n\t\t\t\tT3D.Logger.TYPE_WARNING,\n\t\t\t\t\"No infalted data for entry\"\n\t\t\t);\n\t\t\treadUniqueId(i+N);\n\t\t\treturn;\n\t\t}\n\n\t\tvar ds = new DataStream(inflatedData);\n\t\tvar fileType = FileTypes.getFileType(ds);\n\t\tfileType = FileTypes.getTypeName(fileType);\n\t\t\n\t\t/// Add file to result[type] array\n\t\t/// If a type was specified in the call only allow that type to be added\n\t\tif( !type || fileType == type){\n\t\t\tif(!result[fileType]){\n\t\t\t\tresult[fileType] = [];\n\t\t\t}\n\t\t\tresult[fileType].push(mftIndex);\n\t\t}\n\n\t\treadUniqueId(i+N);\n\t}\n\n\t\n\tvar readUniqueId = function(i){\n\n\t\tif(i%N==0){\n\t\t\tvar pct = Math.min(100, Math.floor( (i-start) * pctM) );\n\t\t\tif(lastPct != pct){\n\t\t\t\tself.logger.log(\n\t\t\t\t\tT3D.Logger.TYPE_PROGRESS,\n\t\t\t\t\t\"Find type\",\n\t\t\t\t\tpct\n\t\t\t\t);\n\t\t\t\tlastPct = pct;\n\t\t\t}\n\t\t}\n\n\t\tif( i>=uniqueIdxs.length || i>=maxlen ){\n\t\t\tself.logger.log(\n\t\t\t\t\tT3D.Logger.TYPE_DEBUG,\n\t\t\t\t\t\"Thread \",i%N+\" done\"\n\t\t\t);\n\t\t\tthreadsDone++;\n\t\t\tif(threadsDone == N){\n\t\t\t\tcallback(result);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tvar mftIndex = uniqueIdxs[i];\n\n\t\tvar compressed = self.mft.entryDict.compressed[mftIndex];\n\t\tif(!compressed){\n\t\t\t/*self.logger.log(\n\t\t\t\t\tT3D.Logger.TYPE_WARNING,\n\t\t\t\t\t\"File is NOT compressed, skipping.\"\n\t\t\t);*/\n\t\t\treadUniqueId(i+N);\n\t\t\treturn;\n\t\t}\n\n\t\tvar handle = mftIndex;\n\t\tvar offset = self.mft.entryDict.offset[mftIndex];\n\t\tvar size =  self.mft.entryDict.size[mftIndex];\n\n\t\tif(size<0x20){\n\t\t\t/*this.logger.log(\n\t\t\t\t\tT3D.Logger.TYPE_WARNING,\n\t\t\t\t\t\"File is too small, skipping.\"\n\t\t\t);*/\n\t\t\treadUniqueId(i+N);\n\t\t\treturn;\n\t\t}\n\n\t\t/// Read .dat file part\n\t\tself.loadFilePart(self.dat, offset, Math.min(size,2000),\n\t\t\tfunction(ds, _size){\n\t\t\t\t\n\t\t\t\t///Infalte\n\t\t\t\tself.inflate(\n\t\t\t\t\tds,\n\t\t\t\t\t_size,\n\t\t\t\t\thandle,\n\t\t\t\t\t///Infaltion  callback\n\t\t\t\t\tfunction(inflatedData){\n\t\t\t\t\t\tpeekCallback(inflatedData, i, mftIndex);\n\t\t\t\t\t}, \n\t\t\t\t\tfalse, 0x20\n\t\t\t\t);\n\n\n\t\t});\n\n\t}\n\n\t/// Make N calls in serial, this will however result in N\n\t/// Parallell processes due to callbacks..\n\tfor(var n=0; n<N; n++){\n\t\treadUniqueId(start + n);\t\n\t}\n};\n\n/**\n * Gets MFT index by fileId or baseId\n * @method getFileIndex\n * @param  {Number} baseOrFileId A file Id or base Id\n * @return {Number}              MFT index\n */\nLocalReader.prototype.getFileIndex = function(baseOrFileId){\n\n\n\tvar index = -1;\n\n\t/// Get by base id\n\t\n\t/*for(var i = 0; i<this.mft.m_entryToId.baseId.length; i++){\n\t\tif( this.mft.m_entryToId.baseId[i+1] == baseOrFileId ){\t\n\t\t\t\n\t\t\tindex = i;\n\n\t\t\tthis.logger.log(\n\t\t\t\tT3D.Logger.TYPE_DEBUG,\n\t\t\t\t\"Found BASE ID\", baseOrFileId, \" at INDEX \", i\n\t\t\t);\n\n\t\t\treturn index;\n\t\t}\n\t}*/\n\tbaseOrFileId = parseInt(baseOrFileId);\n\tindex = this.mft.m_entryToId.baseId.indexOf(baseOrFileId);\n\tif(index != -1){\n\t\treturn index-1;\n\t}\n\telse{\n\t\tindex = this.mft.m_entryToId.fileId.indexOf(baseOrFileId);\n\t\tif(index != -1){\n\t\t\treturn index-1;\n\t\t}\n\t}\n\n\t/// Get by file id\n\t/*if(index==-1){\n\t\tfor(var i = 0; i<this.mft.m_entryToId.fileId.length; i++){\n\t\t\tif( this.mft.m_entryToId.fileId[i+1] == baseOrFileId ){\t\n\t\t\t\t\n\t\t\t\tindex = i;\n\n\t\t\t\tthis.logger.log(\n\t\t\t\t\tT3D.Logger.TYPE_DEBUG,\n\t\t\t\t\t\"Found FILE ID\", baseOrFileId, \" at INDEX \", i\n\t\t\t\t);\n\n\t\t\t\treturn index;\n\t\t\t}\n\t\t}\t\n\t}*/\n\n\treturn index;\n}\n\n/**\n * Reads a bitmap from a texture file in the dat.\n * @method loadTextureFile\n * @async\n * @param  {Number}   baseId   Base or File id of the texture to load\n * @param  {Function} callback Fires when the inflater has read the texture data.\n * \n * The passed arguments are \n * -ArrayBuffer Bitmap\n * -Number DXT Type\n * -Number image width\n * -Number image height\n *\n */\nLocalReader.prototype.loadTextureFile = function(baseId, callback){\n\tthis.loadFile(baseId, callback, true);\n}\n\n/**\n * Reads data from a file in the dat.\n * @method loadFile\n * @async\n * @param  {Number}   baseId   Base or File id of the texture to load\n * @param  {Function} callback Fires when the inflater has read the data.\n *\n * The passed arguments are \n * -ArrayBuffer raw data\n * -Number DXT Type if applicable\n * -Number image width if applicable\n * -Number image height if applicable\n *\n * \n * @param  {boolean}  isImage  \n * @param  {[type]}   raw      If true, any infation is skipped and raw data is returned.\n */\nLocalReader.prototype.loadFile = function(baseId, callback, isImage, raw){\n\t\n\tvar self = this;\n\n\tvar index = this.getFileIndex(baseId);\n\tvar mftIndex = index;\n\n\t//If the file doesn't exist still make sure to fire the callback\n\tif(mftIndex <= 0 ){\n\t\tself.logger.log(\n\t\t\tT3D.Logger.TYPE_WARNING,\n\t\t\t\"Could not find file with baseId \",baseId\n\t\t);\n\t\tcallback(null);\n\t\treturn;\n\t}\n\n\t//console.log(\"fetchign  baseId \",baseId);\n\t\n\tvar offset = this.mft.entryDict.offset[mftIndex];\n\n\tvar size = this.mft.entryDict.size[mftIndex];\n\t//console.log(\"File at found index is \"+ size +\" bytes\");\n\t\n\tvar compressed = this.mft.entryDict.compressed[mftIndex];\n\tif(!compressed){\n\t\tself.logger.log(\n\t\t\tT3D.Logger.TYPE_WARNING,\n\t\t\t\"File is NOT compressed, skipping\"\n\t\t);\n\n\t\tcallback(null);\n\t\treturn;\n\t}\n\n\t/// Read map and pass the ds to our inflate function\n\t//TODO: will this work?? Shared base id's and all that...\n\tvar handle = index;\n\n\tthis.loadFilePart(this.dat, offset, size, function(ds, size){\n\t\t\n\t\t/// If the raw param was passed return the un-inflated data\n\t\tif(raw){\n\t\t\tcallback(ds);\n\t\t}\n\n\t\t/// If raw parameter was not passed or false, inflate first\n\t\telse{\n\t\t\tself.inflate(ds, size, handle, callback, isImage);\t\n\t\t}\n\t\t\n\t});\n};\n\n\n/**\n * Inflates binary data using an external webworker. If the isImage flag is set the infalted data is\n * also decoded if it contains DXT image data.\n * @method inflate\n * @param  {DataStream} ds DataStream instance holding data to inflate\n * @param  {Number}   size      Number if bytes to read\n * @param  {Number}   handle    Unique ID for this file\n * @param  {Function} callback  callback to register for this inflating task\n * @param  {Boolean}  isImage   Passed to the inflater in order to decode image data\n * @param  {[type]}   capLength Number of bytes to deflate.\n */\nLocalReader.prototype.inflate = function(ds, size, handle, callback, isImage, capLength){\n\t\n\tvar arrayBuffer = ds.buffer;\t\n\n\tif(!capLength){\n\t\t//capLength = arrayBuffer.byteLength;\n\t\tcapLength = 1;\n\t}\n\t//console.log(\"Uncompressing file size \",size, \"handle\", handle, \"cap\", capLength, \"isImage\", isImage);\n\t\n\tif(arrayBuffer.byteLength < 12){\n\t\tthis.logger.log(\n\t\t\tT3D.Logger.TYPE_WARNING,\n\t\t\t\"not inflating, length is too short (\"+arrayBuffer.byteLength+\")\", handle\n\t\t);\n\t\tcallback(null);\n\t\treturn;\n\t}\n\tif(handle == 123350 || handle == 123409 || handle == 123408 ){\n\t\tcallback(null);\n\t\treturn;\n\t}\n\n\t/// Register listener for file load callback\n\tif(this.fileListeners[handle]){\n\t\tthis.fileListeners[handle].push(callback);\n\n\t\t///No need to make another call, just wait for callback event to fire.\n\t\treturn;\n\t}\n\telse{\n\t\tthis.fileListeners[handle] = [callback];\t\n\t}\n\t\n    \n    /// Call the webworker component with the handle and arrayBuffer as an arguments\n\tthis.inflater.postMessage([handle,arrayBuffer,isImage===true, capLength]);\n};\n\n/**\n * Reads bytes from a big file. Uses offset and length (in bytes) in order to only load\n * parts of the file that are used.\n * @method loadFilePart\n * @async\n * @param  {File}   file     File object to read from\n * @param  {[type]}   offset   Offset in bytes to start reading\n * @param  {[type]}   length   Number of bytes to read\n * @param  {Function} callback Two arguments are passed. \n *\n * The first is a DataStream object representation of the loaded data.\n *\n * The second is the length of the data.\n */\nLocalReader.prototype.loadFilePart = function(file, offset, length, callback){\n\tvar self = this;\n\n\tvar reader = new FileReader();\n\t\t\n\treader.onerror = function(fileEvent){\n\t\tdebugger;\n\t}\n\treader.onload  = function(fileEvent){\n\n\t\tvar buffer = fileEvent.target.result;\n\t\tvar ds = new DataStream(buffer);\n\t  \tds.endianness = DataStream.LITTLE_ENDIAN;\n\n\t  \t/// Pass data stream and data length to callback function, keeping \"this\" scope\n\t  \tcallback.call(self, ds, length);\n\t}\n\t\n  \tvar start = offset;\n\tvar end = start + length;\n\treader.readAsArrayBuffer(file.slice(start, end));\n};\n\nmodule.exports = LocalReader;","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/// T3DLib version\nlet version = require('../T3DLib').version;\n\n/// Indexed DB versioning\nconst DB_VERSION = 2;\n\n/**\n * This class handles offline storage of the .dat indexes and files metadata\n * @class PersistantStore\n * @constructor\n */\nclass PersistantStore{\n\n    constructor() {\n        //They may be multiple connection request issued at the same time, but it's actually okay since\n        //as soon as they are registered, the not-used ones will get garbage collected\n        this._dbConnection = undefined;\n        this._getConnection();\n    }\n\n    /**\n     * Initialize the IndexedDB connection and manages version changes.\n     * @async\n     * @method connectDB\n     */\n    _getConnection(){\n        let self = this;\n        return new Promise(function(resolve, reject){\n\n            if(self._dbConnection){\n                return resolve(self._dbConnection);\n            }\n\n            // Let us open our database\n            let request = window.indexedDB.open(\"Tyria3DLibrary\", DB_VERSION);\n            \n            /// onblocked is fired when the db needs an upgrade but an older version is opened in another tab\n            request.onblocked = function(event) {\n                T3D.Logger.log(\n                    T3D.Logger.TYPE_ERROR,\n                    \"The T3D persistant database cannot be upgraded while the app is opened somewhere else.\"\n                );\n            }\n\n            /// fired when the database needs to be upgraded (or the first time)\n            request.onupgradeneeded = function(event){\n                let db = event.target.result;\n                let currentVersion = event.oldVersion;\n\n                /// Define the database structure:\n                if(currentVersion < 1){\n                    let store = db.createObjectStore(\"fileList\", { keyPath: \"baseId\", unique: true});\n                    store.createIndex(\"fileType\", \"fileType\", {unique: false});\n                }\n\n                if(currentVersion < 2){\n                    let newstore = db.createObjectStore(\"listings\", \n                        {keyPath: \"id\", unique: true, autoIncrement: true});                    \n                }\n            }\n\n            request.onsuccess = function(event){\n                self._dbConnection = event.target.result;\n                self.isReady = true;\n                resolve(self._dbConnection);\n            }\n\n            request.onerror = function(event){\n                T3D.Logger.log(\n                    T3D.Logger.TYPE_ERROR,\n                    \"The T3D persistant database could not be opened.\"\n                );\n                reject(request.error);\n            }\n        });\n    }\n\n    getFile(id) {\n        let self = this;\n        return new Resolve(function(resolve, reject){\n            self._getConnection().then((db) => {\n                let request = db.transaction([\"fileList\"], \"readonly\")\n                                .objectStore(\"fileList\")\n                                .get(itemId);\n                request.onsuccess = function(event){\n                    resolve(request.result);\n                }\n                request.onerror = function(event){\n                    reject(request.result);\n                }\n            });\n        });\n    }\n\n    getTypeFiles(fileType, limit) {\n        let self = this;\n        return new Resolve(function(resolve, reject){\n            self._getConnection().then((db) => {\n                let request = db.transaction([\"fileList\"], \"readonly\")\n                    .objectStore(\"fileList\")\n                    .index(\"fileType\")\n                    .getAll(IDBKeyRange.only(fileType), limit);\n                request.onsuccess = function(event){\n                    resolve(request.result);\n                }\n                request.onerror = function(event){\n                    reject(request.result);\n                }\n            });\n        });\n    }\n\n    getHighestId() {\n        let self = this;\n        return new Promise((resolve, reject) => {\n            self._getConnection().then((db) => {\n\n            });\n        });\n    }\n\n    getCount() {\n        let self = this;\n        return new Promise(function(resolve, reject){\n            self._getConnection().then((db) => {\n                let store = db.transaction([\"fileList\"], \"readonly\")\n                    .objectStore(\"fileList\");\n                let reqCount = store.count();\n                reqCount.onsuccess = () => {\n                    resolve(reqCount.result);\n                };\n                reqCount.onerror = reject;\n            });\n        });\n    }\n\n    getFiles(offset, limit) {\n        let self = this;\n        return new Promise(function(resolve, reject){\n\n            let range;\n            if(!offset && !limit)\n                //warning this will blow up\n                range = IDBKeyRange.lowerBound(0);\n            else if(!offset)\n                range = IDBKeyRange.upperBound(limit);\n            else if(!limit)\n                range = IDBKeyRange.lowerBound(offset);\n            else\n                range = IDBKeyRange.bound(offset, limit);\n\n            let returnArray = [];\n            self._getConnection().then((db) => {\n                let request = db.transaction([\"fileList\"], \"readonly\")\n                    .objectStore(\"fileList\")\n                    .getAll(range);\n\n                request.onsuccess = function(event){\n                    //Unfold the result into a usable array\n                    for(let item of request.result){\n                        returnArray[item.baseId] = item;\n                    }\n                    resolve(returnArray);\n                }\n                request.onerror = function(event){\n                    reject(request.result);\n                }\n                \n            });\n        });\n    }\n\n    putFile(item){\n        let self = this;\n        return new Promise(function(resolve, reject){\n            self._getConnection().then((db) => {\n                let request = db.transaction([\"fileList\"], \"readwrite\")\n                .objectStore(\"fileList\")\n                .put(item);\n\n                request.onsuccess = function(event){\n                    resolve(request.result);\n                }\n                request.onerror = function(event){\n                    reject(request.result);\n                }\n            });\n        });\n    }\n\n    deleteFile(item){\n        let self = this;\n        return new Promise(function(resolve, reject){\n            self._getConnection().then((db) => {\n                let request = self._dbConnection.transaction([\"fileList\"], \"readwrite\")\n                    .objectStore(\"fileList\")\n                    .delete(item);\n\n                request.onsuccess = function(event){\n                    resolve(request.result);\n                }\n                request.onerror = function(event){\n                    reject(request.result);\n                }\n            });\n        });\n    }\n\n    getLastListing() {\n        let self = this;\n        return new Promise((resolve, reject) => {\n            self._getConnection().then((db) => {\n                let listingsStore = db.transaction([\"getLastListing\"], \"readonly\")\n                    .objectStore(\"listings\")\n                \n                let init = true;\n                listingsStore.openCursor(IDBKeyRange.only(0), \"prev\").onsuccess = () => {\n                    let cursor = event.target.result;\n                    if(!init)\n                        return resolve();\n                    else\n                        init = false;\n                    cursor.continue();\n                }\n\n                mos\n\n                \n            }).catch(reject);\n        });\n    }\n}\n\nmodule.exports = PersistantStore;","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * A Logger class for T3D\n *\n * This satic class defines severity levels of messages and provides\n * basic logging functionality. Replacing the reference to\n * @class Logger\n * @static \n */\nvar Logger = {};\n\n/**\n * @property {[Number]} TYPE_ERROR\n */\nLogger.TYPE_ERROR = 4;\n\n/**\n * @property {[Number]} TYPE_WARNING\n */\nLogger.TYPE_WARNING = 3;\n\n/**\n * @property {[Number]} TYPE_MESSAGE\n */\nLogger.TYPE_MESSAGE = 2;\n\n/**\n * @property {[Number]} TYPE_PROGRESS\n */\nLogger.TYPE_PROGRESS = 1;\n\n/**\n * @property {[Number]} TYPE_DEBUG\n */\nLogger.TYPE_DEBUG = 0;\n\n\n\n/**\n * The logging functions, indexed by severity/type.\n *\n * @property logFunctions\n * @type Function[]\n */\nLogger.logFunctions = new Array(5);\n\n/**\n * Main logging method. Takes 1 to N arguments. If there are more than 1 arguments\n * the first argument is interpreted as severity. If there is only one argument\n * severity defaults to\n * {{#crossLink \"Logger/TYPE_MESSAGE:property\"}}{{/crossLink}}.\n *  \n * The following arguments are passed to a logging function matching the\n * severity.\n * \n \n * \n * @method  log\n */\nLogger.log = function(){\n\n\t/// Require at least 1 argument\n\tif(arguments.length == 0){\n\t\treturn;\n\t}\n\t\n\t/// Parse arguments to an actual array\n\tvar argArr = Logger.argsToArr(arguments);\n\n\t/// Default to message if just one argument was passed\n\tif(argArr.length == 1){\n\t\targArr.unshift(Logger.TYPE_MESSAGE);\n\t}\n\n\t/// Otherwise 1st arg is severity, log/warn/error\n\tvar severity = Math.max(0,Math.min(Logger.logFunctions.length, argArr.shift()));\n\tvar logFunc  = Logger.logFunctions[severity];\n\n\t/// Ouput the rest of the arguments\n\tlogFunc.apply(this, argArr);\n}\n\nLogger.argsToArr = function(args){\n\tvar argArr = new Array(args.length);\n    for(var i = 0; i < argArr.length; ++i) {\n        argArr[i] = args[i];\n    }\n    return argArr;\n}\n\nLogger.logFunctions[Logger.TYPE_ERROR] = function(){\n\tconsole.error.apply(console,arguments);\n}\n\nLogger.logFunctions[Logger.TYPE_WARNING] = function(){\n\tconsole.warn.apply(console,arguments);\n}\n\nLogger.logFunctions[Logger.TYPE_MESSAGE] = function(){\n\tconsole.log.apply(console,arguments);\n}\n\nLogger.logFunctions[Logger.TYPE_PROGRESS] = function(){\n\tvar argArr = Logger.argsToArr(arguments);\n\targArr.unshift(\"Progress: \");\n\tconsole.log.apply(console,argArr);\n}\n\nLogger.logFunctions[Logger.TYPE_DEBUG] = function(){\n\tvar argArr = Logger.argsToArr(arguments);\n\tconsole.debug.apply(console,argArr);\n}\n\n\nmodule.exports = Logger;","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nmodule.exports = {\n\n\tmaps : [\n\t\t{\n            name:\"01. Shiverpeaks\",\n            maps: [\n                { fileName :\"125199.data\", name:\"Wayfarer Foothills (0)\" },\t\n                { fileName :\"187611.data\", name:\"Wayfarer Foothills (1)\" },\n                { fileName :\"568778.data\", name:\"Cragstead\" },\n                { fileName :\"132434.data\", name:\"Hoelbrak (0)\" },\n                { fileName :\"197122.data\", name:\"Hoelbrak (1)\" },\n                { fileName :\"124093.data\", name:\"Snowden Drifts (0)\" },\t\n                { fileName :\"186397.data\", name:\"Snowden Drifts (1)\" },\n                { fileName :\"275155.data\", name:\"Dredgehaunt Cliffs\" },\n                { fileName :\"276252.data\", name:\"Frostgorge Sound\" },\n                { fileName :\"277587.data\", name:\"Lornar's Pass\" },\n                { fileName :\"278717.data\", name:\"Timberline Falls (0)\"},\n                { fileName :\"846866.data\", name:\"Timberline Falls (1)\" },\n                { fileName :\"1018612.data\", name:\"Timberline Falls (2)\" },\n                { fileName :\"295282.data\", name:\"Eye of the North\" },\n            ]\n        },\n\t\t{\n            name:\"02. Ascalon\",\n            maps: [\n                { fileName :\"126118.data\", name:\"Plains of Ashford (0)\" },\n                { fileName :\"188591.data\", name:\"Plains of Ashford (1)\" },\n                { fileName :\"127888.data\", name:\"Diessa Plateau (0)\" },\t\n                { fileName :\"190490.data\", name:\"Diessa Plateau (1)\" },\n                { fileName :\"131944.data\", name:\"Black Citadel (0)\" },\n\t \t\t\t{ fileName :\"196585.data\", name:\"Black Citadel (1)\" },\n\t \t\t\t{ fileName :\"280025.data\", name:\"Blazeridge Steppes\" },\n\t\t\t\t{ fileName :\"281313.data\", name:\"Fireheart Rise\" },\n\t\t\t\t{ fileName :\"282668.data\", name:\"Iron Marches\" },\n\t\t\t\t{ fileName :\"283574.data\", name:\"Fields of Ruin\" },\n            ]\n        },\n        {\n            name:\"03. Kryta\",\n            maps: [\n                { fileName :\"191000.data\", name:\"Lion's Arch (0)\"},\n                { fileName :\"814803.data\", name:\"Lion's Arch (1)\" },\n                { fileName :\"1019669.data\", name:\"Lion's Arch (Legacy)\" },\n                { fileName: \"1796999.data\", name:\"Lion's Arch (2)\"},\n                { fileName: \"1869665.data\", name:\"Lion's Arch (3)\"},\n                { fileName :\"128151.data\", name:\"Divinity's Reach (0)\"  },\n                { fileName :\"191265.data\", name:\"Divinity's Reach (1)\" },\n                { fileName :\"705746.data\", name:\"Divinity's Reach (2)\" },\n                { fileName :\"129834.data\", name:\"North of Divinity's Reach (0)\" },\t\n                { fileName :\"193081.data\", name:\"North of Divinity's Reach (1)\" },\n                { fileName :\"129524.data\", name:\"Queensdale (0)\" },\n                { fileName :\"192711.data\", name:\"Queensdale (1)\" },\n                { fileName :\"130970.data\", name:\"Kessex Hills (0)\" },\t\n                { fileName :\"194288.data\", name:\"Kessex Hills (1)\" },\n                { fileName :\"672138.data\", name:\"Kessex Hills (2)\" },\n                { fileName :\"861815.data\", name:\"Kessex Hills (3)\" },\n                { fileName :\"286945.data\", name:\"Bloodtide Coast\" },\n                { fileName :\"287870.data\", name:\"Harathi Hinterlands\" },\n                { fileName :\"289176.data\", name:\"Gendarran Fields\" },\n                { fileName :\"295005.data\", name:\"Chantry of Secrets\" },\n                { fileName :\"294938.data\", name:\"Claw Island\" },\n            ]\n        },\n        {\n            name:\"04. Maguuma Jungle\",\n            maps: [\n                { fileName :\"195149.data\", name:\"Caledon Forest\" },\n\t\t\t\t{ fileName :\"195493.data\", name:\"Metrica Province\" },\n                { fileName :\"922320.data\", name:\"Metrica Province Instance\" },\n                { fileName :\"198076.data\", name:\"The Grove\" },\n\t\t\t\t{ fileName :\"198272.data\", name:\"Rata Sum\" },\n\t\t\t\t{ fileName :\"291064.data\", name:\"Mount Maelstrom\" },\n\t\t\t\t{ fileName :\"292254.data\", name:\"Sparkfly Fen\" },\n\t\t\t\t{ fileName :\"293307.data\", name:\"Brisban Wildlands\" },\n            ]\n        },\n        {\n            name:\"05. Ruins of Orr\",\n            maps: [\n                { fileName :\"284829.data\", name:\"Straits of Devastation\" },\n                { fileName :\"285089.data\", name:\"Malchor's Leap\" },\n                { fileName :\"285634.data\", name:\"Cursed Shore\" },\n                { fileName :\"295179.data\", name:\"Cathedral of Hidden Depths\" },\n                { fileName :\"295962.data\", name:\"A Light in the Darkness\" },\n            ]\n        },\n        {\n            name:\"06. Living World S1\",\n            maps: [\n                { fileName :\"520479.data\", name:\"Southsun Cove\" },\n\t\t\t\t{ fileName :\"679089.data\", name:\"Tower of Nightmares\" },\n            ]\n        },\n        {\n            name:\"07. Living World S2\",\n            maps: [\n                { fileName :\"836211.data\", name:\"Dry top (0)\" },\n                { fileName :\"861770.data\", name:\"Dry top (1)\" },\n                { fileName :\"909361.data\", name:\"The Silverwastes (0)\" },\n                { fileName :\"996202.data\", name:\"The Silverwastes (1)\" },\n                { fileName :\"908730.data\", name:\"Glint's Lair\" },\n            ]\n        },\n        {\n            name:\"08. Heart of Maguuma\",\n            maps: [\n                { fileName :\"969663.data\", name:\"Verdant Brink\" },\n                { fileName :\"1262460.data\", name:\"Hearts and Minds\" },\n                { fileName :\"969964.data\", name:\"Unknown Airship in tree\" },\n                { fileName :\"1262310.data\", name:\"Dragon Stand\" },\n                { fileName :\"1263739.data\", name:\"Tarir\" },\n\t\t\t\t{ fileName :\"1264291.data\", name:\"Tangled Depths\" },\n            ]\n        },\n        {\n            name:\"09. Living World S3\",\n            maps: [\n                { fileName :\"1472635.data\", name:\"(E1) Bloodstone Fen\" },\n                { fileName :\"1498071.data\", name:\"(E2) Taimi Simulator\" },\n                { fileName :\"1498578.data\", name:\"(E2) Ring of Fire\" },\n                { fileName :\"1605211.data\", name:\"(E3) Bitterfrost Frontier\" },\n                { fileName :\"1645474.data\", name:\"(E4) Caudecus Manor\" },\n                { fileName :\"1646520.data\", name:\"(E4) Lake Doric\" },\n                { fileName :\"1682493.data\", name:\"(E5) Draconis Mons\" },\n                { fileName :\"1682763.data\", name:\"(E5) Titan's Throat\" },\n                { fileName: \"1734839.data\", name:\"(E6) White Mantle Fortress\"},\n\t\t\t\t{ fileName: \"1735346.data\", name:\"(E6) Siren's Landing\"},\n\t\t\t\t{ fileName: \"1735440.data\", name:\"(E6) Shining Blade Headquarters\"},\n            ]\n        },\n        {\n            name:\"10. Crystal Desert\",\n            maps: [\n                { fileName: \"1794574.data\", name:\"Crystal Oasis\"},\n                { fileName: \"1833034.data\", name:\"Desert Highlands\"},\n                { fileName: \"1833726.data\", name:\"PoF story instances\"},\n                { fileName: \"1839188.data\", name:\"Domain of Vabbi\"},\n\t\t\t\t{ fileName: \"1840103.data\", name:\"Elon Riverlands\"},\n\t\t\t\t{ fileName: \"1840368.data\", name:\"Kormir Sanctuary\"},\n\t\t\t\t{ fileName: \"1842533.data\", name:\"The Desolation\"},\n            ]\n        },\n        {\n            name:\"11. Living World S4\",\n            maps: [\n                { fileName: \"1901428.data\", name:\"(E1) Fahranur\"},\n\t\t\t\t{ fileName: \"1902235.data\", name:\"(E1) Istan\"},\n                { fileName: \"1903523.data\", name:\"(E1) Crystal Oasis\"},\n                { fileName: \"1954984.data\", name:\"(E2) Desert Highlands\"},\n\t\t\t\t{ fileName: \"1955224.data\", name:\"(E2) Inquest Lab Tower\"},\n\t\t\t\t{ fileName: \"1955471.data\", name:\"(E2) Rata Primus\"},\n\t\t\t\t{ fileName: \"1955642.data\", name:\"(E2) Divinity's Reach\"},\n\t\t\t\t{ fileName: \"1955915.data\", name:\"(E2) Mount Maelstrom\"},\n\t\t\t\t{ fileName: \"1956140.data\", name:\"(E2) Frostgorge Sound\"},\n\t\t\t\t{ fileName: \"1956245.data\", name:\"(E2) Void\"},\n\t\t\t\t{ fileName: \"1956299.data\", name:\"(E2) Hided Inquest Lab\"},\n\t\t\t\t{ fileName: \"1957526.data\", name:\"(E2) Sandswept Isles\"}\n            ]\n        },\n        {\n            name:\"12. Seasonal Activities\",\n            maps: [\n                { fileName :\"506592.data\", name:\"Ascent to Madness\" },\n\t\t\t\t{ fileName :\"506670.data\", name:\"Mad King's Labyrinth (Past)\" },\n\t\t\t\t{ fileName :\"662436.data\", name:\"Mad King's Labyrinth (Present)\" },\n                { fileName :\"506739.data\", name:\"Mad King's Clock Tower\" },\n                { fileName :\"622681.data\", name:\"The Crown Pavilion\" },\n                { fileName :\"569756.data\", name:\"SAB Hub (0)\" },\n                { fileName :\"636133.data\", name:\"SAB Hub (1)\" },\n\t\t\t\t{ fileName :\"635555.data\", name:\"SAB World 1\" },\n                { fileName :\"635960.data\", name:\"SAB World 2\" },\n                { fileName :\"606255.data\", name:\"Zephyr Sanctum\" },\n                { fileName :\"529896.data\", name:\"Tixx's Infinirarium\" },\n\t\t\t\t{ fileName :\"529945.data\", name:\"Winter Wonderland\" },\n            ]\n        },\n        {\n            name:\"13. Activites\",\n            maps: [\n                { fileName :\"605983.data\", name:\"Sanctum Sprint\" },\n\t\t\t\t{ fileName :\"606030.data\", name:\"Basket Brawl\" },\n            ]\n        },\n        {\n            name:\"14. Dungeons\",\n            maps: [\n                { fileName :\"126840.data\", name:\"Ascalonian Catacombs (0)\" },\n                { fileName :\"189364.data\", name:\"Ascalonian Catacombs (1)\" },\n\t\t\t\t{ fileName :\"275474.data\", name:\"Sorrow's Embrace\" },\n\t\t\t\t{ fileName :\"276520.data\", name:\"Honor of the Waves\" },\n\t\t\t\t{ fileName :\"284039.data\", name:\"Citadel of Flame\" },\n\t\t\t\t{ fileName :\"287214.data\", name:\"Caudecus's Manor\" },\n\t\t\t\t{ fileName :\"291284.data\", name:\"Twilight Arbor (0)\" },\n\t\t\t\t{ fileName :\"645968.data\", name:\"Twilight Arbor (1)\" },\n\t\t\t\t{ fileName :\"293606.data\", name:\"Crucible of Eternity\" },\n\t\t\t\t{ fileName :\"473930.data\", name:\"The Ruined City of Arah\" },\n\t\t\t\t{ fileName :\"473765.data\", name:\"Arah - Story\" },\n\t\t\t\t{ fileName :\"580061.data\", name:\"Molten Facility\" },\n\t\t\t\t{ fileName :\"595722.data\", name:\"Aetherblade Retreat\" },\n            ]\n        },\n        {\n            name:\"15. Fractals\",\n            maps: [\n                { fileName :\"519839.data\", name:\"Fractals of the Mists\" },\n                { fileName :\"697450.data\", name:\"Thaumanova Reactor\" },\n                { fileName :\"1426653.data\", name:\"Cliffside Fractal\" },\n                { fileName :\"1472361.data\", name:\"Chaos Isle Fractal\" },\n                { fileName :\"1472382.data\", name:\"Snowblind Fractal\" },\n                { fileName :\"1472406.data\", name:\"Swampland Fractal\" },\n                { fileName :\"1498016.data\", name:\"Mistlock Observatory\" },\n                { fileName :\"1498798.data\", name:\"Aetherblade/Mai Trin Fractal\" },\n                { fileName :\"1605344.data\", name:\"Nightmare Fractal\" },\n                { fileName: \"1733857.data\", name:\"Shattered Observatory Fractal\"},\n                { fileName: \"1733961.data\", name:\"Mistlock Sanctuary\"},\n                { fileName: \"1905739.data\", name:\"Molten Boss Fractal\"},\n\t\t\t\t{ fileName: \"1905889.data\", name:\"Twilight Oasis Fractal\"},\n            ]\n        },\n        {\n            name:\"16. Raid\",\n            maps: [\n                { fileName :\"1151420.data\", name:\"(W1) Spirit Vale\" },\n                { fileName :\"1383309.data\", name:\"(W2) Salvation Pass\" },\n                { fileName :\"1427048.data\", name:\"Special Forces Training Area\" },\n                { fileName :\"1454070.data\", name:\"(W3) Stronghold of the Faithful\" },\n                { fileName :\"1645215.data\", name:\"(W4) Bastion of the Penitent\" },\n                { fileName: \"1906329.data\", name:\"(W5) Hall of Chains\"},\n            ]\n        },\n        {\n            name:\"17. Structured PvP\",\n            maps: [\n                { fileName :\"871093.data\", name:\"Original Stronghold\" },\n                { fileName :\"870987.data\", name:\"Battle of Champion's Dusk (0)\" },\n                { fileName :\"1666233.data\", name:\"Battle of Champion's Dusk (1)\" },\n                { fileName :\"132570.data\", name:\"Heart of the Mists (0)\" },\n                { fileName :\"197249.data\", name:\"Heart of the Mists (1)\" },\n                { fileName: \"1734729.data\", name:\"Heart of the Mists (2)\"},\n                { fileName: \"1712986.data\", name:\"Hall of the Mists\"},\n                { fileName :\"132710.data\", name:\"The Battle of Khylo (0)\" },\n                { fileName :\"197402.data\", name:\"The Battle of Khylo (1)\" },\n                { fileName :\"132837.data\", name:\"Forest of Niflhel (0)\" },\n                { fileName :\"197545.data\", name:\"Forest of Niflhel (1)\" },\n                { fileName :\"376916.data\", name:\"Legacy of the Foefire\" },\n                { fileName :\"467374.data\", name:\"Raid on the Capricorn\" },\n                { fileName :\"520609.data\", name:\"Temple of the Silent Storm\" },\n                { fileName :\"579383.data\", name:\"Skyhammer (0)\" },\n                { fileName :\"677968.data\", name:\"Skyhammer (1)\" },\n                { fileName: \"1934470.data\", name:\"Skyhammer (2)\"},\n                { fileName :\"791564.data\", name:\"Courtyard (0)\" },\n                { fileName: \"1713054.data\", name:\"Courtyard (1)\"},\n                { fileName :\"556199.data\", name:\"Spirit Watch (0)\" },\n                { fileName :\"1473061.data\", name:\"Spirit Watch (1)\" },\n                { fileName :\"506539.data\", name:\"Reaper's Rumble\" },\n                { fileName :\"529718.data\", name:\"Snowball Mayhem\" },\n                { fileName :\"595582.data\", name:\"Dragon Ball Arena\" },\n                { fileName :\"617120.data\", name:\"Aspect Arena\" },\n                { fileName :\"1644624.data\", name:\"Revenge of the Capricorn\" },\n                { fileName: \"1704155.data\", name:\"Eternal Coliseum\"},\n            ]\n        },\n        {\n            name:\"18. World vs World\",\n            maps: [\n                { fileName :\"131235.data\", name:\"Eternal Battlegrounds (0)\" },\n                { fileName :\"195806.data\", name:\"Eternal Battlegrounds (1)\" },\n                { fileName: \"1885693.data\", name:\"Eternal Battlegrounds (2)\"},\n                { fileName: \"1918037.data\", name:\"Eternal Battlegrounds (3)\"},\n                { fileName :\"131574.data\", name:\"Alpine Borderlands (0)\" },\n                { fileName :\"641501.data\", name:\"Alpine Borderlands (1)\" },\n                { fileName: \"1799855.data\", name:\"Alpine Borderlands (2)\"},\n                { fileName :\"1647236.data\", name:\"Desert Borderlands (0)\" },\n                { fileName: \"1799442.data\", name:\"Desert Borderlands (1)\"},\n                { fileName :\"736241.data\", name:\"Edge of the Mists\" },\n            ]\n        },\n        {\n            name:\"19. Guild Halls\",\n            maps: [\n                { fileName :\"1255378.data\", name:\"Gilded Hollow\" }, \n                { fileName :\"1256064.data\", name:\"Lost Precipice\" },\n                { fileName: \"1843274.data\", name:\"Windswept Haven\"},\n            ]\n        },\n        {\n            name:\"20. Concept and not released\",\n            maps: [\n                { fileName :\"122695.data\", name:\"Empty Plane\" },\n                { fileName :\"184799.data\", name:\"Empty Plane v1\" },\n                { fileName :\"197562.data\", name:\"Empty Plane v2\" },\n                { fileName :\"875614.data\", name:\"Unknown Mists Platforms\" },\n                { fileName :\"132853.data\", name:\"Empty Box\" },\n                { fileName :\"1255516.data\", name:\"Guild Coliseum\" },\n                { fileName :\"1498193.data\", name:\"Concept sPVP Map 1\" },\n                { fileName :\"1513556.data\", name:\"Concept sPVP Map 2\" }, \n\t\t\t\t{ fileName :\"1513607.data\", name:\"Concept sPVP Map 3\" },\n\t\t\t\t{ fileName :\"1513620.data\", name:\"Concept sPVP Map 4\" },\n                { fileName :\"1513675.data\", name:\"Concept sPVP Map 5\" },\n                { fileName: \"1712945.data\", name:\"Concept sPVP Map 6\"},\n            ]\n        },\n\n    ]\n}","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * Provides the static Tyria 3D Library Class.\n * @module T3D\n */\n\n/* INCLUDES */\nLocalReader = require('./LocalReader/LocalReader.js');\n\n/**\n * Tyria 3D Library main class.\n * \n * Use this static class to access file parsers- and data renderer classes.\n * \n * This class also works as a factory for creating\n * LocalReader instances that looks up and inflates files from the Guild Wars 2 .dat.\n *\n * @main T3D\n * @class T3D\n * @static \n */\nmodule.exports = T3D;\nfunction T3D() {}\n\n/* PRIVATE VARS */\nvar _version = \"1.1.0\";\nvar _settings = {\n\tt3dtoolsWorker: \"modules/t3dtools/t3dworker.js\",\n\tconcurrentTasks: (typeof navigator != 'undefined') ? navigator.hardwareConcurrency : 1,\n};\n\n/* PUBLIC PROPERTIES */\n\n/**\n * The current library version. Used to make sure local storage caches are not\n * shared between different releases.\n *\n * @final\n * @property version\n * @type String\n */\nT3D.version = _version;\n\n\n/* FILES */\n\n/**\n * A static reference to the GW2File class, the preferred way of\n * accessing this class.\n *\n * @final\n * @property GW2File\n * @type Class\n */\nT3D.GW2File =\t\t\t\trequire(\"./format/file/GW2File\");\n\n/**\n * A static reference to the GW2Chunk class, the preferred way of\n * accessing this class.\n *\n * @final\n * @property GW2Chunk\n * @type Class\n */\nT3D.GW2Chunk = \t\t\t\trequire(\"./format/file/GW2Chunk\");\n\n/**\n * TODO - doc\n */\nT3D.Archive =\t\t\t\trequire(\"./LocalReader/Archive\");\n\n\n/* RENDERERS */\n\n/**\n * A static reference to the DataRenderer class, the preferred way of\n * accessing this class.\n * \n * @final\n * @property DataRenderer\n * @type Class\n */\nT3D.DataRenderer = \t\t\trequire(\"./dataRenderer/DataRenderer\");\n\n/**\n * A static reference to the EnvironmentRenderer class, the preferred way of\n * accessing this class.\n *\n * @final\n * @property EnvironmentRenderer\n * @type Class\n */\nT3D.EnvironmentRenderer = \trequire(\"./dataRenderer/EnvironmentRenderer\");\n\n/**\n * A static reference to the HavokRenderer class, the preferred way of\n * accessing this class.\n * \n * @final\n * @property HavokRenderer\n * @type Class\n */\nT3D.HavokRenderer = \t\trequire(\"./dataRenderer/HavokRenderer\");\n\n/**\n * A static reference to the PropertiesRenderer class, the preferred way of\n * accessing this class.\n *\n * @final\n * @property PropertiesRenderer\n * @type Class\n */\nT3D.PropertiesRenderer = \trequire(\"./dataRenderer/PropertiesRenderer\");\n\n/**\n * A static reference to the SingleModelRenderer class, the preferred way of\n * accessing this class.\n *\n * @final\n * @property SingleModelRenderer\n * @type Class\n */\nT3D.SingleModelRenderer = \t\trequire(\"./dataRenderer/SingleModelRenderer\");\n\n/**\n * A static reference to the TerrainRenderer class, the preferred way of\n * accessing this class.\n *\n * @final\n * @property TerrainRenderer\n * @type Class\n */\nT3D.TerrainRenderer = \t\trequire(\"./dataRenderer/TerrainRenderer\");\n\n/**\n * A static reference to the ZoneRenderer class, the preferred way of\n * accessing this class.\n *\n * @final\n * @property ZoneRenderer\n * @type Class\n */\nT3D.ZoneRenderer = \t\t\trequire(\"./dataRenderer/ZoneRenderer\");\n\n/**\n * A static reference to the StringRenderer class, the preferred way of\n * accessing this class.\n *\n * @final\n * @property StringRenderer\n * @type Class\n */\nT3D.StringRenderer = \t\trequire(\"./dataRenderer/StringRenderer\");\n\n\n\n\n/* LOGGING */\n\n/**\n * A static reference to the static Logger object, the preferred way of\n * accessing this object. A simple way of providing your own logging methods\n * is to simply overwrite any or all of the logging methods specified in \n * {{#crossLink \"Logger/logFunctions:property\"}}{{/crossLink}}\n *\n * @property Logger\n * @type Object\n */\nT3D.Logger = require(\"./Logger\");\n\n\n/* SETTINGS */\n\n/**\n * Contains a list of known map fileID:s and their names. Used in order to quickly\n * look up what maps are in a .dat file. Note that this property is hard coded and\n * has high probablity of being outdated. Also note that the names are just guesses\n * by RequestTimeout.\n *\n * The format of this list objects is\n *\n * \n * \t{ \n *  \tmaps : [\n *\t  \t\t{\n *     \t\t\tname:\"World Area Name\",\n *\t       \t\tmaps:[\n *\t         \t\t{ fileName :\"[numeric fileId].data\", name:\"Map Name One\" },\n *\t           \t\t{ fileName :\"[numeric fileId].data\", name:\"Map Name Two\" },\t\t\n *\t             \t{ fileName :\"[numeric fileId].data\", name:\"Map Name Three\" }\n *\t              ]\n *           },\n *\t         {\n *\t\t\t    name:\"Another World Area Name\",\n *\t\t \t   \tmaps:[\n *\t\t \t\t   \t{ fileName :\"[numeric fileId].data\", name:\"Map Name 408\" }\n *\t\t\t    ]\n *\t\t     }\n * \t\t]\n *   }\n *\n * @final\n * @property MapFileList\n * @type Object\n */\nT3D.MapFileList = \trequire(\"./MapFileList\");\n\n/* UTILS */\n\n/**\n * A static reference to the MaterialUtils class.\n *\n * @final\n * @property MaterialUtils\n * @type Object\n */\nT3D.MaterialUtils = require('./util/MaterialUtils.js');\n\n/**\n * A static reference to the MathUtils class.\n *\n * @final\n * @property MathUtils\n * @type Object\n */\nT3D.MathUtils = require('./util/MathUtils.js');\n\n/**\n * A static reference to the ParserUtils class.\n *\n * @final\n * @property ParserUtils\n * @type Object\n */\nT3D.ParserUtils = require('./util/ParserUtils.js');\n\n\n/**\n * A static reference to the RenderUtils class.\n *\n * @final\n * @property RenderUtils\n * @type Object\n */\nT3D.RenderUtils = require('./util/RenderUtils.js');\n\n/**\n * A static reference to the PersistantStore class.\n * \n * @final\n * @property PersistantStore\n * @type Class\n */\nT3D.PersistantStore = require('./LocalReader/PersistantStore');\n\n/**\n * TODO - doc\n */\nT3D.Archive = require('./LocalReader/Archive');\nT3D.FileTypes = require('./LocalReader/FileTypes');\n\n/* PRIVATE METHODS */\n\n/**\n * Performs checks for required browser capabilities and required third party libraries.\n * Loggs any warnings or error messages.\n * \n * @private\n * @method  checkRequirements\n * @return {Number} The ammount of errors and warnings generated.\n */\nfunction checkRequirements(){\n\tvar numErrors = 0;\n\n\tif(!global.window || !window.indexedDB){\n\t\tT3D.Logger.log(\n\t\t\tT3D.Logger.TYPE_ERROR,\n\t\t\t\"T3D persistant storing and loading requires indexedDB support.\"\n\t\t);\n\t\tnumErrors++;\n\t}\n\n\tif(typeof DataStream === \"undefined\"){\n\t\tT3D.Logger.log(\n\t\t\tT3D.Logger.TYPE_ERROR,\n\t\t\t\"T3D core functionality requires DataStream library.\"\n\t\t);\n\t\tnumErrors++;\n\t}\n\n\tif(typeof THREE === \"undefined\"){\n\t\tT3D.Logger.log(\n\t\t\tT3D.Logger.TYPE_WARNING,\n\t\t\t\"T3D mesh generation requires three.js library.\"\n\t\t);\n\t\tnumErrors++;\n\t}\n\n\tif(numErrors<1){\n\t\tT3D.Logger.log(\n\t\t\tT3D.Logger.TYPE_MESSAGE,\n\t\t\t\"Tyria 3D API v\"+T3D.version+\" initialized.\"\n\t\t);\n\t}\n\n\treturn numErrors;\n}\n\n/**\n * Performs a quick and dirty check to find what chunk name definitions \n * appear multiple times in th formats array. Note that anything that\n * appears more than 2 times wil get a too hight value due to the \n * algorithm being... incorrect.\n *\n * @private\n * @method findDuplicateChunkDefs\n * @return {Object} An object mapping duplicate chunk definition names.\n * to the number of apperances.\n */\nfunction findDuplicateChunkDefs(){\n\tvar dups = {};\n\tT3D.formats.forEach(\n\t\tfunction(f1){\n\n\t\t\tT3D.formats.forEach(\n\t\t\t\tfunction(f2){\n\t\t\t\t\tif(f2.name == f1.name && f2 !== f1){\n\t\t\t\t\t\tif(dups[f1.name]){\n\t\t\t\t\t\t\tdups[f1.name]++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse{\n\t\t\t\t\t\t\tdups[f1.name]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t);\n\treturn dups\n}\n\n\n/* PUBLIC METHODS */\n\n\n/**\n * Creates a new instance of LocalReader with a webworker inflater connected to it.\n * \n * @method getLocalReader\n * @async\n * @param  {File}   \tfile\t\tCore JS File instance, must refer to a GW2 .dat file\n * @param  {Function}\tcallback\tCallback function, fired when the file index is fully\n *                             \t\tconstructed. Takes no arguments.\n *                             \t\t\n * @param  {String} \tt3dtoolsWorker URL to the inflater file. If omitted\n *                               \t_settings.t3dtoolsWorker will be used instead.\n * @param  {Class}\t\tlogger\t\t\n * \n * @return {LocalReader}\t\t\tThe contructed LocalReader, note that this object\n *                             \t\twill not be fully initialized until the callback\n *                             \t\tis fired.\n */\nT3D.getLocalReader = function(file, callback, t3dtoolsWorker, logger){\n\n\t/// Create Inflater for this file reader.\n\tvar worker = new Worker(t3dtoolsWorker ? t3dtoolsWorker : _settings.t3dtoolsWorker);\n\n\tvar lrInstance = new LocalReader(file, logger);\n\tlrInstance.connectInflater(worker);\n\n\t/// Parse the DAT file MFT header. This must be done oncein order to access\n\t/// any files in the DAT.\n\tlrInstance.parseHeaderAsync(callback);\n\n\t/// Return file reader object\n\treturn lrInstance;\t\n}\n\n/**\n * Utility method for acceccing a list containing information about all files\n * in the .dat connected to the provided LocalReader instance. This method first\n * tries to read a local indexing list from the client's localstorage and\n * fallbacks to generating the list by scanning the MFT indices of the .dat\n * and peeking each file in order to find out what filetype it has.\n *\n * Note that peeking the files is the time consuming task, so if you don't want\n * yout application to spend time indexing the .dat and have a priori knowledge\n * about the required file Id's you should not use this method.\n * \n * @method  getFileListAsync\n * @async\n * @param  {LocalReader}\tlocalReader A fully initialized LocalReader instance\n * @param  {Function}\t\tcallback    Fires when the index has been loaded\n *                                 \t\tfrom the localstorage or after it has\n *                                 \t\tbeen built and stored in localstorage.\n *                                 \t\tTakes the generated object list of\n *                                 \t\tfiles as an argument. This list groups\n *                                 \t\tarrays of MFT indices per file type,\n *                                 \t\tfor exmample:\n *\n * \n * \t{\n *\t  \t\"Unknown\"\t: [444, 555, 333],\n *\t  \t\"MODL\"\t\t: [444, 555, 333],\n * \t  \t\"String\"\t: [666, 777, 888]\n * \t}\n * \n * For more details see\n * {{#crossLink \"LocalReader/listFiles:method\"}}{{/crossLink}}\n */\nT3D.getFileListAsync = function(localReader, callback){\n\n\t/// Check local storage for an existing file list\n\tvar fileList = localReader.loadFileList();\n\n\t/// If there is no cached list, look for pre-defined maps.\n\tif(!fileList){\n\t\tlocalReader.readFileListAsync(callback);\n\t}\n\n\t/// Otherwise, just fire the callback with the cached list\n\telse{\n\t\tcallback(fileList);\n\t}\n\t\n}\n\n/**\n * Utility method for acceccing a list containing information about all map files\n * in the .dat connected to the provided LocalReader instance. This method first\n * tries to read a local indexing list from the client's localstorage and\n * fallbacks to generating the list by scanning the MFT indices of the .dat\n * and peeking each file in order to find out what filetype it has.\n *\n * If the searchAll flag is not set to true, this process will only scan files\n * from the {{#crossLink \"T3D/MapFileList:property\"}}{{/crossLink}}\n * \n * @method getMapListAsync\n * @async\n * @param {LocalReader}\tlocalReader\tA fully initialized LocalReader instance\n * @param {Function}\tcallback\tFires when the index has been loaded\n *                                 \tfrom the localstorage or after it has\n *                                 \tbeen built and stored in localstorage.\n *                                 \tTakes the generated object list of\n *                                 \tfiles as an argument. This list groups\n *                                 \tarrays of MFT indices per file type,\n *                                 \tfor exmample:\n * \n * \t\t{\t\n * \t\t\tmaps:[\n * \t\t\t\t{\n * \t\t\t\t\tname: 'Heart of Maguuma',\n * \t\t\t\t\tmaps: [\n * \t\t\t\t\t\t{fileName:1151420, name:'HoT BWE3 Raid'},\n * \t\t\t\t\t\t{fileName:969663, name:'Verdant Brink}\n * \t\t\t\t\t]\n * \t\t\t\t},\n * \t\t\t\t{\n * \t\t\t\t\tname: 'Unknown maps',\n * \t\t\t\t\tmaps: [\n * \t\t\t\t\t\t{fileName:12345678, name:'Unknown map 12345678'}\n * \t\t\t\t\t]\n * \t\t\t\t}\n * \t\t\t]\n \n *\t    };\n * @param {boolean} searchAll if true forces re-indexing of entire dat.\n */\nT3D.getMapListAsync = function(localReader, callback, searchAll){\n\n\t/// If seachAll flag is true, force a deep search\n\tif(searchAll){\n\t\tlocalReader.readMapListAsync(true, callback);\n\t\treturn;\n\t}\n\n\t/// Check local storage for an existing map list\n\tvar mapList = localReader.loadMapList();\n\n\t/// If there is no cached list, look for pre-defined maps.\n\tif(!mapList){\n\t\tlocalReader.readMapListAsync(false, callback);\n\t}\n\n\t/// Otherwise, just fire the callback with the cached list\n\telse{\n\t\tcallback(mapList);\n\t}\n\t\n}\n\n/**\n * Utility method used for rendering map files. Loads a map file and applies\n * the provided renderers to it.\n * \n * @method renderMapContentsAsync\n * @async\n * @param  {LocalReader}\tlocalReader A fully initialized LocalReader instance\n * @param  {Number}   \t\tfileName\tThe File Id of a mapc file.\n * @param  {Array}   \t\trenderers\tAn array of renderer classes. Each\n *                               \t\tclass should extend \n *                               \t\t{{#crossLink \"DataRenderer\"}}{{/crossLink}}\n * @param  {Function}\t\tcallback    Callback function, takes the shared\n *                                 \t\trenderer context as an argument.\n * @param  {Class}\t\t\tlogger      A logger class of the same type as\n *                               \t\t{{#crossLink \"Logger\"}}{{/crossLink}}\n */\nT3D.renderMapContentsAsync = function(localReader, fileName, renderers, callback, logger){\n\n\t/// VO for storing result from renderers\n    var context = {};\n\n\t/// Make sure we got an actuall ID number\t\t\n\tif(parseInt(fileName)){\n\n\t\t/// File name is baseId, load using local reader.\n\t\tlocalReader.loadFile(\n\t\t\tfileName,\n\t\t\tfunction(arrayBuffer){\n\n\t\t\t\t/// Set up datastream\n\t\t\t\tvar ds = new DataStream(arrayBuffer, 0, DataStream.LITTLE_ENDIAN);\n\n\t\t\t\t/// Initiate Map file object. Connect callback\n\t\t\t\tvar mapFile = new T3D.GW2File(ds, 0);\n\n\t\t\t\t/// Populate VO by running the renderers\n\t\t\t    var runAllRenderers = function(i){\n\t\t\t\t\t\n\t\t\t\t\t/// Run each renderer\n\t\t\t\t\tif(i < renderers.length ){\n\t\t\t\t\t\tT3D.runRenderer(\n\t\t\t\t\t\t\trenderers[i].renderClass,\n\t\t\t\t\t\t\tlocalReader,\n\t\t\t\t\t\t\tObject.assign(renderers[i].settings,{mapFile:mapFile}),\n\t\t\t\t\t\t\tcontext,\n\t\t\t\t\t\t\trunAllRenderers.bind(this,i+1)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\t/// Fire callback with VO when done\n\t\t\t\t\telse{\n\t\t\t\t\t\tcallback(context);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t/// Starting point for running each renderer\n\t\t\t\trunAllRenderers(0);\n\t\t\t}\n\t\t);\n\t}\n\n\t/// Primitive error message...\n\telse{\n\t\tvar outputLogger = logger ? logger : T3D.Logger;\n\t\toutputLogger.log(\n\t\t\tT3D.Logger.TYPE_ERROR,\n\t\t\t\"Map id must be an integer!, was:\",fileName\n\t\t);\n\t}\t\n}\n\n/**\n * Utility method for applying a single renderer to a LocalReader insatnce.\n * \n * @method runRenderer\n * @async\n * \n * @param  {Class}\t\trenderClass\tA class extending \n *                                \t{{#crossLink \"DataRenderer\"}}{{/crossLink}}\n * @param  {LocalReader}localReader A fully initialized LocalReader instance\n * @param  {Object}\t\tsettings    Settings passed to the renderer. Often\n *                               \tspecifies thinks like what file ID should\n *                               \tbe loaded.\n * @param  {Object}\t\tcontext     The shared renderer context value object.\n * @param  {Function} \tcb          Callback method passed to the renderAsync\n *                                 \tmethod of the renderer.\n */\nT3D.runRenderer = function(renderClass, localReader , settings, context, cb){\n\tvar r = new renderClass(\n\t\tlocalReader,\n\t\tsettings,\n\t\tcontext\n\t);\n\n\tr.renderAsync(cb);\n}\n\n\n/**\n * @method getContextValue\n * @param  {Object} context      \tA shared renderer context value object.\n * @param  {Class} \tclazz        \tA class extending\n *                                \t{{#crossLink \"DataRenderer\"}}{{/crossLink}}.\n *                                \tSpecifies for renderer class you want to read \n *                                \toutput.\n * @param  {String} propName     \tThe name of the property written by the\n *                                \trenderer that should retrtieved.\n * @param  {any} \tdefaultValue \tThis value is passed back if no data could\n *                              \tbe found.\n * @return {any}    \t\t\t\tThe specified value from the conext if any,\n *                          \t\totherwise defaultValue.\n */\nT3D.getContextValue = function(context, clazz , propName, defaultValue){\n\tvar output = context[clazz.name];\n\tif(output){\n\t\treturn output[propName] ? output[propName] : defaultValue;\n\t}\n\treturn defaultValue;\n}\n\n/**\n * Check if the client web browser can render WebGL 3D content.\n * \n * @private\n * @method hasWebGL\n * @param  {boolean} return_context flag making this method return the canvas object instead of true\n * @return {boolean} true if the client is WebGL enabled, false otherwise\n */\nT3D.hasWebGL = function(return_context)\n{\n    if (!!window.WebGLRenderingContext) {\n        var canvas = document.createElement(\"canvas\"),\n             names = [\"webgl\", \"experimental-webgl\", \"moz-webgl\", \"webkit-3d\"],\n           context = false;\n \n        for(var i=0;i<4;i++) {\n            try {\n                context = canvas.getContext(names[i]);\n                if (context && typeof context.getParameter == \"function\") {\n                    // WebGL is enabled\n                    if (return_context) {\n                        // return WebGL object if the function's argument is present\n                        return {name:names[i], gl:context};\n                    }\n                    // else, return just true\n                    return true;\n                }\n            } catch(e) {}\n        }\n \n        // WebGL is supported, but disabled\n        return false;\n    }\n \n    // WebGL not supported\n    return false;\n}\n\n\n/// Library checks requirements on startup\ncheckRequirements();","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nvar GW2File = require('../format/file/GW2File');\n\n/**\n * Base class for data interpretors a.k.a. 'Renderers'\n *\n * Renderers are classes that collect and interpret data from the dat file.\n * \n * A {{#crossLink \"LocalReader\"}}{{/crossLink}} instance is used for accessing data from the dat.\n * \n * A {{#crossLink \"Logger\"}}{{/crossLink}} is used for posting progress output or error messages.\n *\n * Most Renderers use one or more\n * {{#crossLink \"GW2Chunk\"}}GW2Chunks{{/crossLink}}, typed data structures that can be read from\n * {{#crossLink \"GW2File\"}}GW2Files{{/crossLink}}.\n *\n * The generated data, be it strings, numbers or meshes are put into a value object structure called\n * the 'context'. The context can store data generated by multiple renderers and makes sure each\n * renderer type, or class has it's own value object within the context. This enables one renderer\n * to read data written by another renderer wihtout having to worry about overwriting existing data\n * within the context. Keep in mind that you will have to manually pass and clean the conext object!\n *\n * A clean context object should just be the empty javasript object : {}.\n *\n * When a Renderer is done it will fire the callback and any view interrested in retrieving the generated\n * data from the context can read it using\n * {{#crossLink \"T3D/getContextValue:method\"}}{{/crossLink}}.\n * \n * \n * \n * \n * @class DataRenderer\n * @constructor\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nvar DataRenderer = module.exports = function(localReader, settings, context, logger) {\n\n\t/// Just storing parameters\n\tthis.localReader = localReader;\n\tthis.settings = settings;\n\tif(!settings){\n\t\tsettings = {};\n\t}\n\tthis.context = context;\n\tthis.context[this.constructor.name] = {};\n\n\tif(logger)\n\t\tthis.logger = logger;\n\telse\n\t\tthis.logger = T3D.Logger;\t\n}\n\n/**\n * Gets the output value object for a specified class within the context.\n * @method  getOutput\n * @param  {Class} otherClass The class to fetch the output value object for.\n * If not specified the class of this instance will be used.\n * @return {Object}            The output value object for this class within the context.\n */\nDataRenderer.prototype.getOutput = function(otherClass){\n\treturn this.context[otherClass ? otherClass.name : this.constructor.name];\n}\n\n/**\n * Basic rendering of unknown files. Output fileds generated:\n *\n * - *fileId* The fileId passed in the settings parameter when constructing this instance.\n * \n * - *rawData* An ArrayBuffer containg the infalted binary data of the loaded file.\n * \n * - *rawString* A string representation of the rawData\n * \n * - *image* A value object witht he fields 'width', 'height' and 'data' describing a RGBA bitmap\n * image. Only set if the loaded file was a texture.\n * \n * - *file* A GW2File representation of the loaded file. Only set if the loaded file was a Pack File.\n * \n * @method  renderAsync\n * @async\n * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n */\nDataRenderer.prototype.renderAsync = function(callback){\n\tvar self = this;\n\t\n\tthis.localReader.loadFile(this.settings.id, function(inflatedData){\n\n\t\t/// Set fileId so callers can identify this VO\t\t\n\t\tself.getOutput().fileId = self.settings.id;\n\n\t\t/// Share inflated data\n\t\tself.getOutput().rawData = inflatedData;\n\n\t\t/// Construct raw string\n\t\tvar uarr = new Uint8Array(inflatedData);\n\t\tvar rawStrings = [], chunksize = 0xffff;\n\t\tvar len = Math.min(uarr.length,10000);\n\n\t\t// There is a maximum stack size. We cannot call String.fromCharCode with as many arguments as we want\n\t\tfor (var i = 0; i * chunksize < len; i++){\n\t\t\trawStrings.push(String.fromCharCode.apply(null, uarr.subarray(i * chunksize, (i + 1) * chunksize)));\n\t\t}\n\n\t\tif(len<uarr.length){\n\t\t\trawStrings.push(\"T3D Ignored the last \"+(uarr.length-len)+\" bytes when generating this raw output\");\n\t\t}\n\n\t\tself.getOutput().rawString = rawStrings.join();\n\n\n\n\t\t/// Check if this is an PF or ATEX file\n\t\t// Binareis are MZ\n\t\tvar ds = new DataStream(inflatedData);\n\t\tvar first4 = ds.readCString(4);\n\n\t\t/// Do special stuff for different fcc signatures\n\t\t/// \n\t\t/// fourcc != fcc::ATEX && fourcc != fcc::ATEC && fourcc != fcc::ATEP &&\n        /// fourcc != fcc::ATET && fourcc != fcc::ATEU && fourcc != fcc::ATTX)\n\t\t/// \n\t\tif( first4 == \"ATEX\" || first4 == \"ATEC\" ||\n\t\t\tfirst4 == \"ATEP\" || first4 == \"ATET\" || \n\t\t\tfirst4 == \"ATEU\" || first4 == \"ATTX\" ){\n\n\t\t\t/// TODO: MOVE TO GW2 texture file!!\n\t\t\t/// Load file using LocalReader.\n\t\t\tself.localReader.loadTextureFile(self.settings.id,\n\t\t\t\tfunction(inflatedData, dxtType, imageWidth, imageHeigth){\n\t\t\t\t\t\n\t\t\t\t\t/// Create image using returned data.\n\t\t\t\t\tvar image = {\n\t\t\t\t\t\tdata   : new Uint8Array(inflatedData),\n\t\t\t\t\t\twidth  : imageWidth,\n\t\t\t\t\t\theight : imageHeigth\n\t\t\t\t\t};\n\n\t\t\t\t\tself.getOutput().image = image;\n\t\t\t\t\tcallback();\n\t\t\t\t}\n\t\t\t);\n\n\t\t}\n\t\telse if(first4.indexOf(\"PF\") == 0){\n\t\t\tself.getOutput().file = new GW2File(ds,0);\n\t\t\tcallback();\n\t\t}\n\t\telse{\n\t\t\tself.getOutput().file = null;\n\t\t\tcallback();\n\t\t}\n\n\t});\t\n}","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nvar RenderUtils = require(\"../util/RenderUtils\");\nvar DataRenderer = require('./DataRenderer');\n\n/**\n *\n * A renderer that generates some of the environment objects of a map.\n * \n * @class EnvironmentRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"mapFile\", a GW2File.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nfunction EnvironmentRenderer(localReader, settings, context, logger){\n\tDataRenderer.call(this, localReader, settings, context, logger);\n\n\tthis.mapFile = this.settings.mapFile;\n\n\tthis.getMat = function(tex){\n\t\treturn new THREE.MeshBasicMaterial({\n\t\t\tmap: tex,\n\t\t\tside: THREE.BackSide,\n\t\t\tfog: false,\n\t\t\tdepthWrite: false\n\t\t});\n\t};\n\n\tthis.loadTextureWithFallback = function(targetMatIndices, materialArray, filename, fallbackFilename, hazeColorAsInt){\n\t\tvar self = this;\n\t\t\n\t\tfunction writeMat(mat){\n\t\t\ttargetMatIndices.forEach(function(i){\n\t\t\t\tmaterialArray[i] = mat; \n\t\t\t});\n\t\t}\n\n\t\tfunction loadFallback(){\n\t\t\tvar mat = self.getMat(\n\t\t\t\tnew THREE.TextureLoader().load(fallbackFilename)\n\t\t\t);\n\n\t\t\twriteMat(mat);\n\t\t}\n\n\t\tfunction errorCallback(){\n\t\t\tsetTimeout(loadFallback, 1);\n\t\t}\n\n\t\tvar mat = self.getMat(\n\t\t\tRenderUtils.loadLocalTexture(\n\t\t\t\tlocalReader,\n\t\t\t\tfilename,\n\t\t\t\tnull, hazeColorAsInt,\n\t\t\t\terrorCallback )\n\t\t);\n\n\t\twriteMat(mat);\t\t\t\n\t}\n\n\tthis.getHazeColor = function(environmentChunkData){\n\t\tvar hazes = environmentChunkData && environmentChunkData.dataGlobal.haze;\n\n\t\tif(!hazes || hazes.length<=0){\n\t\t\treturn [190, 160, 60];\n\t\t}\n\t\telse{\n\t\t\treturn hazes[0].farColor;\n\t\t}\n\t};\n\n\tthis.parseLights = function(environmentChunkData){\n\t\tvar self = this;\n\n\t\t/// Set up output array\n\t\tself.getOutput().lights = [];\n\n\t\tvar lights = environmentChunkData ? environmentChunkData.dataGlobal.lighting : [{\n\t\t\tlights:[],\n\t\t\tbacklightIntensity:1.0,\n\t\t\tbacklightColor:[255,255,255]\n\t\t}];\n\n\t\tvar ambientLight;\n\n\t\t//var light = lights[0];\n\t\t//\n\t\tvar hasLight = false;\n\t\tlights.forEach(function(light, idx){\n\n\t\t\tif(hasLight)\n\t\t\t\treturn;\n\n\t\t\t/// Directional lights\n\t\t\tvar sumDirLightIntensity = 0;\n\n\t\t\t\n\t\t\tlight.lights.forEach(function(dirLightData,idx){\n\n\t\t\t\thasLight = true;\n\t\t\t\t\n\t\t\t\tvar color = new THREE.Color(\n\t\t\t\t\tdirLightData.color[2]/255.0,\n\t\t\t\t\tdirLightData.color[1]/255.0,\n\t\t\t\t\tdirLightData.color[0]/255.0\n\t\t\t\t);\n\n\t\t\t\tvar directionalLight = new THREE.DirectionalLight( color.getHex(), dirLightData.intensity );\n\t\t\t\t\n\t\t\t\tdirectionalLight.position.set(\n\t\t\t\t\t-dirLightData.direction[0],\n\t\t\t\t\tdirLightData.direction[2],\n\t\t\t\t\tdirLightData.direction[1]\n\t\t\t\t).normalize();\n\t\t\t\t\n\t\t\t\tsumDirLightIntensity += dirLightData.intensity;\n\n\t\t\t\tself.getOutput().lights.push(directionalLight);\n\n\t\t\t});// END for each directional light in light\n\n\n\t\t\t/// Add some random directional lighting if there was no, in order to se SOME depth on models\n\t\t\tif(!light.lights || light.lights.length==0){\t\t\n\n\t\t\t\tvar directions = [\n\t\t\t\t\t[0,1,0,.3],\t\t\t\t\t\n\t\t\t\t\t[1,2,1,.3],\n\t\t\t\t\t[-1,-2,-1,.3]\n\t\t\t\t];\n\n\t\t\t\tdirections.forEach(function(lightDir){\n\n\t\t\t\t\tvar color = new THREE.Color(1,1,1);\n\t\t\t\t\tvar intensity = lightDir[3];\n\t\t\t\t\tvar directionalLight = new THREE.DirectionalLight( color.getHex(), intensity );\n\t\t\t\t\t\n\t\t\t\t\tdirectionalLight.position.set(lightDir[0],lightDir[1],lightDir[2]).normalize();\n\t\t\t\t\t\n\t\t\t\t\tsumDirLightIntensity += intensity;\n\n\t\t\t\t\tself.getOutput().lights.push(directionalLight);\n\n\t\t\t\t});\n\t\t\t\t\n\t\t\t}\n\n\n\t\t\t/// Ambient light\n\t\t\t//light.backlightIntensity /= sumDirLightIntensity +light.backlightIntensity; \n\t\t\tlight.backlightIntensity =  light.backlightIntensity; \n\t\t\tvar color = new THREE.Color(\n\t\t\t\tlight.backlightIntensity * (255.0-light.backlightColor[2])/255.0,\n\t\t\t\tlight.backlightIntensity * (255.0-light.backlightColor[1])/255.0,\n\t\t\t\tlight.backlightIntensity * (255.0-light.backlightColor[0])/255.0\n\t\t\t);\n\n\t\t\tambientLight = new THREE.AmbientLight(color);\n\n\t\t})// END for each light in lighting\n\n\t\tvar ambientTotal = 0;\n\t\tif(ambientLight){\n\t\t\tambientTotal = ambientLight.color.r + ambientLight.color.g + ambientLight.color.b;\n\t\t\tthis.getOutput().lights.push(ambientLight);\n\t\t}\n\n\t\t/// Parsing done, set hasLight flag and return\n\t\tthis.getOutput().hasLight = hasLight || ambientTotal>0;\t\t\n\t};\n\n\tthis.parseSkybox = function(environmentChunkData, parameterChunkData, hazeColorAsInt){\n\n\t\t/// set up output array\n\t\tthis.getOutput().skyElements = [];\n\t\t\n\t\t/// Grab sky texture.\n\t\t/// index 0 and 1 day\n\t\t/// index 2 and 3 evening\n\t\tvar skyModeTex = this.environmentChunkData && this.environmentChunkData.dataGlobal.skyModeTex[0];\n\n\t\t/// Fallback skyboxfrom dat.\n\t\tif(!skyModeTex){\n\t\t\tskyModeTex = {\n\t\t\t\ttexPathNE:1930687,\n\t\t\t\ttexPathSW:193069,\n\t\t\t\ttexPathT:193071\n\t\t\t}\n\t\t}\n\n\t\t/// Calculate bounds\n\t\tvar bounds = parameterChunkData.rect;\n\t\tvar mapW = Math.abs( bounds.x1 -bounds.x2 );\n\t\tvar mapD = Math.abs( bounds.y1 -bounds.y2 );\n\t\tvar boundSide = Math.max( mapW, mapD );\n\n\t\tvar materialArray = [];\n\n\t\t/// Load skybox textures, fallback to hosted png files.\n\t\tthis.loadTextureWithFallback([1,4], materialArray, skyModeTex.texPathNE + 1, \"img/193068.png\", hazeColorAsInt);\n\t\tthis.loadTextureWithFallback([0,5], materialArray, skyModeTex.texPathSW + 1, \"img/193070.png\", hazeColorAsInt);\n\t\tthis.loadTextureWithFallback([2], materialArray, skyModeTex.texPathT + 1, \"img/193072.png\", hazeColorAsInt);\n\t\tmaterialArray[3] = new THREE.MeshBasicMaterial({visible:false});\n\n\n\t\t/// Create skybox geometry\n\t\tvar boxSize = 1024;\t\t\n\t\tvar skyGeometry = new THREE.BoxGeometry( boxSize, boxSize/2 , boxSize ); //Width Height Depth\n\n\t\t/// Ugly way of fixing UV maps for the skybox (I think)\n\t\tskyGeometry.faceVertexUvs[0].forEach(function(vecs, idx){\n\n\t\t\tvar face = Math.floor(idx/2);\n\n\t\t\t// PX NX\n\t\t\t// PY NY\n\t\t\t// PZ NZ\n\n\t\t\t/// PX - WEST \tNX - EAST\n\t\t\tif(face == 0 || face == 1){\n\t\t\t\tvecs.forEach(function(vec2){\n\t\t\t\t\tvec2.x = 1 - vec2.x;\t\n\t\t\t\t\tvec2.y /= 2.0;\t\n\t\t\t\t\tvec2.y += .5;\t\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t/// NZ - SOUTH \tPZ - NORTH\n\t\t\telse if(face == 5 || face == 4){\n\t\t\t\tvecs.forEach(function(vec2){\n\t\t\t\t\tvec2.y /= -2.0;\t\n\t\t\t\t\tvec2.y += .5;\t\n\t\t\t\t});\n\t\t\t}\n\n\t\t\telse{\n\t\t\t\tvecs.forEach(function(vec2){\n\t\t\t\t\tvec2.x = 1 - vec2.x;\t\n\t\t\t\t});\n\t\t\t}\n\n\t\t});\n\n\t\tskyGeometry.uvsNeedUpdate = true;\n\t\t\n\t\t/// Generate final skybox\n\t\tvar skyBox = new THREE.Mesh( skyGeometry, materialArray );\n\n\t\t/// Put horizon in camera center\n\t\tskyBox.translateY(boxSize/4);\n\t\t//skyBox.translateY( -environmentChunk.data.dataGlobal.sky.verticalOffset );\n\t\t\n\t\t/// Write to output\n\t\tthis.getOutput().skyElements.push(skyBox);\n\t};\n}\n\n\n/// DataRenderer inheritance:\nEnvironmentRenderer.prototype = Object.create(DataRenderer.prototype);\nEnvironmentRenderer.prototype.constructor = EnvironmentRenderer;\n\n/**\n * Output fileds generated:\n *\n * - *hazeColor* Array of RGBA values describing the global haze color of the map.\n * - *lights* An array of THREE.DirectionalLight and  THREE.AmbientLight objects.\n * - *hasLight* Boolean is false if no directional lights were added to \"lights\".\n * - *skyElements* A textured THREE.Mesh skybox.\n * \n * \n * @method  renderAsync\n * @async\n * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n */\nEnvironmentRenderer.prototype.renderAsync = function(callback){\n\n\tvar environmentChunkData = this.mapFile.getChunk(\"env\").data;\n\tvar parameterChunkData = this.mapFile.getChunk(\"parm\").data;\n\n\t/// Set renderer clear color from environment haze\n\tvar hazeColor = this.getHazeColor(environmentChunkData);\n\tvar hazeColorAsInt =  hazeColor[2]*256*256+hazeColor[1]*256+hazeColor[0];\n\tthis.getOutput().hazeColor = hazeColor;\n\n\t/// Add directional lights to output. Also write hasLight flag\n\tthis.parseLights(environmentChunkData);\n\n\t/// Generate skybox\n\tthis.parseSkybox(environmentChunkData, parameterChunkData, hazeColorAsInt);\n\n\t/// All parsing is synchronous, just fire callback\n\tcallback();\n};\n\t\n\nmodule.exports = EnvironmentRenderer;","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nvar DataRenderer = require('./DataRenderer');\n\n/**\n *\n * A renderer that generates meshes describing the collisions of a map.\n * \n * @class HavokRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"mapFile\", a GW2File. If \"visible\" is specified and true, the generated meshes will be textured\n * with a MeshNormalMaterial, otherwise they will not be visible.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nfunction HavokRenderer(localReader, settings, context, logger){\n\tDataRenderer.call(this, localReader, settings, context, logger);\n\n\tthis.mapFile = this.settings.mapFile;\n\n\tthis.lastP = -1;\n\tthis.seed = 1;\n\tthis.meshes = [];\n\n\t/**\n\t * TODO\n\t * @method renderModels\n\t * @param  {Function} callback         [description]\n\t * @async\n\t */\n\tthis.renderModels = function(models, title, callback){\n\t\tvar mat;\n\t\tif(this.settings && this.settings.visible){\n\t\t\tmat = new THREE.MeshNormalMaterial( { side: THREE.DoubleSide } ); \n\t\t}\n\t\telse{\n\t\t\tmat = new THREE.MeshBasicMaterial( { visible: false } );\t\t\t\n\t\t}\n\n\t\tthis.parseAllModels(models, mat, title, 200, 0, callback);\n\t}\n\n\n\t/**\n\t * TODO\n\t * @method  getCollisionsForAnimation\n\t * @param  {[type]} animation  [description]\n\t * @param  {[type]} collisions [description]\n\t * @return {[type]}            [description]\n\t */\n\tthis.getCollisionsForAnimation = function(animation, collisions){\n\t\tvar ret = [];\n\t\t\n\t\tfor (var i = 0; i < animation.collisionIndices.length; i++) {\n\t\t\tvar index = animation.collisionIndices[i];\n\t\t\tvar collision = collisions[ index ];\n\t\t\tcollision.index = index;\n\t\t\tret.push( collision );\n\t\t}\n\t\t\n\t\treturn ret;\n\t};\n\n\t/**\n\t * TODO\n\t * @method  parseAllModels description\n\t * @param  {[type]} models       [description]\n\t * @param  {[type]} mat       [description]\n\t * @param  {[type]} title     [description]\n\t * @param  {[type]} chunkSize [description]\n\t * @param  {[type]} offset    [description]\n\t * @return {[type]} callback          [description]\n\t * @async\n\t */\n\tthis.parseAllModels = function(models, mat, title, chunkSize, offset, callback){\n\t\tvar i = offset;\t\t\n\n\t\tfor(; i < offset+chunkSize && i < models.length; i++){\n\t\t\t\n\t\t\tvar p = Math.round(i*100/ models.length );\n\t\t\tif( p != this.lastP){\n\n\t\t\t\tthis.logger.log(\n\t\t\t\t\tT3D.Logger.TYPE_PROGRESS,\n\t\t\t\t\t\"Loading Collision Models (\"+title+\")\",\n\t\t\t\t\tp\n\t\t\t\t);\n\t\t\t\tthis.lastP = p;\n\t\t\t}\t\n\t\t\n\t\t\t/// Get animation object\n\t\t\tvar animation =  this.animationFromGeomIndex(\n\t\t\t\tmodels[i].geometryIndex,\n\t\t\t\tthis.geometries,\n\t\t\t\tthis.animations\n\t\t\t);\n\t\t\t\n\t\t\tvar collisions = this.getCollisionsForAnimation( animation, this.havokChunkData.collisions);\n\t\t\t\n\t\t\tfor(var j=0; j< collisions.length; j++){\n\t\t\t\tvar collision = collisions[j];\t\t\t\n\t\t \t\tthis.renderMesh( collision, models[i], mat );\n\t\t\t}\n\t\t}\n\n\t\tif(i<models.length){\n\t\t\twindow.setTimeout(\n\t\t\t\tthis.parseAllModels.bind(this, models, mat, title, chunkSize, offset+chunkSize, callback),\n\t\t\t\t10 /*time in ms to next call*/\n\t\t\t);\n\t\t}\n\t\telse{\n\t\t\tcallback();\n\t\t}\n\t}\n\n\t/**\n\t * TODO\n\t * @method  animationFromGeomIndex\n\t * @param  {[type]} propGeomIndex [description]\n\t * @param  {[type]} geometries    [description]\n\t * @param  {[type]} animations    [description]\n\t * @return {[type]}               [description]\n\t */\n\tthis.animationFromGeomIndex = function(propGeomIndex, geometries, animations){\n\t\t\n\t\t// geometries is just list of all geometries.animations[end] for now\n\t\tvar l = geometries[propGeomIndex].animations.length;\n\t\t\n\t\treturn animations[ geometries[propGeomIndex].animations[l-1] ];\n\t\t//return animations[ geometries[propGeomIndex].animations[0] ];\n\t};\n\n\t/**\n\t * TODO\n\t * @method renderMesh\n\t * @param  {[type]} collision [description]\n\t * @param  {[type]} model     [description]\n\t * @param  {[type]} mat       [description]\n\t * @return {[type]}           [description]\n\t */\n\tthis.renderMesh = function( collision, model, mat ){\n\t    \n\t    var pos = model.translate;\n\t    var rot = model.rotate;\n\t    var scale = 32 * model.scale;    \n\t    \n\t    /// Generate mesh\n\t    var mesh = this.parseHavokMesh(collision, mat);\n\t    \n\t    /// Position mesh\n\t    /// \"x\",\"float32\",\"z\",\"float32\",\"y\",\"float32\"\n\t    mesh.position.set(pos[0], -pos[2], -pos[1]);    \n\t    \n\t    /// Scale mesh\n\t    if(scale)\n\t    \tmesh.scale.set( scale, scale, scale );\n\n\t    /// Rotate mesh\n\t    if(rot){\n\t    \tmesh.rotation.order = \"ZXY\";\n\n\t    \t// [\"x\",\"float32\",\"z\",\"float32\",\"y\",\"float32\"], \n\t    \tmesh.rotation.set(rot[0], -rot[2], -rot[1]);\n\t    }\n\t    \t\n\t\t/// Add mesh to scene and collisions\n\t\tthis.getOutput().meshes.push(mesh);\n\t};\n\n\n\t/**\n\t * TODO\n\t * @method  seedRandom\n\t * @return {[type]} [description]\n\t */\n\tthis.seedRandom = function(){\n\t    var x = Math.sin(this.seed++) * 10000;\n\t    return x - Math.floor(x);\n\t};\n\n\t/**\n\t * TODO\n\t * @method  parseHavokMesh\n\t * @param  {[type]} collision [description]\n\t * @param  {[type]} mat       [description]\n\t * @return {[type]}           [description]\n\t */\n\tthis.parseHavokMesh = function(collision, mat){\n\t\t\n\t\tvar index = collision.index;\n\n\t\tif(!this.meshes[index]){\n\n\t\t\tvar geom = new THREE.Geometry();\n\t\t\t\n\t\t\t/// Pass vertices\t    \t\t\n\t\t\tfor(var i=0; i<collision.vertices.length; i++){\n\t\t\t\tvar v=collision.vertices[i];\n\t\t\t\t//\"x\",\"float32\",\"z\",\"float32\",\"y\",\"float32\"]\n\t\t\t\tgeom.vertices.push( new THREE.Vector3(v[0] , v[2] , -v[1] ) );\n\t\t\t}\t    \t\t\n\t\t\t\t\n\t\t\t/// Pass faces\n\t\t\tfor(var i=0; i<collision.indices.length; i+=3){\n\n\t\t\t\tvar f1=collision.indices[i];\n\t\t\t\tvar f2=collision.indices[i+1];\n\t\t\t\tvar f3=collision.indices[i+2];\n\n\t\t\t\tif( f1<=collision.vertices.length &&\n\t\t\t\t\tf2<=collision.vertices.length &&\n\t\t\t\t\tf3<=collision.vertices.length){\n\t\t\t\t\tgeom.faces.push( new THREE.Face3( f1, f2, f3 ) );\n\t\t\t\t}\n\t   \t\t\telse{\n\t   \t\t\t\tthis.logger.log(\n\t   \t\t\t\t\tT3D.Logger.TYPE_ERROR,\n\t   \t\t\t\t\t\"Errorus index in havok model geometry.\"\n   \t\t\t\t\t);\n\t   \t\t\t}\n\t\t\t}\n\n\t\t\t/// Prepare geometry and pass new mesh\n\t\t\tgeom.computeFaceNormals();\n\t\t\t//geom.computeVertexNormals();\n\t\t\t\n\t\t\tthis.meshes[index]= new THREE.Mesh( geom, mat ); \n\t\t\t\n\t\t\treturn this.meshes[index];\n\t\t}\n\t\telse{\n\t\t\treturn this.meshes[index].clone();\n\t\t}\n\t};\n\n};\n\n\n/// DataRenderer inheritance:\nHavokRenderer.prototype = Object.create(DataRenderer.prototype);\nHavokRenderer.prototype.constructor = HavokRenderer;\n\n/**\n * Output fileds generated:\n *\n * - *boundingBox* Array of values describing the bounding box of all collision.\n * - *meshes* An array of THREE.Mesh objects visualizing all collision in the map.\n * \n * @method  renderAsync\n * @async\n * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n */\nHavokRenderer.prototype.renderAsync = function(callback){\n\tvar self = this;\n\n\t// TODO:The design of this method pretty much requires one instance\n\t// of the class per parallel async render. Should probably fix this\n\t// at some point...\n\t\n\t/// Get required chunks\n\tthis.havokChunkData = this.mapFile.getChunk(\"havk\").data;\n\n    /// Set static bounds to the bounds of the havk models\n    this.getOutput().boundingBox = this.havokChunkData.boundsMax;\n\t\n\t/// Clear old meshes\n\tthis.meshes = [];\n\n\t/// Set up output array\n\tthis.getOutput().meshes = [];\n\n\t/// Grab model raw data from the chunk.\n\t/// Add missing scale value to obs models.\n\tvar propModels = this.havokChunkData.propModels;\n\tvar zoneModels = this.havokChunkData.zoneModels;\n\tvar obsModels = this.havokChunkData.obsModels;\n\tobsModels.forEach(function(mdl){\n\t\tmdl.scale = 1;\n\t});\n\n\t/// Store geoms and animations from the file in hte instance so we don't\n\t/// have to pass them arround too much. (fix this later)\n\tthis.geometries = this.havokChunkData.geometries;\n\tthis.animations = this.havokChunkData.animations;\t\t\n\t\n\t/// Render \"prop\", \"zone\" and \"obs\" models in that order.\n\tvar renderPropModelsCB = function(){\n\t\tself.renderModels(zoneModels, \"zone\", renderZoneModelsCB);\n\t};\n\tvar renderZoneModelsCB = function(){\n\t\tself.renderModels(obsModels, \"obs\", callback);\n\t};\n\tself.renderModels(propModels, \"prop\", renderPropModelsCB);\n\n\t\n}\n\nmodule.exports = HavokRenderer;","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nvar RenderUtils = require(\"../util/RenderUtils\");\nvar DataRenderer = require('./DataRenderer');\n\n/**\n *\n * A renderer that generates property models for a map.\n * \n * @class PropertiesRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"mapFile\", a GW2File.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nfunction PropertiesRenderer(localReader, settings, context, logger){\n\tDataRenderer.call(this, localReader, settings, context, logger);\n\tthis.mapFile = this.settings.mapFile;\n}\n\n/// DataRenderer inheritance:\nPropertiesRenderer.prototype = Object.create(DataRenderer.prototype);\nPropertiesRenderer.prototype.constructor = PropertiesRenderer;\n\n/**\n * Renders all property meshes in a GW2 map described by the map's PROP chunk.\n * Output fileds generated:\n *\n * - *meshes* An array of THREE.Mesh objects visualizing all property models refered by this map.\n * \n * @method  renderAsync\n * @async\n * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n */\nPropertiesRenderer.prototype.renderAsync = function(callback){\n\tvar self = this;\n\n\tself.getOutput().meshes = [];\n\n\tvar propertiesChunkData =  this.mapFile.getChunk(\"prp2\").data;\n\n\tif(!propertiesChunkData){\n\t\trenderCallback();\n\t\treturn;\n\t}\n\n\tvar props = propertiesChunkData.propArray;\n\tvar animProps =propertiesChunkData.propAnimArray;\n\tvar instanceProps = propertiesChunkData.propInstanceArray;\n\tvar metaProps = propertiesChunkData.propMetaArray;\n\n\t/// Concat all prop types\n\tprops = props\n\t\t.concat(animProps)\n\t\t.concat(instanceProps)\n\t\t.concat(metaProps);\n\n\t/// Create mesh cache\n\tself.meshCache = {};\n\tself.textureCache = {};\n\n\t// For now, we'll do all load in serial\n\t// TODO: load unique meshes and textures in parallell (asynch), then render!\n\tvar lastPct = -1;\n\n\tvar renderIndex = function(idx){\n\n\t\tif(idx>= props.length){\n\n\t\t\t/// Empty mesh cache\n\t\t\tself.meshCache = {};\n\t\t\tself.textureCache = {};\n\t\t\tcallback();\n\t\t\treturn;\n\t\t}\n\n\t\tvar pct = Math.round(1000.0*idx / props.length);\n\t\tpct/=10.0;\n\t\t\n\t\t/// Log progress\n\t\tif(lastPct!=pct){\n\t\t\tvar pctStr = pct +\n\t\t\t\t( pct.toString().indexOf(\".\")<0 ? \".0\":\"\" );\n\n\t\t\tself.logger.log(\n\t\t\t\tT3D.Logger.TYPE_PROGRESS,\n\t\t\t\t\"Loading 3D Models (Props)\", pctStr\n\t\t\t);\n\t\t\tlastPct = pct;\n\t\t}\n\n\t\t/// Read prop at index.\n\t\tvar prop = props[idx];\t\t\t\t\t\t\t\t\n\n\t    /// Adds a single mesh to a group.\n\t\tvar addMeshToLOD = function(mesh, groups, lod, prop, needsClone){\n\n\t\t\t/// Read lod distance before overwriting mesh variable\n\t\t    var lodDist = prop.lod2 != 0 ? prop.lod2 : mesh.lodOverride[1];\n\n\t\t    /// Read flags before overwriting mesh variable\n\t    \tvar flags = mesh.flags;\n\n\t    \t/// Mesh flags are 0 1 4\n\t    \t/// For now, use flag 0 as the default level of detail\n\t    \tif(flags==0)\n\t    \t\tlodDist=0;\n\t    \t\n\t    \t/// Create new empty mesh if needed\n\t    \tif(needsClone){\n\t    \t\tmesh = new THREE.Mesh( mesh.geometry, mesh.material );\n\t    \t}\n\n\t    \tmesh.updateMatrix();\n\t\t\tmesh.matrixAutoUpdate = false;\n\n\t    \t// Find group for this LOD distance\n\t    \tif(groups[lodDist]){\n\t    \t\tgroups[lodDist].add(mesh);\n\t    \t}\n\t    \t// Or create LOD group and add to a level of detail\n\t    \t// WIP, needs some testing!\n\t    \telse{\n\t    \t\tvar group = new THREE.Group();\n\t    \t\tgroup.updateMatrix();\n\t\t\t\tgroup.matrixAutoUpdate = false;\n\t    \t\tgroup.add(mesh);\n\t    \t\tgroups[lodDist] = group;\n\t    \t\tlod.addLevel(group,lodDist);\n\t    \t}\n\n\t    \treturn lodDist;\n\t    }\n\n\t    /// Adds array of meshes to the scene, also adds transform clones\n\t\tvar addMeshesToScene = function(meshArray, needsClone, boundingSphere){\n\t\t\t\n\t\t    ///Add original \n\n\t\t    /// Make LOD object and an array of groups for each LOD level\n\t\t    var groups = {};\n\t\t    var lod = new THREE.LOD();\n\n\t\t    /// Each mesh is added to a group corresponding to its LOD distane\n\t\t    var maxDist = 0;\n\t\t    meshArray.forEach(function(mesh){\n\t\t    \tmaxDist = Math.max( maxDist, addMeshToLOD(mesh,groups,lod,prop,needsClone) );\n\t    \t});\n\n\t    \t/// Add invisible level (the raycaster crashes on lod without any levels)\n\t    \tlod.addLevel(new THREE.Group(),100000);\n\n\t\t    /// Set position, scale and rotation of the LOD object\n\t\t\tif(prop.rotation){\n\t\t    \tlod.rotation.order = \"ZXY\";\n\t\t    \t//[\"x\",\"float32\",\"z\",\"float32\",\"y\",\"float32\"],\n\t\t    \tlod.rotation.set(prop.rotation[0], -prop.rotation[2], -prop.rotation[1]);\n\t\t    }\n\t\t    lod.scale.set( prop.scale, prop.scale, prop.scale );\n\t\t    lod.position.set(prop.position[0], -prop.position[2], -prop.position[1]);\n\t\t   \t\n\n\t\t   \tlod.boundingSphereRadius = ( boundingSphere && boundingSphere.radius ? boundingSphere.radius : 1.0) * prop.scale;\n\n\t\t    lod.updateMatrix();\n\t\t    lod.matrixAutoUpdate = false;\n\n\t\t    /// Show highest level always\n\t\t    //lod.update(lod);\n\n\t    \t//Add LOD containing mesh instances to scene\n\t    \tself.getOutput().meshes.push(lod);\n\t    \t\t\t\t    \n\t\t    // Add one copy per transform, needs to be within it's own LOD\n\t\t    if(prop.transforms){\n\n\t\t    \tprop.transforms.forEach(function(transform){\n\t\t    \t\t\n\t\t    \t\t/// Make LOD object and an array of groups for each LOD level\n\t\t    \t\tvar groups = {};\n\t\t    \t\tvar lod = new THREE.LOD();\n\n\t\t    \t\t/// Each mesh is added to a group corresponding to its LOD distane\n\t\t    \t\tvar maxDist = 0;\n\t\t\t    \tmeshArray.forEach(function(mesh){\n\t\t\t    \t\tmaxDist = Math.max( maxDist, addMeshToLOD(mesh,groups,lod,prop,true) );\n\t\t\t    \t});\n\n\t\t\t    \t/// Add invisible level\n\t    \t\t\t//lod.addLevel(new THREE.Group(),10000);\n\n\t\t\t    \t/// Set position, scale and rotation of the LOD object\n\t\t\t\t\tif(transform.rotation){\n\t\t\t\t    \tlod.rotation.order = \"ZXY\";\n\t\t\t\t    \tlod.rotation.set(transform.rotation[0], -transform.rotation[2], -transform.rotation[1]);\n\t\t\t\t    }\n\t\t\t\t    lod.scale.set( transform.scale, transform.scale, transform.scale );\n\t\t\t\t    lod.position.set(transform.position[0], -transform.position[2], -transform.position[1]);\n\n\t\t\t\t\tlod.updateMatrix();\n\t\t    \t\tlod.matrixAutoUpdate = false;\n\n\t\t    \t\tlod.boundingSphereRadius = ( boundingSphere && boundingSphere.radius ? boundingSphere.radius : 1.0) * prop.scale;\n\n\t\t\t\t\t/// Show highest level always\n\t\t    \t\tlod.update(lod);\n\n\t\t\t    \t/// Add LOD containing mesh instances to scenerender: function(propertiesChunkHeader, map, localReader, renderCallback){\n\t\t\t    \tself.getOutput().meshes.push(lod);\n\t\t\t    });\n\t\t    }\n\t\t}\n\n\t\t/// Get meshes\n\t\tvar showUnmaterialed = false;\n\t\tRenderUtils.getMeshesForFilename(prop.filename, prop.color, self.localReader, self.meshCache, self.textureCache, showUnmaterialed,\n\t\t\tfunction(meshes, isCached, boundingSphere){\n\t\t\t\n\t\t\t\tif(meshes){\n\t\t\t\t\taddMeshesToScene(meshes, isCached, boundingSphere);\n\t\t\t\t}\n\n\t\t\t\t/// Render next prop\n\t\t\t\trenderIndex(idx+1);\n\t\t\t}\n\t\t);\n\n\t\t\n\n\t};\n\n\t/// Start serial loading and redering. (to allow re-using meshes and textures)\n\trenderIndex(0);\n}\n\n\n/**\n * TODO: write description. Used for export feature\n * @method getFileIdsAsync\n * @param  {Function} callback [description]\n * @return {[type]}            [description]\n */\nPropertiesRenderer.prototype.getFileIdsAsync = function(callback){\n\tvar fileIds = [];\n\n\tvar propertiesChunkData =  this.mapFile.getChunk(\"prp2\").data;\n\n\tvar props = propertiesChunkData.propArray;\n\tvar animProps = propertiesChunkData.propAnimArray;\n\tvar instanceProps = propertiesChunkData.propInstanceArray;\n\tvar metaProps = propertiesChunkData.propMetaArray;\n\n\tprops = props\n\t\t.concat(animProps)\n\t\t.concat(instanceProps)\n\t\t.concat(metaProps);\n\n\tvar getIdsForProp = function(idx){\n\n\t\tif(idx>=props.length){\n\t\t\tcallback(fileIds);\n\t\t\treturn;\n\t\t}\n\n\t\tif(idx%100==0){\n\n\t\t\tthis.logger.log(\n\t\t\t\tT3D.Logger.TYPE_MESSAGE,\n\t\t\t\t\"getting ids for entry\",idx,\"of\",props.length\n\t\t\t);\n\t\t}\n\n\t\tvar prop = props[idx];\n\t\tUtils.getFilesUsedByModel(\n\t\t\tprop.filename,\n\t\t\tlocalReader,\n\t\t\tfunction(propFileIds){\n\t\t\t\tfileIds = fileIds.concat(propFileIds);\n\t\t\t\tgetIdsForProp(idx+1);\n\t\t\t}\n\t\t);\n\n\t};\n\n\tgetIdsForProp(0);\n};\n\nmodule.exports = PropertiesRenderer;","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nvar RenderUtils = require(\"../util/RenderUtils\");\nvar DataRenderer = require('./DataRenderer');\n\n/**\n *\n * A renderer that generates meshes for a single model file.\n * \n * @class SingleModelRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"id\" the base ID or file ID of the model to generate meshes for.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nfunction SingleModelRenderer(localReader, settings, context, logger){\n\tDataRenderer.call(this, localReader, settings, context, logger);\n}\n\n\n/// DataRenderer inheritance:\nSingleModelRenderer.prototype = Object.create(DataRenderer.prototype);\nSingleModelRenderer.prototype.constructor = SingleModelRenderer;\n\n\n/**\n * Output fileds generated:\n *\n * - *meshes* An array of THREE.Mesh objects visualizing this model file.\n * \n * @method  renderAsync\n * @async\n * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n */\nSingleModelRenderer.prototype.renderAsync = function(callback){\n\tvar self = this;\n\n\t/// Get file id\n\tvar fileId = this.settings.id;\n\tvar showUnmaterialed = true;\n\n\t/// Load the model file\n\tvar meshCache = {};\n\tvar textureCache = {};\n\n\t/// Set up output array\n\tself.getOutput().meshes = [];\n\n\tRenderUtils.getMeshesForFilename(fileId, 0x00ff00, self.localReader, meshCache, textureCache, showUnmaterialed,\n\t\tfunction(meshes, isCached, boundingSphere){\n\t\t\n\t\t\tif(meshes){\n\t\t\t\tmeshes.forEach(function(mesh){\n\t\t\t\t\tmesh.boundingSphere = boundingSphere;\n\t\t\t\t\tself.getOutput().meshes.push(mesh);\n\t\t\t\t});\n\t\t\t}\n\n\t\t\t/// Fire callback after all meshes have been added.\n\t\t\tmeshCache = {};\n\t\t\tcallback();\n\t\t}\n\t);\n\n}\n\nmodule.exports = SingleModelRenderer;","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nvar DataRenderer = require('./DataRenderer');\n\n/**\n *\n * A renderer that generates a list of readable strings from a \"strs\" file.\n * \n * @class StringRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"id\" the base ID or file ID of the string file to read strings from.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nfunction StringRenderer(localReader, settings, context, logger){\n\tDataRenderer.call(this, localReader, settings, context, logger);\n}\n\n\n/// DataRenderer inheritance:\nStringRenderer.prototype = Object.create(DataRenderer.prototype);\nStringRenderer.prototype.constructor = StringRenderer;\n\n/**\n * Output fileds generated:\n *\n * - *strings* An array of objects. Each object has a \"recid\"-property specifing on what index within the file\n * a given string was found, and a \"value\"-property specigying the string value.\n *\n * - *language* An integer specifing the language of the loaded file.\n * \n * @method  renderAsync\n * @async\n * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n */\nStringRenderer.prototype.renderAsync = function(callback){\n\tvar self = this;\n\n\t/// Get file id\n\tvar fileId = this.settings.id;\n\tvar showUnmaterialed = true;\n\n\t/// Load the string file\n\n\t/// Set up output array\n\tthis.getOutput().strings = [];\n\n\tthis.localReader.loadFile(this.settings.id, function(inflatedData){\n\t\tvar ds = new DataStream(inflatedData);\n\t\tvar end = ds.byteLength -2;\n\n    \t/// skip past fcc\n    \tds.seek(4);\n\n    \tvar entryHeaderDef =\n\t\t[\n\t\t\t\"size\", \"uint16\",\n\t\t\t\"decryptionOffset\", \"uint16\",\n\t\t\t\"bitsPerSymbol\", \"uint16\"\n\t\t];\n\n\t\tvar entryIndex = 0;\n\n    \twhile ( end - ds.position > 6) {\n\t        \t        \n\t        var entry = ds.readStruct(entryHeaderDef);\n\t        entry.size -= 6;\n\n\t        if(entry.size > 0){\n\n\n\t        \tvar isEncrypted = entry.decryptionOffset != 0 || entry.bitsPerSymbol != 0x10;\n\n\t        \t/// UTF-16\n\t        \tif( !isEncrypted ){\n\t        \t\tvar value =  ds.readUCS2String(entry.size/2);\n\t        \t\tself.getOutput().strings.push({\n\t        \t\t\tvalue:value,\n\t        \t\t\trecid:entryIndex\n\t        \t\t});\n\t        \t}\n\n\t        \t/// Other... ignored\n\t        \telse{\n\n\t        \t}\n\t        }\n\n\t        entryIndex++;        \n\t    }\n\n\n\t\tds.seek(ds.byteLength - 2);\n    \tself.getOutput().language = ds.readUint16();\n\t\tcallback();\n\t});\n\n\n}\n\nmodule.exports = StringRenderer;","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nvar RenderUtils = require(\"../util/RenderUtils\");\nvar DataRenderer = require('./DataRenderer');\nvar GW2File = require(\"../format/file/GW2File.js\"); \n\nvar TerrainShader = require(\"../util/TerrainShader.js\");\n\n/**\n *\n * A renderer that generates the meshes for the terrain of a map.\n *\n * \n * Requires a context previously populated by a \n * {{#crossLink \"EnvironmentRenderer\"}}{{/crossLink}}.\n * \n * @class TerrainRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"mapFile\", a GW2File.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nfunction TerrainRenderer(localReader, mapFile, settings, context, logger){\n\tDataRenderer.call(this, localReader, mapFile, settings, context, logger);\n\tthis.mapFile = this.settings.mapFile;\n\n\tthis.drawWater = function(rect){\n\t\t\n\t\t/// Add Water\n\t\tvar material = material || new THREE.MeshBasicMaterial(\n\t\t\t{\n\t\t\t\tcolor: 0x5bb1e8,\n\t\t\t\twireframe:false,\n\t\t\t \topacity: 0.35\n\t\t\t}\n\t\t);\n\n\t\tmaterial.transparent = true;\n\t\treturn RenderUtils.renderRect(rect, 0, material);\n\t}\n\n\tthis.parseNumChunks = function(terrainData){\n\t\tterrainData.numChunksD_1 = Math.sqrt(\n\t\t\tterrainData.dims[0] *\n\t\t\tterrainData.chunkArray.length /\n\t\t\tterrainData.dims[1]\n\t\t);\n\t\tterrainData.numChunksD_2 =\n\t\t\tterrainData.chunkArray.length / terrainData.numChunksD_1;\n\t}\n\n\tthis.loadPagedImageCallback = function(callback, infaltedBuffer){\n\t\tvar self = this;\n\n\t\t// Prep output array\n\t\tself.getOutput().terrainTiles = [];\n\n\t\tvar pimgDS = new DataStream(infaltedBuffer);\n\t\tvar pimgFile = new GW2File(pimgDS,0);\n\t\tvar pimgTableDataChunk = pimgFile.getChunk(\"pgtb\");\n\t\tvar pimgData = pimgTableDataChunk && pimgTableDataChunk.data;\n\n\t\tthis.mapRect = null;\n\n\t\t/// Fetch chunks\n\t\tvar terrainData = this.mapFile.getChunk(\"trn\").data;\n\t\tvar parameterData = this.mapFile.getChunk(\"parm\").data;\n\n\t\t/// Read settings\n\t\tvar maxAnisotropy = this.settings.anisotropy ? this.settings.anisotropy : 1;\n\n\t\tvar chunks = [];\t\n\t\tvar chunkW = 35;\n\n\t\t/// Calculate numChunksD_1 and _2\n\t\tthis.parseNumChunks(terrainData);\n\n\t\tvar xChunks = terrainData.numChunksD_1;\n\t\tvar yChunks = terrainData.numChunksD_2;\n\n\t\tvar allMaterials = terrainData.materials.materials;\n\t\tvar allTextures = terrainData.materials.texFileArray;\n\n\t\t//Total map dx and dy\n\t\t/*\n\t\told parameter data definition:\n\t\t\"x1\", \"float32\",\n\t\t\"y1\", \"float32\",\n\t\t\"x2\", \"float32\",\n\t\t\"y2\", \"float32\"\n\t\t*/\n\t\t//var dx = parameterData.rect.x2 - parameterData.rect.x1;\n\t\t//var dy = parameterData.rect.y2 - parameterData.rect.y1;\n\t\tvar dx = parameterData.rect[2] - parameterData.rect[0];\n\t\tvar dy = parameterData.rect[3] - parameterData.rect[1];\n\n\t\t//Each chunk dx and dy\n\t\tvar cdx = dx/terrainData.numChunksD_1 * 1;//  35/33;\n\t\tvar cdy =dy/terrainData.numChunksD_2 * 1;//35/33;\n\t\tvar n=0;\n\t\tvar allMats = [];\n\t\tvar customMaterial = new THREE.MeshLambertMaterial({side: THREE.DoubleSide, color:0x666666, flatShading: true}); \n\t\tvar texMats = {};\n\n\t\t/// Load textures from PIMG and inject as material maps (textures)\n\t\tvar chunkTextures={};\n\t\t\n\t\t/// Load textures\n\t\tif(pimgData){\n\t\t\tvar strippedPages = pimgData.strippedPages;\n\n\t\t\t///Only use layer 0\n\t\t\tstrippedPages.forEach(function(page){\n\t\t\t\t\n\t\t\t\t/// Only load layer 0 and 1\n\t\t\t\tif(page.layer<=1){\n\t\t\t\t\tvar filename = page.filename;\n\t\t\t\t\tvar color = page.solidColor;\n\t\t\t\t\tvar coord = page.coord;\n\n\t\t\t\t\tvar matName = coord[0]+\",\"+coord[1];\n\t\t\t\t\tif(page.layer == 1)\n\t\t\t\t\t\tmatName+=\"-2\";\n\n\n\t\t\t\t\t/// Add texture to list, note that coord name is used, not actual file name\n\t\t\t\t\tif(!chunkTextures[matName]){\n\n\t\t\t\t\t\t/// Load local texture, here we use file name!\n\t\t\t\t\t\tvar chunkTex = RenderUtils.loadLocalTexture(self.localReader, filename);\n\n\t\t\t\t\t\tif(chunkTex){\n\t\t\t\t\t\t\t/// Set repeat, antistropy and repeat Y\n\t\t\t\t\t\t\tchunkTex.anisotropy = maxAnisotropy;\n\t\t\t\t\t\t\tchunkTex.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\t\t\tchunkTex.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t///...But store in coord name\n\t\t\t\t\t\tchunkTextures[matName] = chunkTex;\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t});/// end for each stripped page in pimgData\n\t\t}\n\t\t\n\t\t\n\t\t\t\t\n\t\t/// Render Each chunk\n\t\t/// We'll make this async in order for the screen to be able to update\n\n\t\tvar renderChunk = function(cx,cy){\n\t\t\tvar chunkIndex = cy*xChunks + cx;\n\n\t\t\tvar pageX = Math.floor(cx/4);\n\t\t\tvar pageY = Math.floor(cy/4);\n\n\t\t\t//TODO: Terrain texture LOD ?\n\t\t\tvar chunkTextureIndices = allMaterials[chunkIndex].loResMaterial.texIndexArray;\n\t\t\tvar matFileName = allMaterials[chunkIndex].loResMaterial.materialFile;\t\t\n\t\t\t//var chunkTextureIndices = allMaterials[chunkIndex].hiResMaterial.texIndexArray;\n\t\t\t//var matFileName = allMaterials[chunkIndex].hiResMaterial.materialFile;\n\n\n\t\t\tvar chunkData = terrainData.chunkArray[chunkIndex];\n\n\t\t\tvar mainTex = allTextures[chunkTextureIndices[0]];\n\t\t\tvar mat = customMaterial;\n\n\t\t\t/// TODO: just tick invert y = false...?\n\t\t\tvar pageOffetX = (cx % 4)/4.0;\n\t\t\tvar pageOffetY = 0.75 - (cy % 4)/4.0;\n\n\t\t\t//offset 0 -> 0.75\n\t\t\t\n\t\t\t\n\t\t\t//Make sure we have shared textures\n\n\t\t\t/// Load and store all tiled textures\n\t\t\tvar fileNames = [];\n\t\t\tfor(var gi=0;gi<chunkTextureIndices.length/2;gi++){\n\t\t\t\tvar textureFileName = allTextures[chunkTextureIndices[gi]].filename;\n\n\t\t\t\tfileNames.push(textureFileName);\n\t\t\t\t\n\t\t\t\t/// If the texture is not already loaded, read it from the .dat!\n\t\t\t\tif(!chunkTextures[textureFileName]){\n\n\t\t\t\t\t/// Load local texture\n\t\t\t\t\tvar chunkTex = RenderUtils.loadLocalTexture(self.localReader, textureFileName);\n\n\t\t\t\t\tif(chunkTex){\n\t\t\t\t\t\t/// Set repeat, antistropy and repeat Y\n\t\t\t\t\t\tchunkTex.anisotropy = maxAnisotropy;\n\t\t\t\t\t\tchunkTex.wrapS = THREE.RepeatWrapping;\n\t\t\t\t\t\tchunkTex.wrapT = THREE.RepeatWrapping;\n\t\t\t\t\t}\n\n\t\t\t\t\tchunkTextures[textureFileName] = chunkTex;\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}/// End for each chunkTextureIndices\n\n\t\t\t/// Create Composite texture material, refering the shared textures\n\t\t\tvar pageTexName=  pageX+\",\"+pageY;\t\t\t\t\n\t\t\tvar pageTexName2=  pageX+\",\"+pageY+\"-2\";\t\t\t\t\n\n\n\t\t\t/// TODO USe mapData (Chunk: env -> haze)\n\t\t\t//var fog = SceneUtils.getScene().fog;\n\t\t\tvar fog = {\n\t\t\t\tcolor: {r:1,g:1,b:1},\n\t\t\t\tnear: 0,\n\t\t\t\tfar: 0\n\t\t\t}\n\n\t\t\t/// Get haze color from environment rednerer\n\t\t\tvar envOutput = self.getOutput(T3D.EnvironmentRenderer);\n\t\t\tif(envOutput.hazeColor){\n\t\t\t\tfog.color.r  = envOutput.hazeColor[2]/255.0;\n\t\t\t\tfog.color.g  = envOutput.hazeColor[1]/255.0;\n\t\t\t\tfog.color.b  = envOutput.hazeColor[0]/255.0;\n\t\t\t}\n\t\t\t\n\t\t\tvar uniforms = THREE.UniformsUtils.merge([\n\t    \t\tTHREE.UniformsLib['lights'],\n\t\t\t]);\n\n\t\t\t/// TODO: READ FROM VO, don't default to hard coded scale\n\t\t\tuniforms.uvScale = { type: \"v2\", value: new THREE.Vector2( 8.0, 8.0 ) };\n\t\t\tuniforms.offset = { type: \"v2\", value: new THREE.Vector2( pageOffetX, pageOffetY) };\n\n\t\t\tuniforms.texturePicker = {type: \"t\", value: chunkTextures[pageTexName]};\n\t\t\tuniforms.texturePicker2 = {type: \"t\", value: chunkTextures[pageTexName2]};\n\n\t\t\tuniforms.texture1 = { type: \"t\", value: chunkTextures[fileNames[0]]};\n\t\t\tuniforms.texture2 = { type: \"t\", value: chunkTextures[fileNames[1]]};\n\t\t\tuniforms.texture3 = { type: \"t\", value: chunkTextures[fileNames[2]]};\n\t\t\tuniforms.texture4 = { type: \"t\", value: chunkTextures[fileNames[3]]};\n\t\t\t\n\t\t\t\n\t\t\tmat = new THREE.ShaderMaterial( {\n\t\t\t\tuniforms: uniforms,\n\t\t\t\tfragmentShader: TerrainShader.getFragmentShader(),\n\t\t\t\tvertexShader: TerrainShader.getVertexShader()\n\t\t\t} );\n\n\t\t\t///Store referenceto each material\n\t\t\tallMats.push(mat);\n\n\t\t\t\n\t\t\t/// -1 for faces -> vertices , -2 for ignoring outer faces\n\t\t\tvar chunkGeo =  new THREE.PlaneBufferGeometry ( cdx, cdy, chunkW-3, chunkW-3);\n\n\t\t\tvar cn = 0;\n\n\t\t\t///Render chunk\n\n\t\t\t/// Each chunk vertex\n\t\t\tfor(var y=0; y<chunkW; y++){\n\n\t\t\t\tfor(var x=0; x<chunkW; x++){\n\t\t\t\n\t\t\t\t\tif(  x != 0 && x !=chunkW-1 && y!=0 && y !=chunkW-1 )\n\t\t\t\t\t{\n\t\t\t\t\t\tchunkGeo.attributes.position.array[cn*3+2] = terrainData.heightMapArray[n];\n\t\t\t\t\t\tcn++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tn++;\t\t\t\t\t\n\t\t\t\t}\n\t\t\t} // End each chunk vertex\n\n\t\t\t\n\t\t\t/// Flip the plane to fit wonky THREE js world axes\n\t\t\tvar mS = (new THREE.Matrix4()).identity();\n\t\t\tmS.elements[5] = -1;\n\t\t\tchunkGeo.applyMatrix(mS);\n\n\t\t\t/// Compute face normals for lighting, not used when textured\n\t\t\tchunkGeo.computeFaceNormals();\n\t\t\t//chunkGeo.computeVertexNormals();\n\n\n\t\t\t/// Build chunk mesh!\n\t\t\tvar chunk;\n\t\t\tchunk = new THREE.Mesh(\tchunkGeo , customMaterial );\n\t\t\tif(mat.length){\n\t\t\t\tchunk = THREE.SceneUtils.createMultiMaterialObject( chunkGeo, mat );\n\t\t\t}\n\t\t\telse{\n\t\t\t\tchunk = new THREE.Mesh(\tchunkGeo , mat );\t\n\t\t\t}\t\n\n\n\t\t\t///Move and rotate Mesh to fit in place\n\t\t\tchunk.rotation.set(Math.PI/2,0,0);\n\t\t\t\n\t\t\t/// Last term is the new one: -cdx*(2/35)\n\t\t\tvar globalOffsetX = parameterData.rect[0] + cdx/2;\n\t\t\tvar chunkOffsetX = cx * cdx;\n\n\t\t\tchunk.position.x = globalOffsetX + chunkOffsetX;\n\n\t\t\t///Adjust for odd / even number of chunks\n\t\t\tif(terrainData.numChunksD_2 % 2 == 0){\n\t\t\t\t\n\t\t\t\t/// Last term is the new one: -cdx*(2/35)\n\t\t\t\tvar globalOffsetY = parameterData.rect[1] + cdy/2 -0;// -cdy*(1/35);\n\t\t\t\tvar chunkOffsetY = cy * cdy * 1;//33/35;\n\n\t\t\t\tchunk.position.z =  chunkOffsetY + globalOffsetY;\n\t\t\t}\n\t\t\telse{\n\n\t\t\t\tvar globalOffsetY =  parameterData.rect[1] - cdy/2 + 0; //cdy*(1/35);\n\t\t\t\tvar chunkOffsetY = cy * cdy * 1;//33/35;\n\n\t\t\t\tchunk.position.z = globalOffsetY +  chunkOffsetY;\t\n\t\t\t}\n\n\n\t\t\tvar px = chunk.position.x;\n\t\t\tvar py = chunk.position.z;\n\n\n\t\t\tif(!self.mapRect){\n\t\t\t\tself.mapRect = {\n\t\t\t\t\tx1:px-cdx/2, x2:px+cdx/2,\n\t\t\t\t\ty1:py-cdy/2, y2:py+cdy/2 };\n\t\t\t}\n\t\t\t\n\t\t\tself.mapRect.x1 = Math.min(self.mapRect.x1, px -cdx/2);\n\t\t\tself.mapRect.x2 = Math.max(self.mapRect.x2, px +cdx/2);\n\n\t\t\tself.mapRect.y1 = Math.min(self.mapRect.y1, py -cdy/2);\n\t\t\tself.mapRect.y2 = Math.max(self.mapRect.y2, py +cdy/2);\n\t\t\t\n\t\t\tchunk.updateMatrix();\n\t\t\tchunk.updateMatrixWorld ();\n\n\t\t\t/// Add to list of stuff to render\n\t\t\t/// TODO: Perhaps use some kind of props for each entry instead?\n\t\t\tself.getOutput().terrainTiles.push( chunk );\t\t\n\n\t\t} /// End render chunk function\n\n\n\t\tvar stepChunk = function(cx,cy){\n\t\t\tif(cx>=xChunks){\n\t\t\t\tcx = 0;\n\t\t\t\tcy++;\n\t\t\t}\n\n\t\t\tif(cy>=yChunks){\n\n\t\t\t\t/// Draw water surface using map bounds\t\t\t\t\n\t\t\t\tself.getOutput().water = self.drawWater(self.mapRect);\n\n\t\t\t\t/// Set bounds in output VO\n\t\t\t\tself.getOutput().bounds = self.mapRect;\n\n\t\t\t\t/// Fire call back, we're done rendering.\n\t\t\t\tcallback();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar pct =  Math.floor( 100*(cy * xChunks + cx) /( xChunks * yChunks ) );\n\n\t\t\tself.logger.log(T3D.Logger.TYPE_PROGRESS,\"Loading Terrain\", pct);\n\n\t\t\trenderChunk(cx,cy);\n\t\t\tsetTimeout(stepChunk,1,cx+1,cy);\n\t\t}\n\n\t\tstepChunk(0,0);\n\t};\n}\n\n\n/// DataRenderer inheritance:\nTerrainRenderer.prototype = Object.create(DataRenderer.prototype);\nTerrainRenderer.prototype.constructor = TerrainRenderer;\n\n/**\n * Output fileds generated:\n * \n * - *terrainTiles* An array of THREE.Mesh objects visualizing terrain of the map.\n * \n * - *water* A THREE.Mesh object visualizing the bounds of the map.\n * \n * - *bounds* An object wiht x1, x2, y1, and y2 properties specifying the bounds of the map.\n * \n * @method  renderAsync\n * @async\n * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n */\nTerrainRenderer.prototype.renderAsync = function(callback){\n\t\n\t/// Load all paged Images, requires inflation of other pack files!\n\tvar pagedImageId =  this.mapFile.getChunk(\"trn\").data.materials.pagedImage;\n\tthis.localReader.loadFile(pagedImageId,this.loadPagedImageCallback.bind(this, callback));\n}\n\n/**\n * TODO: write description. Used for export feature\n * @method getFileIdsAsync\n * @param  {Function} callback [description]\n * @return {[type]}            [description]\n */\nTerrainRenderer.prototype.getFileIdsAsync = function(callback){\n\n\tvar terrainChunk = this.mapFile.getChunk(\"trn\");\n\tvar pimgTableDataChunk = this.mapFile.getChunk(\"pimg\");\n\tvar fileIds = [];\n\n\t/// ------------ SPLASH TEXTURES ------------\n\tvar pimgData = pimgTableDataChunk && pimgTableDataChunk.data;\n\tvar strippedPages = pimgData.strippedPages;\n\t\n\t///Only use layer 0\n\tstrippedPages.forEach(function(page){\n\t\t\t\n\t\t/// Only load layer 0 and 1\n\t\tif(page.layer<=1 && page.filename>0){\n\t\t\tfileIds.push( page.filename );\n\t\t}\n\t});\n\t/// ------------ END SPLASH TEXTURES ------------\n\n\n\n\t/// ------------ TILED IMAGES ------------\n\tvar terrainData = terrainChunk.data;\n\tvar allTextures = terrainData.materials.texFileArray;\n\tallTextures.forEach(function(texture){\n\t\tif(texture.filename>0)\n\t\t\tfileIds.push(texture.filename);\n\t})\n\t/// ------------ END TILED IMAGES ------------\n\n\n\n\treturn fileIds;\n};\n\nmodule.exports = TerrainRenderer;","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nvar RenderUtils = require(\"../util/RenderUtils\");\nvar DataRenderer = require('./DataRenderer');\n\n/**\n *\n * A renderer that generates zone models for a map.\n * \n * @class ZoneRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"mapFile\", a GW2File.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nfunction ZoneRenderer(localReader, settings, context, logger){\n\tDataRenderer.call(this, localReader, settings, context, logger);\n\tthis.mapFile = this.settings.mapFile;\n\n\t/**\n\t * TODO\n\t * @method  renderZone\n\t * @param  {[type]} zone               [description]\n\t * @param  {[type]} zoneDefs           [description]\n\t * @param  {[type]} mapRect            [description]\n\t * @param  {[type]} renderZoneCallback [description]\n\t * @return {[type]}                    [description]\n\t */\n\tthis.renderZone = function(zone, zoneDefs, mapRect, renderZoneCallback){\n\t\tvar self = this;\n\n\t\t/// Get Zone Definition\n\t\tvar zoneDef = null;\n\t\tzoneDefs.forEach(function(zd){\n\t\t\tif(!zoneDef && zd.token == zone.defToken)\n\t\t\t\tzoneDef = zd;\n\t\t});\n\n\t\t/// Create array of all models to add:\n\t\tvar models = [];\n\t\tvar modelGroups = this.getModelGroups(zone, zoneDef, mapRect);\n\n\t\t/// Create empty mesh cache\n\t\tself.meshCache = {};\n\t\tself.textureCache = {};\n\n\t\t/*\n\t\t * ---Keeping this out of the doc for now---\n\t\t * Steps trough each model and renders it to the scene, allowing for efficient caching.\n\t\t * @param  {Number} i - Current index within the models array\n\t\t */\n\t\t//var lastPct = -1;\n\t\tvar groupKeys = Object.keys(modelGroups);\n\t\tfunction stepModels(i){\n\n\t\t\t/*var pct = Math.round(100.0*i / groupKeys.length);\n\t\t\tif(lastPct!=pct){\n\t\t\t\tconsole.log(\"Rendering ZONE models \"+pct);\n\t\t\t\tlastPct = pct;\n\t\t\t}*/\n\n\t\t\tif(i>=groupKeys.length){\n\n\t\t\t\t/// Empty mesh cache\n\t\t\t\tself.meshCache = {};\n\t\t\t\tself.textureCache = {};\n\n\t\t\t\t/// Tell caller this zone is done loading\n\t\t\t\trenderZoneCallback();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/// Read model at index\n\t\t\t/// var model = models[i];\n\t\t\tvar key = groupKeys[i]; /// key is model filename\n\t\t\tvar group = modelGroups[key];\n\n\t\t\tvar meshGroups = [];\n\t\t\t\n\t\t\t/// Get model just once for this group\n\t\t\tvar showUnmaterialed = false;\n\t\t\tRenderUtils.getMeshesForFilename(key, null, self.localReader, self.meshCache, self.textureCache, showUnmaterialed,\n\n\t\t\t\tfunction(meshes, isCached){\n\t\t\t\t\t\n\t\t\t\t\t/// If there were meshes, add them to the scene with correct scaling rotation etc.\n\t\t\t\t\tif(meshes /* && meshes.length == 3*/){\n\n\t\t\t\t\t\t/// Add one copy per model instance\n\t\t\t\t\t\t/// TODO: add rotation!\n\t\t\t\t\t\t/// TODO: fine tune position?\n\t\t\t\t\t\t/// TODO: POTIMIZE!\n\t\t\t\t\t\t\n\n\t\t\t\t\t\tgroup.forEach(function(model, instanceIdx){\n\n\t\t\t\t\t\t\tvar isCached = true;\n\t\t\t\t\t\t\tvar scale = 1.0;\n\n\t\t\t\t\t\t\t/// For each Mesh in the model\n\t\t\t\t\t\t\tmeshes.forEach(function(mesh, meshIdx){\n\n\t\t\t\t\t\t\t\tif(mesh.materialFlags == 525 /* || mesh.materialFlags == 520 || mesh.materialFlags == 521*/ ){\n\t\t\t\t\t\t\t\t\t//console.log(\"Skipping lod\");\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\t\tvar move = {x:0,y:0,z:0};\n\n\t\t\t\t\t\t\t \t/// Add to big mesh\n\t\t\t\t\t\t\t \tif(!meshGroups[meshIdx]){\n\t\t\t\t\t\t\t \t\tvar mg = mesh.geometry.clone();\n\t\t\t\t\t\t\t \t\tvar mga = mg.attributes;\n\t\t\t\t\t\t\t \t\tmeshGroups[meshIdx] = {\n\t\t\t\t\t\t\t \t\t\treadVerts : mga.position.array,\n\t\t\t\t\t\t\t \t\t\tverts: new Float32Array( group.length * mga.position.array.length ),\n\n\t\t\t\t\t\t\t \t\t\treadIndices : mg.getIndex().array,\n\t\t\t\t\t\t\t \t\t\tindices: new Uint32Array( group.length * mg.getIndex().array.length ),\n\n\t\t\t\t\t\t\t \t\t\treadUVs : mga.uv.array,\n\t\t\t\t\t\t\t \t\t\tuvs: new Float32Array( group.length * mga.uv.array.length ),\n\n\t\t\t\t\t\t\t \t\t\treadNormals : mga.normal.array,\n\t\t\t\t\t\t\t \t\t\tnormals: new Float32Array( group.length * mga.normal.array.length ),\n\n\t\t\t\t\t\t\t \t\t\tmaterial:mesh.material,\n\t\t\t\t\t\t\t \t\t\t//material:new THREE.MeshBasicMaterial( {color: 0xffcccc, wireframe:true} ),\n\t\t\t\t\t\t\t \t\t\t/*material : new THREE.PointCloudMaterial ({\n\t\t\t\t\t\t\t\t\t      color: 0xFF0000,\n\t\t\t\t\t\t\t\t\t      size: 20\n\t\t\t\t\t\t\t\t\t    }),*/\n\t\t\t\t\t\t\t \t\t\tposition:{x:model.x, y:model.y, z:model.z}\n\t\t\t\t\t\t\t \t\t}\n\t\t\t\t\t\t\t \t}\n\t\t\t\t\t\t\t \telse{\n\t\t\t\t\t\t\t \t\t/// Translate\n\t\t\t\t\t\t \t\t\tmove.x = model.x - meshGroups[meshIdx].position.x;\n\t\t\t\t\t\t \t\t\tmove.y = model.z - meshGroups[meshIdx].position.z;\n\t\t\t\t\t\t \t\t\tmove.z = model.y - meshGroups[meshIdx].position.y;\n\t\t\t\t\t\t\t \t}\n\n\t\t\t\t\t\t\t \t/// Add geom verts\n\t\t\t\t\t\t\t \tvar readVerts = meshGroups[meshIdx].readVerts;\n\t\t\t\t\t\t\t \tvar writeVerts = meshGroups[meshIdx].verts;\n\t\t\t\t\t\t\t \tvar stride = readVerts.length;\n\n\t\t\t\t\t\t\t \tfor ( var i = 0, j = instanceIdx * stride; i < stride; i +=3, j +=3 ) {\n\t\t\t\t\t\t\t\t\twriteVerts[ j + 0 ] = readVerts[ i + 0 ] + move.x;\n\t\t\t\t\t\t\t\t\twriteVerts[ j + 1 ] = readVerts[ i + 1 ] + move.y;\n\t\t\t\t\t\t\t\t\twriteVerts[ j + 2 ] = readVerts[ i + 2 ] + move.z;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tvar readIndices = meshGroups[meshIdx].readIndices;\n\t\t\t\t\t\t\t \tvar writeIndices = meshGroups[meshIdx].indices;\n\t\t\t\t\t\t\t \tvar strideIndices = readIndices.length;\n\t\t\t\t\t\t\t \tvar shift = stride * instanceIdx  / 3;\n\n\t\t\t\t\t\t\t\tfor ( var i = 0, j = instanceIdx * strideIndices; i < strideIndices; i ++, j ++ ) {\n\t\t\t\t\t\t\t\t\twriteIndices[ j ] = readIndices[ i ] + shift;\n\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\tvar readUVs = meshGroups[meshIdx].readUVs;\n\t\t\t\t\t\t\t\tvar writeUvs = meshGroups[meshIdx].uvs;\n\t\t\t\t\t\t\t\tvar uvStride = readUVs.length;\n\t\t\t\t\t\t\t\tfor ( var i = 0, j = instanceIdx * uvStride; i < uvStride; i ++, j ++ ) {\n\t\t\t\t\t\t\t\t\twriteUvs[ j ] = readUVs[ i ];\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tvar readNormals = meshGroups[meshIdx].readNormals;\n\t\t\t\t\t\t\t\tvar writeNormals = meshGroups[meshIdx].normals;\n\t\t\t\t\t\t\t\tvar normalStride = readNormals.length;\n\t\t\t\t\t\t\t\tfor ( var i = 0, j = instanceIdx * normalStride; i < normalStride; i ++, j ++ ) {\n\t\t\t\t\t\t\t\t\twriteNormals[ j ] = readNormals[ i ];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t});// End for each model in group\n\t\t\t\t\t\t\n\t\t\t\t\t}/// End if meshes\n\n\t\t\t\t\t/// Add each cluster of merged meshes to scene\n\t\t\t\t\tmeshGroups.forEach(function(meshGroup){\n\n\t\t\t\t\t\tvar mergedGeom = new THREE.BufferGeometry();\n\t\t\t\t\t\t\n\t\t\t\t\t\tmergedGeom.addAttribute( 'position', new THREE.BufferAttribute( meshGroup.verts, 3 ) );\n\t\t\t\t\t\t//mergedGeom.addAttribute( 'index', new THREE.BufferAttribute( meshGroup.indices, 1) );\n\t\t\t\t\t\tmergedGeom.setIndex(new THREE.BufferAttribute(meshGroup.indices, 1));\n\t\t\t\t\t\tmergedGeom.addAttribute( 'normal', new THREE.BufferAttribute( meshGroup.normals, 3 ) );\n\t\t\t\t\t\tmergedGeom.addAttribute( 'uv', new THREE.BufferAttribute( meshGroup.uvs, 2) );\n\n\t\t\t\t\t\tmergedGeom.buffersNeedUpdate = true;\n\n\t\t\t\t\t\tmesh = new THREE.Mesh( mergedGeom, meshGroup.material );\n\t\t\t\t\t\tmesh.position.set(meshGroup.position.x, meshGroup.position.z, meshGroup.position.y);\n\n\t\t\t\t\t\tself.getOutput().meshes.push(mesh);\n\n\t\t\t\t\t});// End for each meshgroup\n\n\n\t\t\t\t\t/// Rendering is done, render next.\n\t\t\t\t\tstepModels(i+1);\n\t\t\t\t}\n\n\t\t\t);\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t}/// End function stepModels\n\n\t\t/// Begin stepping trough the models, rendering them.\n\t\tstepModels(0);\n\t}\n\n\n\t/**\n\t * TODO\n\t * @method  getModelGroups\n\t * @param  {[type]} zone    [description]\n\t * @param  {[type]} zoneDef [description]\n\t * @param  {[type]} mapRect [description]\n\t * @return {[type]}         [description]\n\t */\n\tthis.getModelGroups = function(zone, zoneDef, mapRect){\n\n\t\t/// Calculate rect in global coordinates\n\t\tvar zPos = zone.zPos;\n\n\t\tvar mapX = mapRect[0];\n\t\tvar mapY = mapRect[1];\n\t\tvar c  = 32+16;\n\n\t\t// [\"x1\",\"uint32\",\"y1\",\"uint32\",\"x2\",\"uint32\", \"y2\", \"uint32\"]\n\t\tvar zoneRect = {\n\t\t\tx1:zone.vertRect[0]*c+mapX,\n\t\t\tx2:zone.vertRect[2]*c+mapX,\n\t\t\ty1:zone.vertRect[1]*-c-mapY,\n\t\t\ty2:zone.vertRect[3]*-c-mapY\n\t\t};\t\n\n\t\t\n\n\t\t/// Zone width and depth in local corrdinates\n\t\t/*var zdx = zone.vertRect.x1-zone.vertRect.x2;\n\t\tvar zdy = zone.vertRect.y1-zone.vertRect.y2;*/\n\t\t\n\t\t/// These zones seems to overflow :/\n\t\tif(zone.encodeData.length == 0){\n\t\t\treturn {};\n\t\t}\n\t\t\n\t\t//console.log(\"Get mdl groups\", zone);\n\t\t/// Testing: Render Zone Vert Rect\n\t\t//RenderUtils.renderRect(zoneRect, -zPos);\n\n\t\tvar zdx = zone.vertRect[0]-zone.vertRect[2];\n\t\tvar zdy = zone.vertRect[1]-zone.vertRect[3];\n\n\t\t/// Zone Flags increases a linear position, used to step trough the Zone.\n\t\tvar linearPos = 0;\n\n\t\tvar modelGroups = {};\n\n\t\tvar terrainTiles = this.getOutput(T3D.TerrainRenderer).terrainTiles;\n\n\t\tfor(var i = 0; i< zone.flags.length; i+=2){\n\n\t\t\t/// Step forward\n\t\t\tlinearPos += zone.flags[i];\n\n\t\t\t/// Check if a model should be placed\n\t\t\tvar flag = zone.flags[i+1];\n\t\t\tif(flag!=0){\n\t\t\t\t\n\t\t\t\t/// Extract flag data\n\t\t\t\t/// Layer is written in the last 4 bytes\n\t\t\t\tvar zoneDefLayer = flag >> 4;\n\n\t\t\t\t/// Get Zone Definition Layer\n\t\t\t\tvar layer = zoneDef.layerDefArray[zoneDefLayer-1];\n\n\t\t\t\t/// TESTING Only show layers with height >= 3\n\t\t\t\tif(layer/* && layer.height >= 0*/){\n\n\t\t\t\t\t/// Get X and Y from linear position\n\t\t\t\t\tvar modelX = (linearPos % zdx)*c + zoneRect.x1;\n\t\t\t\t\tvar modelY = Math.floor(linearPos / zdx)*c + zoneRect.y1;\n\n\t\t\t\t\t/// Get Z from intersection with terrain\n\t\t\t\t\tvar modelZ = null;\n\n\t\t\t\t\tvar startZ = 100000;\n\n\t\t\t\t\tvar raycaster = new THREE.Raycaster(\n\t\t\t\t\t\tnew THREE.Vector3(modelX, startZ, modelY),\n\t\t\t\t\t\tnew THREE.Vector3(0, -1, 0)\n\t\t\t\t\t);\n\n\t\t\t\t\t/// TODO: OPT?\n\t\t\t\t\tterrainTiles.forEach(function(chunk){\n\t\t\t\t\t\tif(modelZ === null){\n\t\t\t\t\t\t\tvar intersections = raycaster.intersectObject(chunk);\n\t\t\t\t\t\t\tif(intersections.length>0){\n\t\t\t\t\t\t\t\tmodelZ = startZ - intersections[0].distance;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\t/// Get model id\n\t\t\t\t\t/// TODO: check with modelIdx = flag & 0xf;\n\t\t\t\t\tvar modelIdx = 0; \n\t\t\t\t\tvar model = layer.modelArray[modelIdx];\n\t\t\t\t\tvar modelFilename = model.filename;\n\t\t\t\t\tvar zOffsets = model.zOffsets;\n\n\t\t\t\t\tvar layerFlags = layer.layerFlags; //NOrmaly 128, 128\n\t\t\t\t\t\n\t\t\t\t\t//TODO: flip z,y?\n\t\t\t\t\tvar rotRangeX = layer.rotRangeX;//max min\n\t\t\t\t\tvar rotRangeY = layer.rotRangeY;//max min\n\t\t\t\t\tvar rotRangeZ = layer.rotRangeZ;//max min\n\t\t\t\t\tvar scaleRange = layer.scaleRange;//max min\n\t\t\t\t\tvar fadeRange = layer.fadeRange;//max min\n\n\t\t\t\t\t//Unused\n\t\t\t\t\t//tiling: 3\n\t\t\t\t\t//type: 1\n\t\t\t\t\t//width: 2\n\t\t\t\t\t//radiusGround: 2\n\n\t\t\t\t\t/// Create modelGroup (this zone only)\n\t\t\t\t\tif(!modelGroups[modelFilename]){\n\t\t\t\t\t\tmodelGroups[modelFilename] = [];\n\t\t\t\t\t}\n\n\t\t\t\t\t/// Add entry to model group\n\t\t\t\t\tmodelGroups[modelFilename].push({\n\t\t\t\t\t\tx:modelX,\n\t\t\t\t\t\ty:modelY,\n\t\t\t\t\t\tz:modelZ,\n\t\t\t\t\t\trotRangeX:rotRangeX,\n\t\t\t\t\t\trotRangeY:rotRangeY,\n\t\t\t\t\t\trotRangeZ:rotRangeZ,\n\t\t\t\t\t\tscaleRange:scaleRange,\n\t\t\t\t\t\tfadeRange:fadeRange\n\n\t\t\t\t\t});\n\t\t\t\t\t\n\n\t\t\t\t}/// End if layer\n\n\t\t\t\t\n\t\t\t}/// End if flag != 0\n\n\t\t} /// End for each flag\n\n\t\treturn modelGroups;\n\t}\n}\n\n/// NOT USED??\nfunction addZoneMeshesToScene(meshes, isCached, position, scale, rotation){\n\t\n\t/// Called for each mesh in the zone\n\t/// TODO: Opt opt opt...\n\n    meshes.forEach(function(mesh){\n\n    \t/// Create new mesh if we got back a cached original.\n\t\tif(isCached)\n\t\t\tmesh = new THREE.Mesh( mesh.geometry, mesh.material );\n\n    \t/// Scale, position and rotate.\n    \tmesh.scale.set( scale, scale, scale );\n    \tif(rotation){\n\t    \tmesh.rotation.order = \"ZXY\";\n\t    \tmesh.rotation.set(rotation.x, rotation.y, rotation.z);\n\t    }\n    \tmesh.position.set(position.x, position.y, position.z);\n\n    \t/// Add to export\n    \tthis.getOutput().meshes.push(mesh);\n\t});\n\n}\n\n\n/// DataRenderer inheritance:\nZoneRenderer.prototype = Object.create(DataRenderer.prototype);\nZoneRenderer.prototype.constructor = ZoneRenderer;\n\n/**\n * Renders all zone meshes in a GW2 map described by the map's \"zon2\" chunk.\n * Output fileds generated:\n *\n * - *meshes* An array of THREE.Mesh objects visualizing all zone models refered by this map.\n * \n * @method  renderAsync\n * @async\n * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n */\nZoneRenderer.prototype.renderAsync = function(callback){\n\tvar self = this;\n\n\t/// Set up output array\n\tself.getOutput().meshes = [];\n\t\n\tvar zoneChunkData = this.mapFile.getChunk(\"zon2\").data;\n\tvar parameterChunkData = this.mapFile.getChunk(\"parm\").data;\n\tvar terrainChunkData = this.mapFile.getChunk(\"trn\").data;\n\tvar mapRect = parameterChunkData.rect;\n\t\t\t\t\n\t/// Zone data\n\tvar zones = zoneChunkData.zoneArray;\n\tvar zoneDefs = zoneChunkData.zoneDefArray;\n\n\t/// Render each zone\n\tlastPct = -1;\t\t\n\n\t/// Main render loop, render each zone\n\tfunction stepZone(i){\n\n\t\tvar pct = Math.round(100.0*i / zones.length);\n\t\tif(lastPct!=pct){\n\t\t\tself.logger.log(\n\t\t\t\tT3D.Logger.TYPE_PROGRESS,\n\t\t\t\t\"Loading 3D Models (Zone)\", pct\n\t\t\t);\n\t\t\tlastPct = pct;\n\t\t}\n\n\t\tif(i >= zones.length){\n\t\t\tcallback();\n\t\t\treturn;\n\t\t}\n\n\t\t/// Main zone render function call\n\t\tself.renderZone(zones[i], zoneDefs, mapRect,\n\t\t\tstepZone.bind(self,i+1)\n\t\t);\t\n\n\t}\n\n\tstepZone(0);\n}\n\nmodule.exports = ZoneRenderer;\n\n//// Not used: zone defintion per chunk data \"images\" 32*32 points\n/*\n//Total map dx and dy\nvar d = terrainChunkHeader.data;\nvar pd = parameterChunkHeader.data;\nvar dx = (pd.rect.x2-pd.rect.x1);\nvar dy = (pd.rect.y2-pd.rect.y1);\n\n//Each chunk dx and dy\n\nvar c =1;\nvar cdx = c*dx/d.dims.dim1;\n\nvar cdy = c*dy/d.dims.dim2;\n\nvar cdx = dx/(d.numChunksD_1*2);\nvar cdy =dy/(d.numChunksD_2*2);\n\n\nfor(var i=0; i<zoneDefs.length; i++){\n\tvar zoneDef = zoneDefs[i];\n\t\n\t//TODO: opt!\n\tzoneDef.layerDefs.forEach(function(layer){\n\n\t\tlayer.modelArray.forEach(function(model){\n\t\t\n\t\t\t\n\t\t});\n\t\t\n\n\t});\n\n\tvar chunkMat = new THREE.MeshBasicMaterial(\n\t\t{\n\t\t\tcolor: 0x00ff00,\n\t\t\twireframe:true,\n\t\t \topacity: 1.0,\n\t\t}\n\t);\n\n\t//TODO: opt!\n\t\n\tif(\n\t\tzoneDef.token == 597  ||\n\t\tzoneDef.token == 1369  ||\n\t\tzoneDef.token == 903  \n\t){\n\n\t\tzoneDef.pageTable.pageArray.forEach(function(page){\n\t\t\tvar flags = page.flags;\n\t\t\tvar coord = page.chunkCoord;\n\n\n\t\t\t//Hightlight this coord\n\t\t\tvar rect = {};\n\n\t\t\t\n\t\t\t//var globalOffsetX = pd.rect.x2 - cdx;\n\t\t\tvar globalOffsetX = pd.rect.x1 + cdx/2;\n\t\t\tvar chunkOffsetX = coord[0] * cdx;\n\n\t\t\trect.x1  = globalOffsetX + chunkOffsetX;\n\n\t\t\t///Adjust for odd / even number of chunks\n\t\t\tif(d.numChunksD_2 % 2 == 0){\n\t\t\t\t\n\t\t\t\tvar globalOffsetY = -pd.rect.y1;\n\t\t\t\tvar chunkOffsetY = -coord[1] * cdy;\n\n\t\t\t\trect.y1  =  chunkOffsetY + globalOffsetY;\n\t\t\t}\n\t\t\telse{\n\n\t\t\t\tvar globalOffsetY =  -pd.rect.y1;\n\t\t\t\tvar chunkOffsetY = -coord[1] * cdy;\n\n\t\t\t\trect.y1 = globalOffsetY +  chunkOffsetY;\t\n\t\t\t}\n\n\t\t\trect.x2 = rect.x1+cdx;\n\t\t\trect.y2 = rect.y1+cdy;\n\n\n\t\t\t\n\n\t\t\tRenderUtils.renderRect(rect, 4000,chunkMat, 4000);\n\n\t\t\t//for(var j=0; j<flags.length; j++){\n\t\t\t//\tif(flags[j]>0){\n\t\t\t//\t\tconsole.log(\"Found flag\",flags[j],\"@ zoneDef\",zoneDef.token,\"coord\",coord,\"index\",j);\n\t\t\t//\t}\n\t\t\t//}\n\t\t});\n\n\t}\n\n}*/","/*\nCopyright (C) 2015 RequestTimeout <https://github.com/RequestTimeout408>\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nmodule.exports  = [\n    //uint8_t  version;\n    \"version\",\"uint8\",                      \n\n    //uint8_t  magic[3];\n    \"magic\", \"string:3\",                    \n\n    //uint32_t headerSize;\n    \"headerSize\",\"uint32\",                  \n\n    //uint32_t unknown1;\n    \"unknown1\",\"uint32\",                    \n\n    //uint32_t chunkSize;\n    \"chunkSize\",\"uint32\",                   \n    \n    //uint32_t crc;\n    \"crc\",\"uint32\",                         \n    \n    //uint32_t unknown2;\n    \"unknown2\",\"uint32\",                    \n    \n    //uint64_t mftOffset;\n    \"mftOffset\",[ \"[]\",\"uint32\", 2 ],\n    \n    //uint32_t mftSize;\n    \"mftSize\",\"uint32\",\n    \n    //uint32_t flags;\n    \"flags\",\"uint32\"\n];","/*\nCopyright (C) 2015 RequestTimeout <https://github.com/RequestTimeout408>\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nmodule.exports = [\n\t//uint8_t  magic[4];\n\t\"magic\",\"string:4\",\n\t\t\n\t//uint64_t unknown1;\n\t\"unknown1\",[ \"[]\",\"uint32\", 2 ],\n\n\t//uint32_t nbOfEntries;\n\t\"nbOfEntries\",\"uint32\",\n\n\t//uint32_t unknown2;\n\t\"unknown2\",\"uint32\",\n\t\n\t//uint32_t unknown3;\n\t\"unknown3\",\"uint32\",\n];","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nvar HEAD_STRUCT = [\n\t'type', 'cstring:4',\n\t'chunkDataSize', 'uint32',\n\t'chunkVersion', 'uint16',\n\t'chunkHeaderSize', 'uint16',\n\t'offsetTableOffset', 'uint32',\n];\n\n\n/**\n * Settings for resolving conflicting chunk names in different files.\n * @private \n * @property DUPLICATE_SETTINGS\n * @type {Object}\n */\nvar DUPLICATE_SETTINGS = {\n\t'ANIM':['MODL','Unknown'],\n\n\t'GAME':['MODL','Unknown'],\n\n\t'Main':['cntc','mMet'],\n\n\t'SKEL':['MODL','Unknown'],\n\n\t'TOOL':['AMAT','MODL'],\n\n\t'main':['Unknown','Unknown','cmaC'],\n\n\t'nvms':['Unknown','Unknown']\n};\n/*\n\tANIM, GAME, SKEL needs to know file name for scenefile...\n\n\tANIM: 2\n\t\tModelFileAnimationV25\t\tMODL\n\t\tSceneFileAnimationV2\t\t?\n\n\tGAME: 2\n\t\tModelFileGame\t\t\t\tMODL ???\n\t\tSceneFileGameV6\t\t\t\t?\n\n\tMain: 2\n\t\tPackContent\t\t\t\t\tcntc\n\t\tPackMapMetadata\t\t\t\tmMet\n\n\tSKEL: 2\n\t\tModelFileSkeletonV1\t\t\tMODL\n\t\tSceneFileSkeletonV3\t\t\t?\n\n\tTOOL: 2\n\t\tAmatToolParams\t\t\t\tAMAT ???\n\t\tModelFileToolV16\t\t\tMODL ???\n\n\tmain: 3\n\t\tCollideNavMesh\n\t\tCollideNavMeshChunk\n\t\tCollideModelManifest\t\tcmaC\n\n\tnvms: 2\n\t\tPackMapNavMeshV2\n\t\tPackMapNavMeshChunkV2\n*/\n\n   \n\n\n\n/**\n * Basic chunk parsing functionality for Guild Wars 2 file chunks\n * @class GW2Chunk\n * @constructor\n * @param {DataStream} ds A DataStream containing deflated chunk binary data.\n * @param {Number} addr Offset of chunk start within the DataStream\n */\nvar Chunk = function(ds, addr){\n\n\t/**\n\t * @property {DataStream} ds The DataStream data source used by this chunk.\n\t */\n\tthis.ds = ds;\n\n\t/**\n\t * @property {Number} addr The address to this Chunk within ds.\n\t */\n\tthis.addr = addr;\n\n\t/**\n\t * @property {Object} data The typed data read from the body of this chunk.\n\t */\n\tthis.data = null;\n\n\n\t/**\n\t * @property {Number} headerLength The length in bytes of the chunk header.\n\t */\n\tthis.headerLength  = NaN;\n\n\t/**\n\t * @property {Object} header Chunk header data.\n\t */\n\tthis.loadHead();\n};\n\n/**\n * Parses the chunk header data, populating the header property.\n * @method loadHead\n */\nChunk.prototype.loadHead=function(){\n\tthis.ds.seek(this.addr);\t\n\tthis.header = this.ds.readStruct(HEAD_STRUCT);\n\n\tthis.headerLength = this.ds.position - this.addr;\n};\n\n/**\n * @method  getDefinition\n * @param  {String} fileType The main type of the pack file containing this chunk.\n * Used for resolving chunk naming conflicts between pack file types.\n * @return {Array}\tDataStream formatted array describing the data\n * sctructures of this chunk\n */\nChunk.prototype.getDefinition=function(fileType){\n\n\t/// Normally we're looking for the 0th occurance\n\t/// But some chunk names occur multiple times and we're interrested\n\t/// in the N:th occurance of the definition.\n\t/// \n\t/// I've no idea how this is automated, for now just use the \n\t/// settings object I've put together from experience.\n\tvar useNthIndex = 0;\n\n\t/// If this chunk has multiple definitions\n\t/// get to know what def to use...\n\tvar fileTypes = DUPLICATE_SETTINGS[this.header.type];\n\tif(fileTypes){\n\n\t\tuseNthIndex = -1;\n\n\t\t/// Check what file name entry matches this file name\n\t\tfor(var i=0; i<fileTypes.length && useNthIndex == -1; i++){\n\t\t\tvar ft = fileTypes[i];\n\n\n\t\t\tif(ft == fileType){\n\t\t\t\tuseNthIndex = i;\n\t\t\t}\n\t\t}\n\n\t\t/// We didnt find this file name!\n\t\t/// TODO: if you get this error, please update the DUPLICATE_SETTINGS above\n\t\tif(useNthIndex == -1){\n\t\t\tdebugger;\n\t\t}\n\t}\n\n\tvar defsFound = 0;\n\tfor(var i=0; i<T3D.formats.length; i++){\n\t\tvar f = T3D.formats[i];\n\t\t\n\t\t/// Chunk name needs to match\n\t\tif(\tf.name == this.header.type ){\n\n\t\t\t/// There needs to be a chunk def version matching the one specifiend \n\t\t\t/// \n\t\t\t/// AND If this is the Nth occurance of the chunk definition\n\t\t\t/// and we're looking for the Nth occurance, return it.\n\t\t\t/// \n\t\t\t/// chunkVersion in the dat uses 0 indexing\n\t\t\tif( defsFound == useNthIndex && f.versions[this.header.chunkVersion] ){\n\t\t\t\treturn ( new f.versions[this.header.chunkVersion]() ).__root;\t\n\t\t\t}\n\n\t\t\tdefsFound++;\n\t\t}\n\t}\n\t\n\n};\n\n/**\n * Parses the chunk main data, populating the data property.\n * @method loadData\n * @param  {String} fileType The main type of the pack file containing this chunk.\n * Used for resolving chunk naming conflicts between pack file types when\n * looking up the structure definition for this chunk.\n */\nChunk.prototype.loadData=function(fileType){\n\n\tvar def = this.getDefinition(fileType);\n\t\n\tif(def){\n\t\tthis.ds.seek(this.addr + this.headerLength);\n\t\tthis.data =  this.ds.readStruct(def);\n\t}\n\n\telse{\n\t\tT3D.Logger.log(T3D.Logger.TYPE_WARNING,\n\t\t\t\"Could not find a definition for chunk\",\n\t\t\tthis.header.type,\n\t\t\t\"version\", this.header.chunkVersion,\n\t\t\t\"file name\", fileType);\n\t}\n\t\n};\n\n/**\n * Retrieves the next chunk is the datastream. In practice this means the next chunk\n * within the same pack file.\n * @method next\n * @return {GW2Chunk} The next chunk if any, otherwise null.\n */\nChunk.prototype.next = function(){\n\ttry{\n\t\t\n\t\t// Calculate actual data size, as mChunkDataSize\n\t\t// does not count the size of some header variables\n\t\treturn new Chunk(this.ds,this.addr + 8 + this.header.chunkDataSize);\n\t}\n\tcatch(e){\n\t\t/// Out of bounds probably\t\t\n\t}\n\treturn null;\n};\n\nmodule.exports = Chunk;","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nvar Chunk = require('./GW2Chunk');\n\nvar HEAD_STRUCT = [\n\t'identifier', 'cstring:2',\n\t'unknownField1', 'uint16',\n\t'unknownField2', 'uint16',\n\t'pkFileVersion', 'uint16',\n\t'type', 'cstring:4'\n];\n\n\n/**\n * Basic header and chunk parsing functionality for Guild Wars 2 pack files (PF)\n * @class GW2File\n * @constructor\n * @param {DataStream} ds A DataStream containing deflated file binary data.\n * @param {Number} addr Offset of file start within the DataStream\n * @param {boolean} noChunks If true, the file does not parse its\n * chunks on creation.\n */\nvar File = function(ds, addr, noChunks){\n\n\t/**\n\t * @property {DataStream} ds The DataStream data source used by this file.\n\t */\n\tthis.ds = ds;\n\n\t/**\n\t * @property {Number} addr The address to this File within ds.\n\t */\n\tthis.addr = addr;\n\n\t/// Not used anymore I think\n\tthis.data = null;\n\n\t/**\n\t * @property {Number} headerLength The length in bytes of the file header.\n\t */\n\tthis.headerLength  = NaN;\n\n\t/**\n\t * All {{#crossLink \"GW2Chunk\"}}chunks{{/crossLink}} contained in the file.\n\t *\n\t * @property chunks\n\t * @type GW2Chunk[]\n\t */\n\tthis.chunks = [];\n\t\n\n\t/**\n\t * @property {Object} header Chunk header data.\n\t */\n\tthis.readHead();\n\t\n\tif(!noChunks){\n\t\tthis.readChunks();\n\t}\n};\n\n\n/**\n * Parses the file header data, populating the header property.\n * @method readHead\n */\nFile.prototype.readHead = function(){\n\tthis.ds.seek(this.addr);\n\tthis.header = this.ds.readStruct(HEAD_STRUCT);\n\tthis.headerLength = this.ds.position - this.addr;\n};\n\n/**\n * Parses the file headers and populates the chunks property.\n * @method readChunks\n */\nFile.prototype.readChunks = function(){\n\n\t/// Reset chunks\n\tthis.chunks = [];\n\n\t//var structs = this.getChunkStructs && this.getChunkStructs();\n\n\t/// Load basic Chunk in order to read the chunk header.\n\tvar ch = new Chunk(this.ds, this.headerLength + this.addr);\t\n\n    //while(structs && ch!=null && ch.header.type){\n    while(ch!=null && ch.header.type){\n\n    \t/// Load data and pass file type if we need to determine what chunk entry to use\n    \t/// (Some chunks in different files share the same chunk name)\n\t\tch.loadData(this.header.type);\n\t    this.chunks.push(ch);\n\n    \t/// Load next basic Chunk in order to read the chunk header.\n    \tch = ch.next();\n    }\n};\n\n\n/**\n * Get a GW2Chunk from this file\n * @method getChunk\n * @param  {String} type The name, or type of the desired chunk.\n * @return {GW2Chunk} The first GW2Chunk in this file matching the type name, or null if no matching GW2Chunk was found.\n */\nFile.prototype.getChunk = function (type){\n\tfor(var i=0; i<this.chunks.length; i++){\n\t\tif( this.chunks[i].header.type.toLowerCase() == type.toLowerCase() )\n\t\t\treturn this.chunks[i]; \n\t}\n\treturn null;\n};\n\n/**\n * Provides a list of known header types and their parsing structure. Should be defined by each file type individually.\n * @method getChunkStructs\n * @return {Object} An object mapping chunk identifiers to DataStream structure descriptors.\n */\nFile.prototype.getChunkStructs = function(){\n\treturn {}\n};\n\nmodule.exports = File;","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/*\n\tguid 1683952224941671000 is fucked up floor in SAB HUB\n\tmaterialFilename for that mesh is 564821, shared with lots of stuff\n\tlod 1 and 2 are both 0\n\tmaterial flags is 2056\n*/\n\n/**\n * Collection of methods for generating THREE materials and textures\n * from Guild Wars 2 data formats.\n * @Class MaterialUtils\n * @static\n */\nvar ME = module.exports = {};\n\n\n/**\n * Builds a custom vertex shader for a given number of uv cannels.\n * WIP not implemented yet!\n * \n * @method  buildVS\n * @param  {Number} numUv Number of UV channels used by this shader\n * @return {String}       Genereted vertex shader source\n */\nfunction buildVS(numUv){\n\n\tvar vdefs = \"\";\n\tvar adefs = \"\";\n\tvar reads = \"\";\n\tfor(var i=0; i< numUv; i++){\n\t\tvdefs += \"varying vec2 vUv_\"+(i+1)+\";\\n\";\n\t\t\n\t\t/// uv and uv2 are defined by THREE\n\t\tif(i>1)\n\t\t\tadefs += \"attribute vec2 uv\"+(i+1)+\";\\n\";\n\n\n\t\treads += \"vUv_\" + (i+1) + \" = uv\"+(i>0?(i+1):\"\")+\";\\n\";\n\t}\n\n\treturn adefs + vdefs +\n\t    \"void main()\\n\"+\n\t    \"{\\n\"+\n\t        reads+\n\t        \"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\"+\n\t        \"gl_Position = projectionMatrix * mvPosition;\\n\"+\n\t    \"}\";\n}\n\n\n/**\n * Generate a texture of a specified color, used to be part of THREEjs\n * \n * @method generateDataTexture\n * @param {Number} width \n * @param {Number} height \n * @param {THREE.Color} color \n */\nfunction generateDataTexture(width, height, color){\n\t// create a buffer with color data\n\tvar size = width * height;\n\tvar data = new Uint8Array( 4 * size );\n\tvar r = Math.floor( color.r * 255 );\n\tvar g = Math.floor( color.g * 255 );\n\tvar b = Math.floor( color.b * 255 );\n\tvar a = 255;\n\n\tfor ( var i = 0; i < size; i ++ ) {\n\t\tvar stride = i * 4;\n\n\t\tdata[ stride ] = r;\n\t\tdata[ stride + 1 ] = g;\n\t\tdata[ stride + 2 ] = b;\n\t\tdata[ stride + 3 ] = a;\n\t}\n\t// used the buffer to create a DataTexture\n\treturn new THREE.DataTexture( data, width, height, THREE.RGBAFormat );\n}\n\n/**\n * Builds a custom pixel shader for a given number of uv cannels.\n * WIP not implemented yet!\n * \n * @method buildPS\n * @param  {Array}  textures  THREE textures\n * @param  {Number} numUv     Number of UV channels used by this shader\n * @param  {Number} alphaTest Texture see-trough alpha treshold\n * @param  {TODO} lightMap  TODO\n */\nfunction buildPS(textures, numUv, alphaTest, lightMap){\n\tvar t1uv = \"vUv_\"+(textures[0].uvIdx+1);\n\t\n\n\tvar discard = \"\";\n\n\tif(alphaTest){\n\t\tdiscard = \"    if (c1.a < 0.5) \\n\"+\n    \t\"       discard;\\n\";\t\n\t}\n\n    /// Color from 1st text or lighted by 2nd?\n    var writeColor = \"gl_FragColor = c1;\\n\";\n\n    if(lightMap){\n    \tvar texIdx = 0;\n    \t//var t2uv = \"vUv_4\";//+(3-textures[texIdx].uvIdx+1);\n    \tvar t2uv = \"vUv_1\";// + (textures[texIdx].uvIdx+1);\n    \t//console.log(\"t2uv\",t2uv);\n\n    \twriteColor = \"   vec4 c2 = texture2D( texture\"+(texIdx+1)+\", \"+t2uv+\" );\\n\"+\n\t    \"     gl_FragColor = c2;\\n\";\n\t    //\"     gl_FragColor = vec4(c2.rgb * c1.r/.5, c2.a);\\n\";\n    }\n\n\n    var uniforms = \"\"\n    textures.forEach(function(t,idx){\n    \tuniforms += \"uniform sampler2D texture\"+(idx+1)+\";\\n\";\n    });\n\t/*uniforms += \"uniform sampler2D texture1;\\n\";\n\tif(lightMap)\n\t\tuniforms += \"uniform sampler2D texture2;\\n\";*/\n\n\tvar varyings = \"\";\t\n\tfor(var i=0; i< numUv; i++){\n\t\tvaryings += \"varying vec2 vUv_\"+(i+1)+\";\\n\";\n\n\t}\n\n\treturn uniforms + varyings +\n    \"void main( void ) {\\n\"+\n    \"    vec4 c1 = texture2D( texture1, \"+t1uv+\" );\\n\"+\n    discard +\n    writeColor +\n    \"}\";\n}\n\n/**\n * WIP, concept for generatin materials to render multi UV chanelled meshes.\n * \n * @method getUVMat\n * @param  {Array} \ttextures  THREE texture\n * @param  {Number} numUV     Number of UV channels used by this shader\n * @param  {Number} alphaTest Texture see-trough alpha treshold\n * @return {THREE.ShaderMaterial} Generated shader\n */\nfunction getUVMat(textures, numUV, alphaTest){\n\n\tvar lightMap = false;\n\tvar uniforms = {};\n\n\ttextures.forEach(function(t,idx){\n\t\tuniforms[\"texture\"+idx] = { type: \"t\", value: t };\n\t});\n\n\tif(textures.length>1){\n\t\tlightMap = true;\t\t\n\t}\n\n\tvar attributes = {};\n\n\tfor(var i=2; i<numUV; i++){\n\t\tattributes[\"uv\"+(i+1)] =  { type: 'v2', value: [] };\n\t}\n\n\tvar vs = buildVS(numUV);\n\n\treturn new THREE.ShaderMaterial( {\n\t\tuniforms: uniforms,\n\t\tvertexShader: vs,\n\t\tfragmentShader: buildPS(\n\t\t\t\ttextures,\n\t\t\t\tnumUV,\n\t\t\t\talphaTest,\n\t\t\t\tlightMap\n\t\t\t), \n\t\tattributes: attributes,\n\t\tside: THREE.FrontSide,\n\t} );\n\n}\n\n/**\n * Builds a THREE texture from a ModelMaterialData by reading settings and\n * loading any required data from the localReader. Uses sharedTextures for \n * texture caching.\n *\n * This method is full of guesses and estimations, and could be improved on\n * a lot, allowing rendering of multi UV channeled materials, or special\n * materials like custom color chanelled gear.\n * \n * @method getMaterial\n * @param  {ModelMaterialData} material \tA value object often automaticaly  \n *                                       \tgenerated by a\n *                                       \t{{#crossLink \"GW2Chunk\"}}{{/crossLink}}\n *                                       \tstructure definitions can be found in \n *                                       \tAllFormats.js, look for the latest \n *                                       \tversion of ModelMaterialData\n *                                       \t\n * @param  {GW2File} materialFile   A GW2File instance, must be of type AMAT\n * @param  {LocalReader} localReader The LocalReader to load the file contents from.   \n * @param  {Object} sharedTextures  Value Object for keeping the texture cache\n * @return {THREE.Material}         A THREE Material with the generated contents and settings.\n */\nvar getMaterial = ME.getMaterial = function(material, materialFile, localReader, sharedTextures){\n\n\tif(!materialFile)\n\t\treturn;\n\t\n\tvar dxChunk =  materialFile.getChunk(\"dx9s\");\n\tvar grChunk = materialFile.getChunk(\"grmt\");\n\n\t/// Append all textures to the custom material\n\tvar finalTextures = [];\n\t\n\t//Some materials don't use textures..\n\tif(material && material.textures.length/* && material.textures[texIndex]*/){\n\n\t\t/// TODO: check for flags!\t\t\t\n\t\t/// \n\t\t/// techinques[] -> passes[] -> effects[] -> samplerIndex[]\n\t\t/// \n\t\t//console.log(\"num effects\",dxChunk.data.techniques[0].passes[0].effects.length);\n\n\t\t//if(grChunk.data.flags!=76)\n\t\t//\treturn;\n\n\t\t/// 3 teqs : high medium low\t\t\t\t\t\t\t\tGRAPHICS LEVEL SETTINGS\n\t\t/// 1 passes\t\t\t\t\t\t\t\t\t\t\t\tDON'T CARE\n\t\t/// 15 effects\t\t\tEach effect has a pixel shader \t\tHOW??\n\t\t/// 1 or 2 sampler indices \t\t\t\t\t\t\t\t\tUSE ALL! (Multi material)\n\t\t\n\t\tvar effects = dxChunk.data.techniques[0].passes[0].effects;\n\t\t//var effect = effects[10];\n\t\tvar effect = effects[0];\n\n\t\tvar shader = dxChunk.data.shaders[effect.pixelShader];\n\t\t\n\t\t/*effects.forEach(function (eff) {\n\t\t\tif(eff.samplerIndex.length > effect.samplerIndex.length)\n\t\t\t\teffect = eff;\n\t\t});*/\n\t\t//var samplerIdx = effect.samplerIndex[0];\n\n\t\tvar samplerTextures = [];\n\t\tfor(var i=0; i<effect.samplerIndex.length; i++)\n\t\t{\n\n\t\t\tvar samplerIdx = effect.samplerIndex[i];\n\t\t\tvar sampler = dxChunk.data.samplers[samplerIdx];\n\n\t\t\t/// SHOULD NEVER HAPPEN, hide mesh!\n\t\t\tif(!sampler)\n\t\t\t\tcontinue;//return;\n\n\t\t\tvar textureToken = sampler && grChunk.data.texTokens[sampler.textureIndex];\n\t\t\tif(!textureToken)\n\t\t\t\ttextureToken = \"0-0\";\n\t\t\t/*else\n\t\t\t\ttextureToken =textureToken.val;*/\n\n\t\t\t/// Find the texture reffered by this sampler\n\t\t\tvar samplerTex = null;\n\n\t\t\tmaterial.textures.forEach(function(tex, index){\n\n\t\t\t\t///Seems like only 1st part of token is used...\n\t\t\t\tif(!samplerTex && tex.token.split(\"-\")[0] == textureToken.split(\"-\")[0]){\n\t\t\t\t\t//console.log(\"TEX match\",tex.token, textureToken)\n\t\t\t\t\tsamplerTex = tex;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t/// Add this sampler's texture to the collection of all textures\n\t\t\tif(samplerTex){\n\t\t\t\tsamplerTextures.push(samplerTex);\n\t\t\t}\n\t\t\telse{\n\t\t\t\t///FALLBACK, just guess what texture we should use\n\t\t\t\tif(sampler)\n\t\t\t\t\tsamplerTextures.push(material.textures[sampler.textureIndex]);\n\t\t\t\telse if(material.textures.length>0)\n\t\t\t\t\tsamplerTextures.push(material.textures[0]);\n\t\t\t\telse return;\n\t\t\t}\n\n\n\t\t}/// END for each sampler index in effect\n\n\t\t/// We now have all textures\n\t\t//console.log(\"textures from sampler\", samplerTextures);\n\t\t\t\t\n\n\t\t/// Fallback to using whatever texture there is.\n\t\tif(samplerTextures.length <= 0){\n\t\t\treturn;\n\t\t\t//mainTex =  material.textures[0];\t\t\t\n\t\t}\n\n\n\t\t//console.log(\"num samplers \",samplerTextures.length);\n\t\tsamplerTextures.forEach(function(texture, idx){\n\n\t\t\tif(!texture)\n\t\t\t\treturn;\n\t\t\t\n\t\t\t/// Set texture \"URL\"\n\t\t\tvar texURL = texture && texture.filename;\n\n\t\t\t/// Load texture from RAM or local reader:\n\t\t\tfinalTextures[idx] = getTexture(texURL, localReader, sharedTextures)\n\t\t\tif(finalTextures[idx]){\n\t\t\t\tfinalTextures[idx].uvIdx = texture.uvPSInputIndex;\t\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\n\t}/// End if material and texture\t\t\t\n\n\tvar finalMaterial;\n\n\n\t/// Create custom shader material if there are textures\n\tif(finalTextures){\n\n\t\t// TODO: make this work!\n\t\tif(false && finalTextures.length>0){\n\t\t\tfinalMaterial = getUVMat( finalTextures, material.texCoordCount, grChunk.data.flags!=16460 );\t\n\t\t}\n\t\telse{\n\t\t\tvar ft=false;\n\t\t\tvar nt=false;\n\t\t\tmaterial.textures.forEach(function(t){\n\t\t\t\t//Flag for diffuse map\n\t\t\t\tif(!ft && t.token.split(\"-\")[0] == \"1733499172\")\n\t\t\t\t\tft = t;\n\n\t\t\t\t//Flag for normal map\n\t\t\t\tif(!nt && t.token.split(\"-\")[0] == \"404146670\")\n\t\t\t\t\tnt = t;\n\t\t\t});\n\t\t\t\n\t\t\tif(!ft || ft.filename<=0)\n\t\t\t\treturn;\n\n\t\t\tfinalMaterial = new THREE.MeshPhongMaterial({\n\t\t\t\tside: THREE.FrontSide, map:getTexture(ft.filename, localReader, sharedTextures)\n\t\t\t}); \n\t\t\tif(nt) {\n\t\t\t\tvar normalMap = getTexture(nt.filename, localReader, sharedTextures);\n\t\t\t\tnormalMap.flipY = true;\n\t\t\t\tfinalMaterial.normalMap = normalMap;\n\t\t\t}\n\n\t\t\t\t\n\t\t\tfinalMaterial.textureFilename = ft.filename;\n\t\t\tif(grChunk.data.flags!=16460){\n\t\t\t\t//console.log(\"Setting alpha flag for \",grChunk.data.flags)\n\t\t\t\tfinalMaterial.alphaTest = 0.05;\n\t\t\t}\n\t\t}\n\t\t\t\n\t}\n\n\t/// Fallback material is monocolored red\n\telse{\n\t\tfinalMaterial = new THREE.MeshBasicMaterial({\n\t\t\tside: THREE.FrontSide,\n\t\t\tcolor:0xff0000,\n\t\t\tshading: THREE.FlatShading}); \n\t}\n\n\t\n\tfinalMaterial.needsUpdate = true;\n\n\n\t/// Set material props\n\t/// disable for now in order for custom shaders not to fuck up\n\t\n\tif(material){\n\n\t\tvar alphaMask0 = 0x0001;// + 0x0100 + 0x0200;\n    \tvar alphaMask1 = 0x0010\n    \tvar alphaMask2 = 0x0100 + 0x0200;\n    \tvar alphaMask2b =  0x0200;\n\n\t\t\n\t\tvar grChunk = materialFile.getChunk(\"grmt\");\n\n\t\t//Enable alpha test for transparent flags\n    \tif( (\n    \t\t material.materialFlags & alphaMask0 ||\n    \t\t material.materialFlags & alphaMask1 ||\n    \t\t material.materialFlags & alphaMask2\n    \t\t) //&& solidColor != null\n\t\t){\n    \t\t//return;\n    \t\t//mesh.material.transparent = true;\n    \t\t//mesh.material.opacity = 2.0;\n\n    \t\t//var clr = solidColor;\n    \t\t//var propAlpha = 0;\n\n    \t\t///Backgroud color adds to alpha\n    \t\t//if( mesh.materialFlags == 2569  ){\n\n    \t\t/// This is rly just guesswork\n    \t\t/// Check material flag  2568 (as int) and compare material filename 27353 to 20041\n    \t\t/// Same flags but some have alpha and some don't\n    \t\t//if( mesh.materialFlags & alphaMask2b  ){\n    \t\t//\tpropAlpha =  (clr[3] - 128)/128;\n    \t\t//\t//propAlpha = Math.max(0,propAlpha);\n    \t\t//}\n\n    \t\t//mesh.material.alphaTest = Math.max(0, 0.1 );//- propAlpha*2);\n    \t\t\n    \t}\n\n\n\t\t/// GRCHUNK -> DATA -> FLAGS\n\n\t\t///HAS LIGHT - TEX - ? - EMISSIVE16460\n\t\t///\n\t\t\n\t\t/// 56533 LOD FOR TOMBSTONE?\n\t\t\n\t\t//\t16460\t\t\t0100 0000 0100 1100\t\t\t\"standard\" stuff rendering OK in SAB (no alpha test)\n\n\t\t//\t\n\t\t//\t16452(SAB)\t\t0100 0000 0100 0100\t\t\tyellow numbers in sab signs\n\t\t//\t16448(SAB)\t\t0100 0000 0100 0000\t\t\tfaces on rocks, cloudmen, skybox portal images, holes in walls, floor plates...\n\t\t//\t\t\t\t\t\t\t\t\t\t\t\tno lighting??\n\t\t//\t\n\t\t//\t 8268\t\t\t0010 0000 0100 1100\t\n\t\t//\t 3392\t\t\t0000 1101 0100 0000\t\t\tMoto machine light bulbs\n\t\t//\t 2380\t\t\t0000 1001 0100 1100\n\t\t//\t 2368\t\t\t0000 1001 0100 0000\t\t\tFountain water with rings, portal border and circular \"light\"\n\t\t//\t  332\t\t\t0000 0001 0100 1100\n\t\t//\t  324\t\t\t0000 0001 0100 0100\t\t\tMoto face sprites\n\t\t//\t  \n\t\t//\t  320(SAB)\t\t0000 0001 0100 0000\t\t\tportal textures (normal maps ish)\n\t\t//\t  \n\t\t//\t   76\t\t\t0000 0000 0100 1100\t\t\tLOTS OF STUFF\n\t\t//\t   \t\t\t\t\t\t\t\t\t\t\tTree leaves, ground, hills, some roofs, flags, street lights\n\t\t//\t   \t\t\t\t\t\t\t\t\t\t\tsheild textures, some fences, water tops, waterfall\n\t\t//\t   \t\t\t\t\t\t\t\t\t\t\t\n\t\t//\t   \t\t\t\t\t\t\t\t\t\t\tIN KHYLO \"everything with alpha\"\n\t\t//\t   \n\t\t//\t   \n\t\t//\t   68\t\t\t0000 0000 0100 0100\t\t\tSome flowers (lo res?) fountain edges foam\n\t\t//\t   \n\t\t//\t   64(SAB)\t\t0000 0000 0100 0000\t\t\tclouds, sun iamge\n\n\n\t\tvar lightMask = 8;\n\t\t\n\t\tvar knownFileFlags = [\n\t\t\t16460,\n\t\t\t16452,\n\t\t\t16448,\n\t\t\t8268,\n\t\t\t3392,\n\t\t\t2380,\n\t\t\t2368,\n\t\t\t332,\n\t\t\t324,\n\t\t\t320,\n\t\t\t76,\n\t\t\t68,\n\t\t\t64];\n\n\t\tif(knownFileFlags.indexOf(grChunk.data.flags)<0){\n\t\t\tT3D.Logger.log(\n\t\t\t\tT3D.Logger.TYPE_WARNING,\n\t\t\t\t\"unknown GR flag\",grChunk.data.flags\n\t\t\t);\n\t\t}\n\n\t\tif( !(grChunk.data.flags & lightMask) ){\n\t\t\t//debugger;\n\t\t\t//console.log(\"no light\");\n\t\t\tfinalMaterial =  new THREE.MeshBasicMaterial({\n\t\t\t\tside: THREE.FrontSide,\n\t\t\t\tmap: finalMaterial.map\n\t\t\t});\n\n\t\t}\n\t\t\n\t\tif(grChunk.data.flags!=16460){\n\t\t\tfinalMaterial.alphaTest = 0.05;\n\t\t}\n\n\n\t}/// End if material\n\t\n\n\treturn finalMaterial;\n\n}\n\n\n/**\n * Load image data into a THREE.Texture from a texture file in the .dat file, using a LocalReader.\n * Any loaded tetures are added to sharedTextures, allowing for texture caching and fewer reads.\n * \n * @method  getTexture\n * @param  {Number} texURL         The fileId or baseId of the file to load image data from.\n * @param  {LocalReader} localReader    The LocalReader to load the file contents from.\n * @param  {Object} sharedTextures Value Object for keeping the texture cache\n * @return {THREE.Texture} A texture that will be populated by the file data when it is loaded.\n */\nvar getTexture = ME.getTexture = function(texURL, localReader, sharedTextures){\n\n\tvar finalTexture;\n\n\t/// Read texture from shared array of loaded textures\n\t/// or read it from URL and add to shared ones!\t\t\t\n\tif(texURL && sharedTextures[texURL]){\n\n\t\t/// Just read from already loaded textures.\n\t\tfinalTexture = sharedTextures[texURL];\n\n\t}\n\telse if(texURL){\n\n\t\t/// Load and add to shared array.\n\t\tfinalTexture = loadLocalTexture(localReader,texURL);\n\n\t\t/// Set standard texture functionality.\n\t\tfinalTexture.wrapT = THREE.RepeatWrapping;\n\t\tfinalTexture.wrapS = THREE.RepeatWrapping;\n\t\tfinalTexture.flipY = false;\n\n\t\tsharedTextures[texURL] = finalTexture;\n\t}\n\n\treturn finalTexture;\n}\n\n\n\n/**\n * Load image data into a THREE.Texture from a texture file in the .dat file, using a LocalReader.\n * If you're loading multiple textures, make sure to use\n * {{#crossLink \"MaterialUtils/getTexture\"}}{{/crossLink}} that allows you to cache textures.\n * \n * @method loadLocalTexture\n * @param {LocalReader} localReader - The LocalReader to load the file contents from.\n * @param {Number} fileId - The fileId or baseId of the file to load image data from.\n * @param {Number} mapping - What THREE mapping the returned texture will use, not implemented.\n \n * @return {THREE.Texture} A texture that will be populated by the file data when it is loaded.\n */\nvar loadLocalTexture = ME.loadLocalTexture = function(localReader, fileId, mapping, defaultColor, onerror){\n\t\n\tif(defaultColor === undefined){\n\t\tdefaultColor = Math.floor( 0xffffff * Math.random() )\n\t}\n\n\t/// Temporary texture that will be returned by the function.\n\t/// Color is randomized in order to differentiate different textures during loading.\n\tvar texture =  generateDataTexture(\n\t\t1, // Width\n\t\t1, // Height\n\t\tnew THREE.Color( defaultColor ) // Color\n\t);\n\n\t//Threejs r71 is using these settings by default, r72+ changed it\n\ttexture.minFilter = THREE.LinearMipMapLinearFilter;\n\ttexture.magFilter = THREE.LinearFilter;\n\ttexture.generateMipmaps = true;\n\ttexture.flipY = true;\n\n\t/// Only allow non-zero fileId, otherwise jsut return static texture\n\tif( parseInt(fileId) <= 0 ){\n\t\tif(onerror)\n\t\t\tonerror();\n\t\treturn texture;\n\t}\n\n\t/// Load file using LocalReader.\n\tlocalReader.loadTextureFile(fileId,\n\t\tfunction(inflatedData, dxtType, imageWidth, imageHeigth){\n\n\t\t\t/// Require infalted data to be returned.\n\t\t\tif(!inflatedData){\n\t\t\t\tif(onerror)\n\t\t\t\t\tonerror();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/// Create image using returned data.\n\t\t\tvar image = {\n\t\t\t\tdata   : new Uint8Array(inflatedData),\n\t\t\t\twidth  : imageWidth,\n\t\t\t\theight : imageHeigth\n\t\t\t};\n\n\t\t\t/// Use RGBA for all textures for now...\n\t\t\t/// TODO: don't use alpha for some formats!\n\t\t\ttexture.format = (dxtType==3 || dxtType==5 || true) ? THREE.RGBAFormat : THREE.RGBFormat;\n\n\t\t\t/// Update texture with the loaded image.\n\t\t\ttexture.image = image;\n\t\t\ttexture.needsUpdate = true;\n\t\t}\n\t);\t\n\n\t/// Return texture with temporary content.\n\treturn texture;\n};","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * Collection Math and sorting methods\n * @Class MathUtils\n * @static\n */\nvar ME = module.exports = {};\n\n/**\n * Takes an integer and calculates what the 16 bit float\n * representation of the binary data used to read the integer is.\n * @method f16\n * @param  {Number} h Integer value\n * @return {Number} Float value\n */\nME.f16 = function(h) {\n    var s = (h & 0x8000) >> 15;\n    var e = (h & 0x7C00) >> 10;\n    var f = h & 0x03FF;\n\n    if(e == 0) {\n        return (s?-1:1) * Math.pow(2,-14) * (f/Math.pow(2, 10));\n    } else if (e == 0x1F) {\n        return f?NaN:((s?-1:1)*Infinity);\n    }\n\n    return(s?-1:1) * Math.pow(2, e-15) * (1+(f/Math.pow(2, 10)));\n}\n\n\n/**\n * Calculates the number of binary ones present in the data used to\n * generate the input integer.\n * @method popcount\n * @param  {Number} bits Integer\n * @return {Number}      Number of binary ones in the data\n */\nME.popcount = function(bits) {\n  var SK5  = 0x55555555,\n      SK3  = 0x33333333,\n      SKF0 = 0x0f0f0f0f,\n      SKFF = 0xff00ff;\n\n  bits -= (bits >> 1) & SK5;\n  bits  = (bits & SK3) + ((bits >> 2) & SK3);\n  bits  = (bits & SKF0) + ((bits >> 4) & SKF0);\n  bits += bits >> 8;\n\n  return (bits + (bits >> 15)) & 63;\n}\n\n\n/**\n * Calculates the 64 bit integer value of two 32 bit integers. Only works up to \n * the limit of the javascript Number maximum value.\n * @method arr32To64\n * @param  {Number[]} arr     Input integers, length should be 2.\n * @return {Number}      64 bit representation of the two integers.\n */\nvar base32Max = Math.pow(2,32);\nME.arr32To64 = function(arr){\n  /// Re-read as uint64 (still little endian)\n  /// Warn: this will not work for ~50+ bit longs cus all JS numbers are 64 bit floats...\n  return base32Max*arr[1] + arr[0];\n};\n\n\n/**\n * Sorts an array and returns unique values only.\n * @method  sort_unique\n * @param  {Array} arr_in     Input array\n * @param  {Function} comparator A comparator function between the objects in arr_in\n * @return {Array}            Sorted and unique value.\n */\nME.sort_unique = function(arr_in, comparator) {\n  var arr = Array.prototype.sort.call(arr_in, comparator);\n   \n    var u = {}, a = [];\n    for(var i = 0, l = arr.length; i < l; ++i){\n      if(u.hasOwnProperty(arr[i])) {\n        continue;\n      }\n      a.push(arr[i]);\n      u[arr[i]] = 1;\n  }\n\n  return a;\n}","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * Collection of methods used for parsing complex data types from the .dat\n *\n * Most of these methods are only refered by the automatically generated script\n * AllFormats.js\n * \n * @Class ParserUtils\n * @static\n */\n\nmodule.exports = {\n\n\t/**\n\t * Generates a function for reading an array using DataStream\n\t * @method  getArrayReader\n\t * @param  {Array} structDef DataStream formatted structure definition\n\t *                           for the items in the array.\n\t * @param  {Number} maxCount The maximum allowed length of the array.\n\t *                           Allows any length if left unspecified.\n\t * @return {Function}        The generated parsing function.\n\t */\n\tgetArrayReader : function(structDef, maxCount){\n\t\treturn function(ds, struct){\n\t\t\tvar ret = [];\n\t\t\ttry{\n\n\t\t    \tvar arr_len = ds.readUint32();\n\t\t    \tvar offset = ds.readUint32(); \n\t\t\t\tif(offset == 0){\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\tvar arr_ptr = ds.position -4 + offset;\n\t\t    \tvar pos = ds.position;\t   \n\n\t\t    \tif(maxCount && arr_len > maxCount){\n\t\t    \t\tthrow(\"Array length \"+arr_len+\" exceeded allowed maximum \" + maxCount);\n\t\t    \t}\n\n\t\t    \tvar pos = ds.position;   \t\n\t\t    \t\n\t    \t\n\t\t    \tds.seek( arr_ptr );\n\t\t    \tret = ds.readType (['[]',structDef,arr_len], struct);\n\t\t    \tds.seek(pos);\n\t    \t}\n\t    \tcatch(e){\n\t    \t\tconsole.warn(\"getArrayReader Failed loading array\", e);\n\t    \t\tconsole.warn(\"getArrayReader Failed loading array, structDef\", structDef);\n\t    \t}\n\t    \treturn ret;\n\t    }\n\t},\n\n\t/**\n\t * Generates a function for reading a refered array using DataStream\n\t * @method  getRefArrayReader\n\t * @param  {Array} structDef DataStream formatted structure definition\n\t *                           for the items in the array.\n\t * @return {Function}        The generated parsing function.\n\t */\n\tgetRefArrayReader : function(structDef){\n\t\treturn function(ds, struct){\n\t    \t\n\t    \tvar ret_arr=[];\n\n\t    \t/// Read array of offsets\n\t    \tvar arr_len = ds.readUint32();\n\t\t    var arr_ptr = ds.position + ds.readUint32();\n\n\t    \tif(arr_len==0){\n\t    \t\treturn ret_arr;\n\t    \t}\n\n\t    \tvar orgPos = ds.position;\n\n\t    \t/// Go to pointer and read an array of offsets!\n\t    \tds.seek(arr_ptr);\n\t    \tvar offsets = ds.readInt32Array(arr_len);\t\n\n\n\t    \t//p_data is after having read array\n\t    \t//var pointer = p_data - 4;\n\t    \tvar pointer = orgPos -4;\n\n        \t//auto offset  = *reinterpret_cast<const int32*>(pointer);\n        \tds.seek(pointer);\n        \tvar offset = ds.readUint32(); /// this should be the same as arr_ptr\n        \t\n        \t//pointer     += offset;\n        \tpointer +=offset;\n\n\t    \tfor(var i=0;i<offsets.length;i++){\n\n\t    \t\t\n\t    \t\tif(offsets[i] != 0){\n\n\t    \t\t\tvar pos = pointer + i * 4 + offsets[i];\n\t\t    \t\tds.seek(pos);\n\n\t\t    \t\ttry{\n\t\t    \t\t\tret_arr.push(ds.readStruct(structDef));\t\n\t\t    \t\t}\n\t\t    \t\tcatch(e){\n\t\t    \t\t\t//debugger;\n\t\t    \t\t\tret_arr.push(null);\n\t\t    \t\t\tconsole.warn(\"getRefArrayReader could not find refered data at offset\",offsets[i] ,e);\n\t\t    \t\t}\n\n\t    \t\t}\n\t    \t\t\n\t    \t}/// End for each offset\n\n\t    \tds.seek(orgPos);\n\t    \treturn ret_arr;\n\n\n\t    }\n\t},\n\n\n\t/**\n\t * Generates a function for reading a 64bit initeger. For now just reads each\n\t * 32 bit integer and glues together as a string.\n\t * @method  getQWordReader\n\t * @return {Function}        The generated parsing function.\n\t */\n\tgetQWordReader:function(){\n\t\tvar base32Max = 4294967296;\n\t\treturn function(ds, struct){\n\t\t\treturn ds.readUint32()+\"-\"+ds.readUint32();\n\n\t\t\tvar p0= ds.readUint32();\n\t\t\tvar p1= ds.readUint32();\n\t\t\treturn base32Max*p1 + p0;\n\t\t}\n\t\t\n\t},\n\t\n\t/**\n\t * Generates a function for reading a string of 8 bit chars.\n\t * @method  getStringReader\n\t * @return {Function}        The generated parsing function.\n\t */\n\tgetStringReader : function(){\n\t\treturn function(ds, struct){\n\t\t\tvar ptr = ds.position + ds.readUint32();\n\t    \tvar pos = ds.position;\t    \t\n\n\t    \t/// Go to pointer\n\t    \tds.seek( ptr );\n\n\t    \tvar ret = ds.readCString();\n\n\t\t\t/// Go back to where we were\n\t    \tds.seek( pos );\n\n\t    \treturn ret;\n\t    }\n\t},\n\n\t/**\n\t * Generates a function for reading a string of 16 bit chars.\n\t * @method  getString16Reader\n\t * @return {Function}        The generated parsing function.\n\t */\n\tgetString16Reader : function(stringOffset){\n\t\treturn function(ds, struct){\n\t\t\tvar ptr = ds.position + ds.readUint32() + (stringOffset ? stringOffset : 0);\n\t    \tvar pos = ds.position;\t    \t\n\n\t    \t/// Go to pointer\n\t    \tds.seek( ptr );\n\n\t    \tvar ret = \"\";\n\t    \tvar num;\n\t    \twhile(ds.position+2<ds.byteLength && (num = ds.readUint16()) != 0 ){\n\t    \t\tret += String.fromCharCode(num);\n\t    \t}\n\t    \t//ds.readCString();\n\n\t\t\t/// Go back to where we were\n\t    \tds.seek( pos );\n\n\t    \treturn ret;\n\t    }\n\t},\n\n\n\t/**\n\t * Generates a function for reading a pointer.\n\t * @method getPointerReader\n\t * @param  {Array} structDef DataStream formatted structure definition\n\t *                           for the item pointed to.\n\t * @return {Function}        The generated parsing function.\n\t */\n\tgetPointerReader : function(structDef){\n\t\treturn function(ds, struct){\n\t\t\tvar offset = ds.readUint32(); \n\n\t\t\tif(offset == 0){\n\t\t\t\treturn {};\n\t\t\t}\n\n\t\t\tvar ptr = ds.position -4 + offset;\n\t    \tvar pos = ds.position;\t    \t\n\n\t    \t/// Go to pointer\n\t    \tds.seek( ptr );\n\t    \t\n\t    \tvar ret = ds.readStruct(structDef);\n\n\t\t\t/// Go back to where we were\n\t    \tds.seek( pos );\n\n\n\t    \treturn ret;\n\t    }\n\t},\n\n\t/**\n\t * Generates a function for reading a filename/file Id.\n\t * @method  getFileNameReader\n\t * @return {Function}        The generated parsing function.\n\t */\n\tgetFileNameReader : function(){\n\t\treturn function(ds, struct){\n\t\t\ttry{\n\t\t\t\tvar ptr = ds.position + ds.readUint32();\n\t    \t\tvar pos = ds.position;\t    \t\n\t    \t\n\t\t    \t/// Go to pointer\n\t\t    \tds.seek( ptr );\n\n\t\t    \tvar fileRef = ds.readStruct([\n\t\t    \t\t\"m_lowPart\", \"uint16\", //uint16 m_lowPart;\n\t\t\t\t    \"m_highPart\", \"uint16\", //uint16 m_highPart;\n\t\t\t\t    \"m_terminator\", \"uint16\",//uint16 m_terminator;\n\t\t\t\t]);\n\n\n\t\t\t\t/// Getting the file name...\n\t\t\t\t/// Both need to be >= than 256 (terminator is 0)\n\t\t\t\tvar ret = 0xFF00 * (fileRef.m_highPart - 0x100) + (fileRef.m_lowPart - 0x100) + 1;\n\t\t\t\t//var ret = (fileRef.m_highPart - 0x100) * 0xff00 + (fileRef.m_lowPart - 0xff);\n\n\t\t\t\tif(ret<0){\n\t\t\t\t\tret = 0;\n\t\t\t\t\t//console.log(\"FR negative\", fileRef.m_highPart, fileRef.m_lowPart, fileRef.m_terminator);\n\t\t\t\t\t//debugger;\n\t\t\t\t}\n\n\t\t    \t/// Go back to where we were\n\t\t    \tds.seek( pos );\n\n\t\t    \treturn ret;\n\t    \t}\n\t    \tcatch(e){\n\t    \t\t/// Go back to where we were\n\t\t    \tds.seek( pos );\n\n\t\t    \treturn -1;\n\t    \t}\t    \t\n\t    }\n\t}\n}","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * Todo doc\n */\n\n\n/**\n * @function\n * @param   {Array}     array           Array to iterate over\n * @param   {Function}  promiseTask     Working function on the element that returns a promise\n * @param   {Number}    limit           Amount of simultaneously spawned promises\n * @param   {String}    logPrefix       Progress prefix\n * @returns {Promise}   Return a promise that resolves when it has done iterating over\n */\nfunction limitedAsyncIterator(array, promiseTask, limit, logPrefix){\n    return new Promise((resolve, reject) => {\n        let index = 0;\n        let returned = 0;\n    \n        function startNewPromise(){\n            //Progress:\n            if(logPrefix)\n                progress(index, array.length, logPrefix);\n\n            //Continues iterating as long as we're in the range of the array\n            if(index<array.length){\n                //Tasks are supposed to handle their faults, it will spawn a new task\n                //either way if it resolves or rejects\n                promiseTask(array[index], index)\n                    .then(startNewPromise)\n                    .catch(startNewPromise);\n                index += 1;\n            } else {\n                returned += 1;\n                //Wait for the last promise to return\n                if(returned == limit)\n                    resolve();\n            }\n        }\n\n        //Start the first promise\n        for(let p = 0; p<limit; p++)\n            startNewPromise();\n    \n    })\n}\n\nfunction progress(done, amount, prefix){\n    done += 1;\n    //Call at every percent\n    if(done%Math.floor(amount/100) == 0) {\n        T3D.Logger.log(T3D.Logger.TYPE_PROGRESS,\n            prefix, done/Math.floor(amount/100))\n    }\n\n    return done;\n}\n\nmodule.exports = {\n    limitedAsyncIterator: limitedAsyncIterator\n}","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * Collection of methods used for generating THREE meshes from Guild Wars 2 data formats.\n * @Class RenderUtils\n * @static\n */\n\nvar GW2File = require(\"../format/file/GW2File\");\nvar MaterialUtils = require(\"./MaterialUtils\");\nvar MathUtils = require(\"./MathUtils\");\n\n\n//TODO: Remove this local cache!!\nvar matFiles = {};\n\n/**\n * Object describing the meaning of the bits in fvf integers.\n * @property fvfFormat\n * @private\n * @type {Object}\n */\nvar fvfFormat = {\n\tPosition              : 0x00000001,   /**< 12 bytes. Position as three 32-bit floats in the order x, y, z. */\n\tWeights               : 0x00000002,   /**< 4 bytes. Contains bone weights. */\n    Group                 : 0x00000004,   /**< 4 bytes. Related to bone weights. */\n    Normal                : 0x00000008,   /**< 12 bytes. Normal as three 32-bit floats in the order x, y, z. */\n    Color                 : 0x00000010,   /**< 4 bytes. Vertex color. */\n    Tangent               : 0x00000020,   /**< 12 bytes. Tangent as three 32-bit floats in the order x, y, z. */\n    Bitangent             : 0x00000040,   /**< 12 bytes. Bitangent as three 32-bit floats in the order x, y, z. */\n    TangentFrame          : 0x00000080,   /**< 12 bytes. */\n    UV32Mask              : 0x0000ff00,   /**< 8 bytes for each set bit. Contains UV-coords as two 32-bit floats in the order u, v. */\n    UV16Mask              : 0x00ff0000,   /**< 4 bytes for each set bit. Contains UV-coords as two 16-bit floats in the order u, v. */\n    Unknown1              : 0x01000000,   /**< 48 bytes. Unknown data. */\n    Unknown2              : 0x02000000,   /**< 4 bytes. Unknown data. */\n    Unknown3              : 0x04000000,   /**< 4 bytes. Unknown data. */\n    Unknown4              : 0x08000000,   /**< 16 bytes. Unknown data. */\n    PositionCompressed    : 0x10000000,   /**< 6 bytes. Position as three 16-bit floats in the order x, y, z. */\n    Unknown5              : 0x20000000,   /**< 12 bytes. Unknown data. **/\n};\n\nvar ME = module.exports = {};\n\n/**\n * Creates a mesh representing a single plane.\n * \n * @method  renderRect\n * @param  {Object} rect     An object with x1,x2,y1 and y2 properties.\n * @param  {Number} yPos     Vertical position of the rectangle.\n * @param  {THREE.Material} material \tMesh material to apply.\n * @param  {Number} dy       Mesh height.\n * @return {THREE.Mesh}      The generated mesh.\n */\nvar renderRect = ME.renderRect = function(rect, yPos, material, dy){\n\tvar dx = rect.x1 - rect.x2;\n\tvar dz = rect.y1 - rect.y2;\n\tif(!dy)\n\t\tdy = 1;\n\n\tvar cx = (rect.x1 + rect.x2)/2;\n\tvar cz = (rect.y1 + rect.y2)/2;\n\tvar cy = yPos;\n\n\tvar geometry = new THREE.BoxGeometry( dx, dy, dz );\n\n\n\tmaterial = material || new THREE.MeshBasicMaterial(\n\t\t{\n\t\t \tcolor: 0xff0000,\n\t\t\twireframe:true,\n\t\t}\n\t);\n\tvar plane = new THREE.Mesh( geometry, material );\n\tplane.overdraw = true;\n\t\n\tplane.position.x = cx;\n\tplane.position.y = cy;\n\tplane.position.z = cz;\n\n\treturn plane;\n};\n\n\n/**\n * Load image data into a THREE.Texture from a file within the GW2 .dat file using a LocalReader.\n *\n * @method loadLocalTexture\n * \n * @param {LocalReader} localReader The LocalReader to load the file contents from.\n * @param {Number} fileId The fileId or baseId of the file to load image data from.\n * @param {Number} mapping What THREE mapping the returned texture will use, not implemented.\n * @param  {Array} defaultColor RGBA array of 4 integers. The default solid color of the mesh, should texture loading fail.\n * @param {Function} onerror Error callback, not implemented.\n * \n * @return {THREE.Texture} A texture that will be populated by the file data when it is loaded.\n */\nvar loadLocalTexture = ME.loadLocalTexture = function(localReader, fileId, mapping, defaultColor, onerror){\n\treturn MaterialUtils.loadLocalTexture(localReader, fileId, mapping, defaultColor, onerror);\n};\n\n/**\n* Returns a THREE representation of the data contained by a GW2 model file.\n* The data is read using a LocalReader reference into the GW2 .dat.\n*\n* @method renderGeomChunk\n* \n* @param {LocalReader} localReader The LocalReader to load the file contents from.\n* @param {Object} chunk Model GEOM chunk.\n* @param {Object} modelDataChunk Model MODL chunk.\n* @param {Object} sharedTextures  Value Object for keeping the texture cache.\n* @param {boolean} showUnmaterialed If false does not render any models with missing materials.\n* \n* @return {Array} Each geometry in the model file represented by a textured THREE.Mesh object\n*/\nvar renderGeomChunk = ME.renderGeomChunk = function(localReader, chunk, modelDataChunk, sharedTextures, showUnmaterialed){\n\n\tvar rawMeshes = chunk.data.meshes;\n\tvar meshes = [];\n\tvar mats = modelDataChunk.data.permutations[0].materials;\n\t\n\trawMeshes.forEach(function(rawMesh){\n\n\t\tvar rawGeom = rawMesh.geometry;\n\t\tvar fvf = rawGeom.verts.mesh.fvf;//rawGeom.fvf;\n\n\t\tvar numVerts = rawGeom.verts.vertexCount;//rawGeom.vertexCount;\n\t\t\n\t\tvar rawVerts = rawGeom.verts.mesh.vertices;//rawGeom.vertices\n\n\t\tvar indices = rawGeom.indices.indices;\n\n\t\tvar geom = new THREE.BufferGeometry();\n\n\t\tvar vertDS =  new DataStream(rawVerts.buffer);\n\n\t\t//Dirty step length for now:\n\t\tvar stride = rawVerts.length / numVerts;\n\n\t\t//Each vertex\n\t\t//DO UV as well\n\t\tvar vertices = new Float32Array( numVerts * 3 );\n\t\tvar tangents = null; \n\t\tvar normals = null;\n\t\tvar uvs = []; \n\t\t\n\n\t\t/// Calculate the distance to the first pair of UV data from the\n\t\t/// start of the vertex entry\n\t\t/// \n\t\tvar distToNormals = \n\t\t\t!!(fvf & fvfFormat.Position) \t\t* 12 +\n\t\t\t!!(fvf & fvfFormat.Weights) \t\t*  4 +\n\t\t\t!!(fvf & fvfFormat.Group) \t\t\t*  4 ;\n\n\t\tvar distToTangent = \n\t\t\tdistToNormals\t\t\t\t\t\t\t +\n\t\t\t!!(fvf & fvfFormat.Normal) \t\t\t* 12 +\n\t\t\t!!(fvf & fvfFormat.Color) \t\t\t*  4;\n\n\t\tvar distToBittangent = \n\t\t\tdistToTangent\t\t\t\t\t\t +\n\t\t\t!!(fvf & fvfFormat.Tangent) \t\t* 12;\n\n\t\tvar distToTangentFrame = distToBittangent\t +\n\t\t\t!!(fvf & fvfFormat.Bitangent) \t\t* 12;\n\n\t\tvar distToUV = \n\t\t\tdistToTangentFrame\t\t\t\t\t\t +\n\t\t\t!!(fvf & fvfFormat.TangentFrame) \t* 12;\n\n\t\t/// Check if the UV is 32 bit float or 16 bit float.\n\t\tvar uv32Flag = (fvf & fvfFormat.UV32Mask) >> 8;\n\t\tvar uv16Flag = (fvf & fvfFormat.UV16Mask) >> 16;\n\t\tvar isUV32 = !!uv32Flag;\n\t\tvar hasUV = !!uv16Flag || !!uv32Flag;\n\t\t\n\t\t/// Popcount (count the number of binary 1's) in the UV flag\n\t\t/// to get the number of UV pairs used in this vertex format.\n\t\tvar masked = isUV32 ? uv32Flag : uv16Flag;\n\t\tvar numUV = MathUtils.popcount(masked);\n\n\t\tnumUV = Math.min(numUV,1.0);\n\n\n\t\t/// Create typed UV arrays\n\t\tif(hasUV){\n\t\t\tfor(var i=0; i<numUV; i++){\n\t\t\t\tuvs[i] = new Float32Array( numVerts * 2 );\n\t\t\t}\n\t\t}\n\t\t\n\n\t\t\n\t\n\t\tif( !!(fvf & fvfFormat.Normal) ){\n\t\t\t\n\t\t\t//console.log(\"HAS Normal\");\n\n\t\t}\n\t\n\t\tif( !!(fvf & fvfFormat.Tangent) ){\n\t\t\t\n\t\t\t//console.log(\"HAS Tangent\");\n\n\t\t}\n\n\t\tif( !!(fvf & fvfFormat.Bitangent) ){\n\t\t\t\n\t\t\t//console.log(\"HAS Bitangent\");\n\n\t\t}\n\t\tif( !!(fvf & fvfFormat.TangentFrame) ){\n\t\t\t\n\t\t\t//console.log(\"HAS TangentFrame\");\n\n\t\t}\n\n\t\t/// Read data from each vertex data entry\n\t\tfor(var i=0; i<numVerts; i++){\n\n\t\t\t/// Go to vertex memory position\n\t\t\tvertDS.seek(i*stride);\n\n\t\t\t/// Read position data\n\t\t\t/// (we just hope all meshes has 32 bit position...)\n\t\t\tvar x = vertDS.readFloat32();\n\t\t\tvar z = vertDS.readFloat32();\n\t\t\tvar y = vertDS.readFloat32();\n\n\t\t\t/// Write position data, transformed to Tyria3D coordinate system.\n\t\t\tvertices[i*3 + 0] =  x ;//- c.x;\n\t\t\tvertices[i*3 + 1] = -y ;//+ c.y;\n\t\t\tvertices[i*3 + 2] = -z ;//+ c.z;\n\n\t\t\t/// Read data at UV position\n\t\t\tif(hasUV){\n\t\t\t\t\n\t\t\t\tfor(var uvIdx=0; uvIdx<numUV; uvIdx++){\n\n\t\t\t\t\tvertDS.seek(\n\t\t\t\t\t\ti*stride + \n\t\t\t\t\t\tdistToUV + \n\t\t\t\t\t\tuvIdx*(isUV32 ? 8 : 4)\n\t\t\t\t\t);\n\n\t\t\t\t\t/// Add one UV pair:\n\t\t\t\n\t\t\t\t\tvar u,v;\n\t\t\t\t\tif(isUV32){\n\t\t\t\t\t\tu = vertDS.readUint32();\n\t\t\t\t\t\tv = vertDS.readUint32();\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tu = MathUtils.f16(vertDS.readUint16());\n\t\t\t\t\t\tv = MathUtils.f16(vertDS.readUint16());\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\t/// Push to correct UV array\n\t\t\t\t\tuvs[uvIdx][i*2 + 0] = u;\n\t\t\t\t\tuvs[uvIdx][i*2 + 1] = v;\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t} /// End if has UV\n\t\t\t\t\n\n\t\t\t\n\n\t\t} /// End each vertex\n\n\t\t/// Each face descripbed in indices\n\t\tvar faces = new Uint16Array( indices.length );\t\t\n\t\tfor(var i=0; i<indices.length; i+=3){\n\n\t\t\t// This is ONE face\n\t\t\tfaces[i + 0] = indices[i + 2];\n\t\t\tfaces[i + 1] = indices[i + 1];\n\t\t\tfaces[i + 2] = indices[i + 0];\n\n\t\t}// End each index aka \"face\"\n\n\n\t\t/// Add position, index and uv props to buffered geometry\n\t\tgeom.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\n\t\t//geom.addAttribute( 'index', new THREE.BufferAttribute( faces, 1) );\n\t\tgeom.setIndex(new THREE.BufferAttribute(faces, 1));\n\n\t\tif(normals){\n\t\t\tconsole.log(\"adding normals\");\n\t\t\tgeom.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\n\t\t\tgeom.normalizeNormals();\n\t\t\tgeom.normalsNeedUpdate = true;\n\t\t}\n\t\telse{\n\t\t\t/// Calculate normals\n\t\t\tgeom.computeVertexNormals();\n\t\t}\n\n\t\t\n\t\tif(hasUV){\n\n\t\t\tfor(var uvIdx=0; uvIdx<numUV; uvIdx++){\n\n\t\t\t\t/// Names are \"uv\", \"uv2\", \"uv3\", ... , \"uvN\"\n\t\t\t\tvar uvName = \"uv\" + ( uvIdx > 0 ? uvIdx+1 : \"\" );\n\t\t\t\t\n\t\t\t\t/// Set \"custom\" attribute uvN\n\t\t\t\tgeom.addAttribute( uvName, new THREE.BufferAttribute( uvs[uvIdx], 2 ) );\n\n\t\t\t\t/// Flag for update\n\t\t\t\tgeom.attributes[uvName].needsUpdate = true;\t\n\t\t\t}\n\t\t\t\n\n\t\t\t/// Not needed anymore?\n\t\t\tgeom.uvsNeedUpdate = true;\t\n\t\t}\n\t\t\n\n\t\t/// Tell geometry to update its UVs and buffers\n\t\tgeom.buffersNeedUpdate = true;\n\n\t\t/// DONE READING VERTEX DATA\n\t\t\n\n\t\t/// Get material used for this mesh\n\t\tvar matIdx = rawMesh.materialIndex;\n\t\tvar mat = mats[matIdx];\n\t\tvar materialFile = null\n\n\t\tif(mat && matFiles[mat.filename]){\n\t\t\tmaterialFile = matFiles[mat.filename];\t\t\t\n\t\t}\n\n\t\tvar finalMaterial =  MaterialUtils.getMaterial(mat, materialFile, localReader, sharedTextures);\t\n\t\n\n\t\t/// IF we could not find a material abort OR use a wireframe placeholder.\n\t\tif(!finalMaterial){\n\t\t\tif(showUnmaterialed){\n\t\t\t\tfinalMaterial = new THREE.MeshLambertMaterial(\n\t\t\t\t\t{\n\t\t\t\t\t\tcolor: 0x5bb1e8,\n\t\t\t\t\t\twireframe:false,\n\t\t\t\t\t\tside: THREE.DoubleSide\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\t\t\telse{\n\t\t\t\treturn;\t\n\t\t\t}\t\t\t\n\t\t}\n\n\t\t\n\n\t\t/// Create the final mesh from the BufferedGeometry and MeshBasicMaterial\n\t\tvar finalMesh = new THREE.Mesh(geom, finalMaterial);\n\n\t\t\n\t\t/// Set material info on the returned mesh\n\t\tif(mat){\n\t\t\tfinalMesh.materialFlags = mat.materialFlags;\n\t\t\tfinalMesh.materialFilename = mat.filename;\n\t\t}\n\n\t\tfinalMesh.materialName = rawMesh.materialName;\n\n\t\t/// Use materialFilename, materialName, and material.textureFilename in order to build export\n\n\t\t/// Set lod info on the returned mesh\n\t\tfinalMesh.numLods = rawMesh.geometry.lods.length;\n\t\tfinalMesh.lodOverride = modelDataChunk.data.lodOverride;\n\n\t\t/// Set flag and UV info on the returned mehs\n\t\tfinalMesh.flags = rawMesh.flags;\n\t\tfinalMesh.numUV = numUV;\n\n\t\t/// Add mesh to returned Array\n\t\tmeshes.push( finalMesh );\n\n\t});/// End rawMeshes forEach\n\t\n\treturn meshes;\t\n};\n\n/**\n * Loads mesh array from Model file and sends as argument to callback.\n * @method loadMeshFromModelFile\n * @param  {Number} filename Name of the model file to load data from.\n * @param  {Array} solidColor RGBA array of 4 integers\n * @param {LocalReader} localReader The LocalReader to load the file contents from.\n * @param {Object} sharedTextures  Value Object for keeping the texture cache.\n * @param {boolean} showUnmaterialed If false does not render any models with missing materials.\n \n * @param  {Function} callback Fired once all meshes have been loaded.\n * two arguments are passed to the callback function.\n * \n * The first argument is an Array with each textured THREE.Mesh objects.\n * \n * The second argument is the bounding spehere of this model file.\n * \n */\n\nvar loadMeshFromModelFile = ME.loadMeshFromModelFile =\nfunction(filename, solidColor, localReader, sharedTextures, showUnmaterialed, callback){\n\n\t//Short handles prop attributes\n\tvar finalMeshes = [];\n\n\t///Load file\n\tlocalReader.loadFile(filename,function(inflatedData){\n\t\ttry{\n\t\t\tif(!inflatedData){\n\t\t\t\tthrow \"Could not find MFT entry for \"+filename;\n\t\t\t}\n\n\t\t\tvar ds = new DataStream(inflatedData);\n\n\t\t\tvar modelFile = new GW2File(ds,0);\n\n\t\t\t//MODL for materials -> textures\n\t\t\tvar modelDataChunk = modelFile.getChunk(\"modl\");\n\t\t    \n\t\t    //GEOM for geometry\n\t\t    var geometryDataChunk = modelFile.getChunk(\"geom\");\n\n\n\t\t    /// Hacky fix for not being able to adjust for position\n\t\t    var boundingSphere = modelDataChunk.data.boundingSphere;\n\t\t    var bsc = boundingSphere.center;\n\t\t    boundingSphere.radius+= Math.sqrt( bsc[0]*bsc[0] + Math.sqrt(bsc[1]*bsc[1] + bsc[2]*bsc[2]) );\n\n\t\t    /// Load all material files\n\t\t    var allMats = modelDataChunk.data.permutations[0].materials;\n\n\t\t    function loadMaterialIndex(mIdx, matCallback){\n\t\t    \t\n\t\t    \tif(mIdx>=allMats.length){\n\t\t    \t\t\n\t\t    \t\tmatCallback();\n\t\t    \t\treturn;\n\t\t    \t}\n\n\t\t    \tvar mat = allMats[mIdx];\n\n\t\t    \t/// Skip if file is loaded\n\t\t    \tif(matFiles[mat.filename]){\n\t\t    \t\tloadMaterialIndex(mIdx+1,matCallback);\n\t\t    \t\treturn;\n\t\t\t\t}\t\t\n\n\t\t\t\tlocalReader.loadFile(mat.filename,\n\t\t\t\t\tfunction(inflatedData){\n\t\t\t\t\t\tif(inflatedData){\n\t\t\t\t\t\t\tvar ds = new DataStream(inflatedData);\n\t\t\t\t\t\t\tvar materialFile = new GW2File(ds,0);\n\t\t\t\t\t\t\tmatFiles[mat.filename] = materialFile;\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tloadMaterialIndex(mIdx+1,matCallback);\t\n\t\t\t\t\t\t\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t);\n\t\t    }\n\n\n\n\t\t    loadMaterialIndex(0, function(){\n\n\t\t    \t/// Create meshes\n\t\t\t    var meshes = renderGeomChunk(localReader, geometryDataChunk, modelDataChunk, sharedTextures, showUnmaterialed);\t\t\t    \n\n\t\t\t    // Build mesh group\n\t\t\t    meshes.forEach(function(mesh){\n\t\t\t    \t\n\t\t\t    \t/// Material flags\n\t\t\t    \tvar knownflags = [\n\n\t\t\t    \t\t/*\n\t\t\t\t\t\t\t1-5\n\t\t\t\t\t\t\tHas Tex?\tIDK\t\t\tLight?\t\tAlpha?\n\n\t\t\t\t\t\t\t5-8\n\t\t\t\t\t\t\t0\t\t\t0\t \t\tIDK\t\t \tWater?\n\n\t\t\t\t\t\t\t9-12\n\t\t\t\t\t\t\tHas Tex?\t0\t\t\tAlpha?\t\tAlpha?\n\n\t\t\t\t\t\t\t13\n\t\t\t\t\t\t\tIDK KEV\n\t\t\t    \t\t*/\n\n\t\t\t    \t\t0,\t\t\t//0 0000 0000 0000\t\tGround / Wall splashes\n\t\t\t    \t\t8,\t\t\t//0 0000 0000 1000\t\tBroken Khylo roof DDS\n\t\t\t    \t\t9,\t\t\t//0 0000 0000 1001\t\tTree leaves\n\n\t\t\t    \t\t520,\t\t//0 0010 0000 1000\t\tSome LOD modules, fires, smoke, inside of tents (some DSS textures)\n\t\t\t    \t\t\n\n\t\t\t    \t\t2056,\t\t//0 1000 0000 1000\t\tSolid objects, also broken animations\n\n\t\t\t    \t\t///Solids here are unhappy, or are they? could be animations etc\n\t\t\t    \t\t2057,\t\t//0 1000 0000 1001\t\tWindmill sails, bushes, trees, but also a statue and a few pieces of wall\n\n\t\t\t    \t\t2060,\t\t//0 1000 0000 1100\t\tA few solid objects, like wooden barricades, one(!) painting\n\t\t\t    \t\t2061,\t\t//0 1000 0000 1101\t\tA few bushes, two paintings\n\t\t\t    \t\t\n\t\t\t    \t\t\n\t\t\t    \t\t2312,\t\t//0 1001 0000 1000\t\tOpaque Clock tower main walls AND IVY\n\t\t\t    \t\t2316,\t\t//0 1001 0000 1100\t\tBushes, inner flower walkway a ramp and a box\n\n\t\t\t    \t\t// Number 10\n\t\t\t    \t\t2568,\t\t//0 1010 0000 1000\t\tLots of solids; walls, tents also some tent details WITH alpa\n\n\t\t\t    \t\t//Number 11\n\t\t\t    \t\t2569,\t\t//0 1010 0000 1001\t\tSolids like walls and roofs and appernt non solids like ropes\n\n\t\t\t    \t\t2572,\t\t//0 1010 0000 1100\t\tSolid wooden beems, lamp posts\n\t\t\t    \t\t2573,\t\t//0 1010 0000 1101\t\tLamp holders, bushes, fences, apparent non solids\n\t\t\t    \t\t2584,\t\t//0 1010 0001 1000\t\tFountain Well water\n\n\t\t\t    \t\t2824,\t\t//0 1011 0000 1000\t\tWindows, sign arrows, cloth roofs (non solids) BUT straw roofs\n\t\t\t    \t\t2828,\t\t//0 1011 0000 1100\t\tA few fence post (non solids)\n\t\t\t    \t\t2840,\t\t//0 1011 0001 1000\t\tFountain running water + pipe water\n\n\t\t\t    \t\t4617,\t\t//1 0010 0000 1001\t\tFound nothing\n\t\t\t    \t\t6664\t\t//1 1010 0000 1000\t\tTwo groups of solid boxes\n\t\t\t    \t];\n\n\t\t\t    \tvar alphaMask0 = 0x0001;// + 0x0100 + 0x0200;\n\t\t\t    \tvar alphaMask1 = 0x0010\n\t\t\t    \tvar alphaMask2 = 0x0100 + 0x0200;\n\t\t\t    \tvar alphaMask2b =  0x0200;\n\n\t\t\t    \tvar texMask = 0x8 + 0x0800;\n\n\n\t\t\t    \tif(knownflags.indexOf(mesh.materialFlags)!==11){\n\t\t\t    \t\t//return;\n\t\t\t    \t}\n\n\t\t\t    \t// No smoke etc\n\t\t\t    \tif( mesh.materialFlags == 520 ){\n\t\t\t    \t\t//return;\n\t\t\t    \t}\n\n\t\t\t    \t//Must have texture\n\t\t\t    \tif(!showUnmaterialed && !(mesh.materialFlags & texMask) ){\n\t\t\t    \t\treturn;\n\t\t\t    \t}\n\n\t\t\t\t\t//NO lods\n\t\t\t    \tif(mesh.flags == 4 || mesh.flags == 1 || mesh.flags == 0){\n\t\t\t    \t\t//return;\n\t\t\t    \t}\n\n\t\t\t\t\t//Add to final colection\n\t\t\t\t\tfinalMeshes.push(mesh);\n\n\t\t\t    });/// END FOR EACH meshes\n\n\t\t\t\tcallback(finalMeshes, boundingSphere);\n\n\t\t\t    \n\t\t    });/// END LOAD MATERIALS CALLBACK\n\n\n\t\t}\n\t    catch(e){\n\t    \tconsole.warn(\"Failed rendering model \"+filename,e);\n\t    \tvar mesh = new THREE.Mesh( new THREE.BoxGeometry( 200, 2000, 200 ), new THREE.MeshNormalMaterial() );\n\t    \tmesh.flags = 4;\n\t    \tmesh.materialFlags = 2056;\n\t    \tmesh.lodOverride = [1000000,1000000];\n\t    \tfinalMeshes.push(mesh);\n\n\t    \t/// Send the final meshes to callback function\n\t    \tcallback(finalMeshes);\n\t    }\n\t\t    \n\t});/// END FILE LOADED CALLBACK FUNCTION\n};\n\n\n/**\n * Gets a mesh array from Model file and sends as argument to callback. Uses a cache of meshes in order\n * to never read the same model file twice.\n * @method getMeshesForFilename\n * \n * @param  {Number} filename The fileId or baseId of the Model file to load\n * @param  {Array} color RGBA array of 4 integers\n * @param  {LocalReader} localReader The LocalReader object used to read data from the GW2 .dat file.\n * @param {Object} sharedMeshes  Value Object for keeping the texture cache.\n * @param {Object} sharedTextures  Value Object for keeping the texture cache.\n * @param {boolean} showUnmaterialed If false does not render any models with missing materials.\n * @param  {Function} callback Fired once all meshes have been loaded.\n * three arguments are passed to the callback function.\n * \n * The first argument is an Array with each textured THREE.Mesh objects.\n *\n * The second argument is a boolean, true indicates that these meshes were not\n * loaded from the dat file, but retrieved from the run time cache.\n * \n * The third argument is the bounding spehere of this model file.\n */\nvar getMeshesForFilename = ME.getMeshesForFilename =\nfunction(filename, color, localReader, sharedMeshes, sharedTextures, showUnmaterialed, callback){\n\n\t/// If this file has already been loaded, just return a reference to the meshes.\n\t/// isCached will be set to true to inform the caller the meshes will probably\n\t/// have to be cloned in some way.\n\tif( sharedMeshes[filename] ){\n\t\tcallback(sharedMeshes[filename].meshes, true, sharedMeshes[filename].boundingSphere)\n\t}\n\n\t/// If this file has never been loaded, load it using loadMeshFromModelFile\n\t/// the resulting mesh array will be cached within this model's scope.\n\telse{\n\n\t\tloadMeshFromModelFile(filename, color, localReader, sharedTextures, showUnmaterialed, function(meshes, boundingSphere){\n\n\t\t\t/// Cache result if any.\n\t\t\tif(meshes){\n\t\t\t\tsharedMeshes[filename] ={\n\t\t\t\t\tmeshes : meshes,\n\t\t\t\t\tboundingSphere : boundingSphere\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/// Allways fire callback.\n\t\t\tcallback(meshes, false, boundingSphere);\n\n\t\t});\n\t}\n}\n\n\n/**\n * WIP, Tries to find all fileIds refered by a model file.\n * @method  getFilesUsedByModel\n * @param  {Number}   filename    Model file Id\n * @param  {LocalReader}   localReader LocalReader instance to read from\n * @param  {Function} callback   First argument is list of used file IDs\n */\nvar getFilesUsedByModel = ME.getFilesUsedByModel = function(filename, localReader, callback){\n\tvar fileIds = [filename];\n\n\t///Load model file\n\tlocalReader.loadFile(filename,function(inflatedData){\n\t\t\n\t\ttry{\n\t\t\tif(!inflatedData){\n\t\t\t\tthrow \"Could not find MFT entry for \"+filename;\n\t\t\t}\n\n\t\t\tvar ds = new DataStream(inflatedData);\n\t\t\tvar modelFile = new GW2File(ds,0);\n\n\t\t\t//MODL for materials -> textures\n\t\t\tvar modelDataChunk = modelFile.getChunk(\"modl\");\n\n\t\t\t/// Get materials used by model\n\t\t\tvar mats = modelDataChunk.data.permutations[0].materials;\n\n\t\t\t/// Add each material file AND referenced TEXTURES\n\t\t\tmats.forEach(function(mat){\n\n\t\t\t\t/// Add material file id\n\t\t\t\tvar matFileName = mat.filename;\n\t\t\t\tfileIds.push(matFileName);\n\n\t\t\t\t/// Add each texture file id\n\t\t\t\tmat.textures.forEach(function(tex){\n\t\t\t\t\tfileIds.push(tex.filename);\n\t\t\t\t})\n\t\t\t\t\n\t\t\t});\n\t\t\t\n\t\t}\n\t\tcatch(e){\n\t\t\tconsole.warn(\"Could not export any data\",e);\n\t\t}\n\n\t\tcallback(fileIds);\n\t});\n\n}\n\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * TODO doc\n */\n\n\nmodule.exports = {\n    ///TODO: port fog from in-engine\n\n    getFragmentShader: function(){\n        return [\n            \"uniform vec2 uvScale;\",\n            \"uniform vec2 offset;\",\n            \"uniform sampler2D texturePicker;\",\n            \"uniform sampler2D texturePicker2;\",\n            \"uniform sampler2D texture1;\",\n            \"uniform sampler2D texture2;\",\n            \"uniform sampler2D texture3;\",\n            \"uniform sampler2D texture4;\",\n    \n            THREE.ShaderChunk[\"logdepthbuf_pars_fragment\"],\n    \n            \"varying vec2 vUv;\",\n            \"varying vec3 vecNormal;\",\n    \n            \"vec3 blend(\",\n                    \"vec4 texture1, float a1, vec4 texture2, float a2,\",\n                    \"vec4 texture3, float a3, vec4 texture4, float a4)\",\n            \"{\",\n                \"float depth = 2.0;\",\n                \"float alphaMult = 1.0;\",\n                \"float alphaAdd  = 0.0;\",\n                \"a1 *= 4.0;\",\n                \"a2 *= 4.0;\",\n                \"a3 *= 4.0;\",\n                \"a4 *= 4.0;\",\n                \"a1 =  a1+(1.5+texture1.a);\",\n                \"a2 =  a2+(1.5+texture2.a);\",\n                \"a3 =  a3+(1.5+texture3.a);\",\n                \"a4 =  a4+(1.5+texture4.a);\",\n                \"float ma = max(a1,a2);\",\n                \"ma = max(ma,a3);\",\n                \"ma = max(ma,a4);\",\n                \"ma -= depth;\",\n                \"float b1 = max(a1 - ma, 0.0);\",\n                \"float b2 = max(a2 - ma, 0.0);\",\n                \"float b3 = max(a3 - ma, 0.0);\",\n                \"float b4 = max(a4 - ma, 0.0);\",\n                \"return (\",\n                    \"texture1.rgb * b1 + texture2.rgb * b2 +\",\n                    \"texture3.rgb * b3 + texture4.rgb * b4 \",\n                \") / (b1 + b2 + b3 + b4);\",\n            \"}\",\n    \n            \"void main( void ) {\",\n                \"vec2 position = vUv*uvScale;\",\n                \"float edge = 1.0/1024.0;\",\n                \"vec2 compPos = edge + (vUv*0.25 + offset) * (1.0-edge*2.0);\",\n                \"vec4 tp1 = texture2D( texturePicker, compPos);\",\n                \"vec4 tp2 = texture2D( texturePicker2, compPos);\",\n                \"vec4 composite = tp1;\",\n                \"vec4 t1 = texture2D( texture1, position );\",\n                \"vec4 t2 = texture2D( texture2, position );\",\n                \"vec4 t3 = texture2D( texture3, position );\",\n                \"vec4 t4 = texture2D( texture4, position );\",\n                \"vec3 color = blend(\",\n                    \"t1, tp1.a,\",\n                    \"t2, tp1.b,\",\n                    \"t3, tp1.g,\",\n                    \"t4, tp1.r\",\n                \");\",\n                \"color *= 0.5+tp2.r;\",\n                \"gl_FragColor = vec4(color,1.0);\",\n                THREE.ShaderChunk[\"logdepthbuf_fragment\"],\n            \"}\"\n    \n        ].join( \"\\n\" );\n    },\n    getVertexShader : function(){\n        return [\n            \"varying vec2 vUv;\",\n            \"varying vec3 vecNormal;\",\n            THREE.ShaderChunk[\"logdepthbuf_pars_vertex\"],\n            \"void main()\",\n            \"{\",\n\n                \"vUv =  uv;\",\n                \"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n                \"vecNormal = (modelMatrix * vec4(normal, 0.0)).xyz;\",\n                \"gl_Position = projectionMatrix * mvPosition;\",\n                THREE.ShaderChunk[\"logdepthbuf_vertex\"],\n            \"}\"\n        ].join( \"\\n\" );\n    }\n}"]}