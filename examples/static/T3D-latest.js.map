{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/LocalReader/ArchiveParser.js","src/LocalReader/DataReader.js","src/LocalReader/FileTypes.js","src/LocalReader/LocalReader.js","src/LocalReader/PersistantStore.js","src/Logger.js","src/MapFileList.js","src/T3DLib.js","src/dataRenderer/DataRenderer.js","src/dataRenderer/EnvironmentRenderer.js","src/dataRenderer/HavokRenderer.js","src/dataRenderer/PropertiesRenderer.js","src/dataRenderer/SingleModelRenderer.js","src/dataRenderer/StringRenderer.js","src/dataRenderer/TerrainRenderer.js","src/dataRenderer/ZoneRenderer.js","src/format/file/GW2Chunk.js","src/format/file/GW2File.js","src/util/Constants.js","src/util/MapEnvUtils.js","src/util/MapHavokUtils.js","src/util/MapPropsUtils.js","src/util/MapTerrainUtils.js","src/util/MapZoneUtils.js","src/util/MaterialUtils.js","src/util/MathUtils.js","src/util/ModelUtils.js","src/util/RenderUtils.js","src/util/TerrainShader.js"],"names":["f","exports","module","define","amd","window","global","self","this","T3D","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","1","MathUtils","parseANDatHeader","ds","header","version","readUint8","magic","readString","headerSize","readUint32","seek","position","chunkSize","crc","mftOffset","arr32To64","mftSize","flags","Logger","log","TYPE_DEBUG","TYPE_ERROR","parseMFTTable","nbOfEntries","fullTable","item","readUint16","table","mftIndexOffset","offset","mftIndexSize","size","parseMFTIndex","indexTable","id","mftIndex","getFilePart","file","Promise","resolve","reject","reader","FileReader","onerror","onload","fileEvent","buffer","target","result","DataStream","endianness","LITTLE_ENDIAN","len","readAsArrayBuffer","slice","readArchive","async","archiveHeader","mftData","metaTable","DataReader","[object Object]","settings","_settings","_workerPool","_workerLoad","_handleCounter","_workQueue","_handleRegister","workersNb","_startWorker","workerPath","mftId","isImage","capLength","arrayBuffer","byteLength","TYPE_WARNING","push","freeWorkerIndex","_getFreeWorkerIndex","_workNext","workerId","workData","shift","handle","_getNewHandle","postMessage","path","_id","selfWorkerId","worker","Worker","onmessage","messageEvent","answer","data","handleID","split","handleData","dxtType","imageWidth","imageHeight","_","terminate","indexOf","GW2File","getAnetTextureType","first4","textureType","getFileType","readCString","fileType","type","ArchiveParser","PersistantStore","MapFileList","FileTypes","LocalReader","_dataReader","_persistantStore","undefined","_file","_indexTable","_fileMetaTable","noIndexedDB","baseId","raw","fileLength","extractLength","isBaseId","getFileIndex","meta","getFileMeta","compressed","inflate","then","catch","oldFileList","persistantId","persistantList","lastListing","getLastListing","name","array","complete","key","iterateList","Object","keys","map","Number","index","taskArray","task","persistantNeedsUpdate","_needsScan","scan","taskId","race","readFileType","scanResult","change","Math","floor","TYPE_PROGRESS","putListing","res","all","_persistantData","getFileList","mapArray","reversedIndex","getReverseIndex","maps","filter","found","category","fileMap","find","fileName","toString","mapEntry","typeList","reverseBaseIdList","fileList","baseIds","baseIdList","reduce","reversed","searchAll","callback","restoreOuput","returnArray","elt","findIndex","sort","j","readFileList","getMapList","returnObj","fileEntry","readFile","persistantData","metaData","_fileTypeCache","fileBuffer","min","DB_VERSION","_dbConnection","_getConnection","request","indexedDB","open","onblocked","event","onupgradeneeded","db","currentVersion","oldVersion","createObjectStore","autoIncrement","currentTarget","transaction","objectStore","createIndex","unique","onsuccess","isReady","listing","isComplete","store","put","filename","openCursor","IDBKeyRange","only","cursor","value","primaryKey","TYPE_MESSAGE","logFunctions","Array","arguments","argArr","argsToArr","unshift","severity","max","apply","args","console","error","warn","debug","t3dtoolsWorker","concurrentTasks","navigator","hardwareConcurrency","GW2Chunk","DataRenderer","EnvironmentRenderer","HavokRenderer","PropertiesRenderer","SingleModelRenderer","TerrainRenderer","ZoneRenderer","StringRenderer","RenderUtils","getLocalReader","lrInstance","openArchive","getFileListAsync","localReader","getMapListAsync","renderMapContentsAsync","renderers","logger","context","parseInt","mapFile","runAllRenderers","runRenderer","renderClass","assign","bind","RenderClass","cb","renderAsync","getContextValue","clazz","propName","defaultValue","output","hasWebGL","returnContext","WebGLRenderingContext","canvas","document","createElement","names","getContext","getParameter","gl","numErrors","THREE","checkRequirements","constructor","otherClass","inflatedData","getOutput","fileId","rawData","uarr","Uint8Array","textDecoder","TextDecoder","rawString","decode","image","width","height","MapEnvUtils","super","environmentChunkData","getChunk","parameterChunkData","hazeColor","getHazeColor","hazeColorAsInt","lightData","parseLights","hasLight","lights","skyElements","parseSkybox","MapHavokUtils","lastP","seed","meshes","havokChunkData","boundingBox","boundsMax","propModels","zoneModels","obsModels","mdl","scale","geometries","animations","renderZoneModelsCB","renderModels","models","title","currentOutput","concat","MapPropsUtils","propertiesChunkData","props","propArray","animProps","propAnimArray","instanceProps","propInstanceArray","metaProps","propMetaArray","renderIndex","getIdsForProp","ModelUtils","meshCache","getMeshesForFilename","isCached","boundingSphere","forEach","mesh","strings","end","entryHeaderDef","entryIndex","entry","readStruct","decryptionOffset","bitsPerSymbol","readUCS2String","recid","language","MapTerrainUtils","pagedImageId","materials","pagedImage","loadPagedImageCallback","anisotropy","terrainResult","terrainTiles","water","bounds","mapRect","getTerrainFilesId","MapZoneUtils","zoneChunkData","rect","zones","zoneArray","zoneDefs","zoneDefArray","lastPct","dataForUtils","stepZone","pct","round","renderZone","HEAD_STRUCT","DUPLICATE_SETTINGS","PACKTOCHUNK","pack","chunk","root","addr","setting","regex","RegExp","chunkDef","formats","v","defsIdx","defs","versions","getRootName","pop","match","Definition","__root","genDuplicateSettings","headerLength","NaN","loadHead","useNthIndex","fileTypes","defsFound","chunkVersion","def","getDefinition","chunkDataSize","Chunk","noChunks","chunks","readHead","readChunks","ch","loadData","next","toLowerCase","fvfFormat","Position","Weights","Group","Normal","Color","Tangent","Bitangent","TangentFrame","UV32Mask","UV16Mask","Unknown1","Unknown2","Unknown3","Unknown4","PositionCompressed","Unknown5","MaterialUtils","getMat","tex","MeshBasicMaterial","side","BackSide","fog","depthWrite","loadTextureWithFallback","targetMatIndices","materialArray","fallbackFilename","writeMat","mat","loadFallback","TextureLoader","load","loadLocalTexture","setTimeout","hazes","dataGlobal","haze","farColor","ambientLight","lightOutput","lighting","backlightIntensity","backlightColor","idx","light","sumDirLightIntensity","dirLightData","color","directionalLight","DirectionalLight","getHex","intensity","set","direction","normalize","directions","lightDir","AmbientLight","ambientTotal","g","b","skyboxFallbackArray","skyModeTex","texPathNE","texPathSW","texPathT","mapW","abs","x1","x2","mapD","y1","y2","visible","skyGeometry","BoxGeometry","boxSize","faceVertexUvs","vecs","face","vec2","x","y","uvsNeedUpdate","skyBox","Mesh","translateY","getCollisionsForAnimation","animation","collisions","ret","collisionIndices","collision","animationFromGeomIndex","propGeomIndex","l","renderMesh","rendererData","model","pos","translate","rot","rotate","clone","geom","Geometry","vertices","Vector3","indices","f1","f2","f3","faces","Face3","computeFaceNormals","parseHavokMesh","rotation","order","parseAllModels","geometryIndex","MeshNormalMaterial","DoubleSide","propsArray","textureCache","pctStr","prop","addMeshToLOD","groups","lod","needsClone","lodDist","lod2","lodOverride","geometry","material","updateMatrix","matrixAutoUpdate","add","group","addLevel","meshArray","LOD","maxDist","boundingSphereRadius","radius","transforms","transform","update","addMeshesToScene","fileIds","getFilesUsedByModel","propFileIds","TerrainShader","inflatedBuffer","envOutput","pimgDS","pimgTableDataChunk","pimgData","terrainData","parameterData","maxAnisotropy","numChunksD_1","sqrt","dims","chunkArray","numChunksD_2","parseNumChunks","xChunks","yChunks","allMaterials","allTextures","texFileArray","dx","dy","cdx","cdy","allMats","customMaterial","MeshLambertMaterial","flatShading","chunkTextures","strippedPages","page","layer","coord","matName","chunkTex","wrapS","RepeatWrapping","wrapT","renderChunk","cx","cy","chunkIndex","pageX","pageY","chunkTextureIndices","loResMaterial","texIndexArray","pageOffetX","pageOffetY","fileNames","gi","textureFileName","pageTexName","pageTexName2","near","far","uniforms","UniformsUtils","merge","UniformsLib","uvScale","Vector2","texturePicker","texturePicker2","texture1","texture2","texture3","texture4","ShaderMaterial","fragmentShader","getFragmentShader","vertexShader","getVertexShader","chunkGeo","PlaneBufferGeometry","chunkW","cn","getAttribute","heightMapArray","mS","Matrix4","identity","elements","applyMatrix","SceneUtils","createMultiMaterialObject","PI","globalOffsetX","chunkOffsetX","globalOffsetY","chunkOffsetY","z","px","py","updateMatrixWorld","wireframe","opacity","transparent","renderRect","drawWater","terrainChunk","texture","zone","renderZoneCallback","zoneDef","zd","token","defToken","modelGroups","mapX","mapY","zoneRect","vertRect","encodeData","zdx","linearPos","flag","zoneDefLayer","layerDefArray","modelX","modelY","modelZ","startZ","raycaster","Raycaster","intersections","intersectObject","distance","modelIdx","modelArray","modelFilename","rotRangeX","rotRangeY","rotRangeZ","scaleRange","fadeRange","getModelGroups","groupKeys","stepModels","meshGroups","instanceIdx","meshIdx","materialFlags","move","mg","readVerts","verts","Float32Array","readIndices","getIndex","Uint32Array","readUVs","uvs","readNormals","normals","writeVerts","stride","writeIndices","strideIndices","writeUvs","uvStride","writeNormals","normalStride","meshGroup","mergedGeom","BufferGeometry","addAttribute","BufferAttribute","setIndex","buffersNeedUpdate","buildVS","numUv","vdefs","adefs","reads","generateDataTexture","DataTexture","RGBAFormat","buildPS","textures","alphaTest","lightMap","t1uv","uvIdx","discard","writeColor","varyings","getUVMat","numUV","attributes","vs","FrontSide","getTexture","texURL","sharedTextures","finalTexture","flipY","mapping","defaultColor","random","minFilter","LinearMipMapLinearFilter","magFilter","LinearFilter","generateMipmaps","format","needsUpdate","getMaterial","materialFile","dxChunk","grChunk","finalMaterial","finalTextures","effect","techniques","passes","effects","samplerTextures","samplerIndex","samplerIdx","sampler","samplers","textureToken","texTokens","textureIndex","samplerTex","uvPSInputIndex","ft","nt","MeshPhongMaterial","normalMap","textureFilename","shading","FlatShading","alphaMask0","alphaMask1","lightMask","base32Max","pow","f16","h","s","Infinity","popcount","bits","arr","sort_unique","arr_in","comparator","prototype","hasOwnProperty","matFiles","renderGeomChunk","modelDataChunk","showUnmaterialed","rawMeshes","mats","permutations","rawMesh","rawGeom","fvf","numVerts","vertexCount","rawVerts","vertDS","distToUV","uv32Flag","uv16Flag","isUV32","hasUV","masked","readFloat32","Uint16Array","computeVertexNormals","uvName","materialIndex","finalMesh","materialFilename","materialName","numLods","lods","sharedMeshes","hideLOD","solidColor","finalMeshes","modelFile","geometryDataChunk","bsc","center","loadMaterialIndex","mIdx","matCallback","texMask","loadMeshFromModelFile","matFileName","yPos","dz","cz","plane","overdraw","ShaderChunk","join"],"mappings":"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","file":"T3D-latest.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst MathUtils = require(\"../util/MathUtils\");\n\n/**\n * @file The ArchiveParser module is a set of helper tools to correctly read the Archive.\n * @namespace ArchiveParser\n */\n\n/**\n *    All in one function to read a GW2.dat file and parse all the needed informations to work with it\n *\n * @memberof ArchiveParser\n * @param {File} file\n * @returns {Promise<{archiveHeader: ArchiveHeader, metaTable: MetaTable, indexTable: IndexTable}>}\n */\nasync function readArchive(file) {\n  let archiveHeader = parseANDatHeader((await getFilePart(file, 0, 40)).ds);\n  let mftData = parseMFTTable(\n    (await getFilePart(file, archiveHeader.mftOffset, archiveHeader.mftSize)).ds\n  );\n  let { ds, len } = await getFilePart(\n    file,\n    mftData.mftIndexOffset,\n    mftData.mftIndexSize\n  );\n  let indexTable = parseMFTIndex(ds, len);\n\n  return {\n    archiveHeader: archiveHeader,\n    metaTable: mftData.table,\n    indexTable: indexTable\n  };\n}\n\n/**\n * The header of the archive.\n * @typedef {Object} ArchiveHeader\n * @property {number} version\n * @property {number} magic\n * @property {number} headerSize\n * @property {number} chunkSize\n * @property {number} crc\n * @property {number} mftOffset\n * @property {number} mftSize\n * @property {number} flags\n */\n\n/**\n *   Parse the main information about the archive like format version, positions of information tables, crc etc...\n *\n * @memberof ArchiveParser\n * @param {DataStream} ds\n * @returns {ArchiveIndex} Returns undefined if the header couldn't be parsed\n */\nfunction parseANDatHeader(ds) {\n  let header = {};\n\n  // Header parsing\n  header.version = ds.readUint8();\n  header.magic = ds.readString(3);\n  header.headerSize = ds.readUint32();\n  ds.seek(ds.position + 4); // Skip uint32\n  header.chunkSize = ds.readUint32();\n  header.crc = ds.readUint32();\n  ds.seek(ds.position + 4); // Skip uint32\n  header.mftOffset = MathUtils.arr32To64([ds.readUint32(), ds.readUint32()]);\n  header.mftSize = ds.readUint32();\n  header.flags = ds.readUint32();\n  // End header parsing\n\n  // Check MAGIC\n  if (header.magic !== \"AN\\u001A\") {\n    T3D.Logger.log(\n      T3D.Logger.TYPE_ERROR,\n      \"ANDat header is not valid\",\n      header.magic\n    );\n    return undefined;\n  }\n\n  T3D.Logger.log(T3D.Logger.TYPE_DEBUG, \"Loaded Main .dat header\");\n\n  return header;\n}\n\n/**\n * The array containing all the meta information concerning the contained files\n * @typedef {Array<{offset: number, size: number, compressed: number, crc: number}>} MetaTable\n */\n\n/**\n *   Parse the main information table that contains the offset, size, compression flags and crc\n *\n * @memberof ArchiveParser\n * @param {Datastream}  ds\n * @returns {{header: {magic: String, nbOfEntries: number}, table: MetaTable, mftIndexOffset: number, mftIndexSize: number}|undefined}\n *   Returns undefined if it couldn't parse the table\n */\nfunction parseMFTTable(ds) {\n  // Parse the table header\n  let header = {};\n  header.magic = ds.readString(4);\n  ds.seek(ds.position + 8); // Skip uint64\n  header.nbOfEntries = ds.readUint32();\n  ds.seek(ds.position + 4 + 4); // Skip uint32 * 2\n\n  // check MAGIC\n  if (header.magic !== \"Mft\\u001A\") {\n    T3D.Logger.log(\n      T3D.Logger.TYPE_ERROR,\n      \"MFTTable header is not valid\",\n      header.magic\n    );\n    return undefined;\n  }\n\n  // Where we put all the parsed data\n  // We don't pre-alloc anymore since not having the data aligned together procs too many\n  // cache misses during a fullscan\n  let fullTable = [];\n\n  // Go through the table\n  for (let i = 1; i < header.nbOfEntries; i++) {\n    let item = {};\n    item[\"offset\"] = MathUtils.arr32To64([ds.readUint32(), ds.readUint32()]);\n    item[\"size\"] = ds.readUint32();\n    item[\"compressed\"] = ds.readUint16();\n    ds.seek(ds.position + 4 + 2); // Skip uint16 + uint32\n    item[\"crc\"] = ds.readUint32();\n    fullTable[i] = item;\n  }\n\n  T3D.Logger.log(T3D.Logger.TYPE_DEBUG, \"Loaded MFTTable\");\n\n  return {\n    header: header,\n    table: fullTable,\n    // Register the MFTIndex table position and size\n    mftIndexOffset: fullTable[2].offset,\n    mftIndexSize: fullTable[2].size\n  };\n}\n\n/**\n * The array linking all the file indexes to their respective files\n * @typedef {Array<number>} IndexTable\n */\n\n/**\n *   This function used to be much more complex with the use of\n *   a \"fileId\" which in the end was just the equivalent of\n *   MFTbaseIds[mftId].sort().reverse()[0] (aka the bigger baseId found)\n *\n * @memberof ArchiveParser\n * @param {DataStream} ds\n * @param {number} size\n * @returns {IndexTable}\n */\nfunction parseMFTIndex(ds, size) {\n  let length = size / 8;\n\n  let indexTable = [];\n\n  for (let i = 0; i < length; i++) {\n    // Parse table\n    let id = ds.readUint32();\n    let mftIndex = ds.readUint32();\n    // Store the values\n    indexTable[id] = mftIndex;\n  }\n\n  T3D.Logger.log(T3D.Logger.TYPE_DEBUG, \"Finished indexing MFT\");\n\n  return indexTable;\n}\n\n/**\n *   Get a chunk of the specified file. Used mainly to take parts of the Archive before parsing.\n *\n * @memberof ArchiveParser\n * @param {File} file\n * @param {number} offset\n * @param {number} length\n * @returns {Promise<{ds: DataStream, len: number}>}\n */\nfunction getFilePart(file, offset, length) {\n  return new Promise((resolve, reject) => {\n    let reader = new FileReader();\n\n    reader.onerror = reject;\n\n    reader.onload = fileEvent => {\n      let buffer = fileEvent.target.result;\n      let ds = new DataStream(buffer);\n      ds.endianness = DataStream.LITTLE_ENDIAN;\n      // Pass data stream and data length to callback function\n      resolve({\n        ds: ds,\n        len: length\n      });\n    };\n\n    // Slicing a File is just reducing the scope of the ArrayBuffer, but doesn't load anything in memory.\n    reader.readAsArrayBuffer(file.slice(offset, offset + length));\n  });\n}\n\nmodule.exports = {\n  readArchive: readArchive,\n  parseANDatHeader: parseANDatHeader,\n  parseMFTTable: parseMFTTable,\n  parseMFTIndex: parseMFTIndex,\n  getFilePart: getFilePart\n};\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * Organized thread pool of extractors\n * @class DataReader\n */\nclass DataReader {\n  /**\n   * @constructor\n   * @param {Object} settings\n   * @param {number} settings.workersNb Amount of concurrent spawned workers\n   * @param {string} settings.workerPath Path to the worker script\n   */\n  constructor(settings) {\n    this._settings = settings;\n    this._workerPool = [];\n    this._workerLoad = [];\n\n    // Makes individual ids for file extraction\n    this._handleCounter = 0;\n\n    /**\n     * Work to be processed\n     * @private\n     * @type {[{buffer: ArrayBuffer, size: number, mftId: number, isImage: boolean, capLength: number, resolve: function, reject: function}]}\n     */\n    this._workQueue = [];\n\n    /**\n     * Work currently processed\n     * @private\n     * Entries : {mftId: number, workerId: number, resolve: resolve, reject: reject}\n     */\n    this._handleRegister = {};\n\n    for (let i = 0; i < settings.workersNb; i++) {\n      this._startWorker(settings.workerPath);\n    }\n  }\n\n  /**\n   * @param {DataStream} ds\n   * @param {number} size\n   * @param {number} mftId\n   * @param {boolean} [isImage] Parses the output as a dxt texture\n   * @param {number} [capLength] Output size\n   * @returns {Promise<{buffer: ArrayBuffer, dxtType: number, imageWidth: number, imageHeight: number}>}\n   */\n  inflate(ds, size, mftId, isImage, capLength) {\n    return new Promise((resolve, reject) => {\n      let arrayBuffer = ds.buffer;\n\n      // If no capLength then inflate the whole file\n      if (!capLength || capLength < 0) {\n        capLength = 0;\n      }\n\n      // Buffer length size check\n      if (arrayBuffer.byteLength < 12) {\n        T3D.Logger.log(\n          T3D.Logger.TYPE_WARNING,\n          `not inflating, length is too short (${arrayBuffer.byteLength})`,\n          mftId\n        );\n        reject(new Error(\"Couldn't inflate \" + mftId + \" (mftId)\"));\n        return;\n      }\n\n      // Register the data to work with\n      this._workQueue.push({\n        buffer: arrayBuffer,\n        size: size,\n        mftId: mftId,\n        isImage: isImage,\n        capLength: capLength,\n        resolve: resolve,\n        reject: reject\n      });\n\n      // Check if there is a free worker and ask it to start\n      const freeWorkerIndex = this._getFreeWorkerIndex();\n      if (freeWorkerIndex >= 0) {\n        this._workNext(freeWorkerIndex);\n      }\n    });\n  }\n\n  /**\n   * Function used to give work to a worker\n   * @private\n   * @param {number} workerId\n   **/\n  _workNext(workerId) {\n    const workData = this._workQueue.shift();\n\n    if (workData) {\n      // Get a handleID\n      const handle = this._getNewHandle();\n\n      this._handleRegister[handle] = {\n        mftId: workData.mftId,\n        workerId: workerId,\n        resolve: workData.resolve,\n        reject: workData.reject\n      };\n\n      this._workerLoad[workerId] += 1;\n      this._workerPool[workerId].postMessage([\n        handle,\n        workData.buffer,\n        workData.isImage === true,\n        workData.capLength\n      ]);\n    }\n  }\n\n  _getNewHandle() {\n    return this._handleCounter++;\n  }\n\n  // Initialization function for creating a new worker (thread)\n  // _id should only be used to restart a worker !\n  _startWorker(path, _id) {\n    let worker = new Worker(path);\n    let selfWorkerId;\n    if (_id) {\n      selfWorkerId = _id;\n      this._workerPool[selfWorkerId] = worker;\n      this._workerLoad[selfWorkerId] = 0;\n    } else {\n      selfWorkerId = this._workerPool.push(worker) - 1;\n      if (this._workerLoad.push(0) !== selfWorkerId + 1)\n        throw new Error(\"WorkerLoad and WorkerPool don't have the same length\");\n    }\n\n    // This\n    worker.onmessage = messageEvent => {\n      const answer = messageEvent.data;\n      let handleID;\n\n      // Remove load\n      this._workerLoad[selfWorkerId] -= 1;\n\n      // If error\n      if (typeof answer === \"string\") {\n        T3D.Logger.log(\n          T3D.Logger.TYPE_WARNING,\n          \"Inflater threw an error\",\n          answer\n        );\n\n        // Parse the handle\n        handleID = answer.split(\":\")[0];\n\n        // Get handle owner informations and reject then cleanup\n        const handleData = this._handleRegister[handleID];\n        if (handleData) {\n          handleData.reject(`Error: ${answer}`);\n          delete this._handleRegister[handleID];\n        }\n      } else {\n        // Parse handle\n        handleID = answer[0];\n\n        const handleData = this._handleRegister[handleID];\n        // If handle is recognized: success\n        if (handleData) {\n          // Array buffer, dxtType, imageWidth, imageHeight\n          handleData.resolve({\n            buffer: answer[1],\n            dxtType: answer[2],\n            imageWidth: answer[3],\n            imageHeight: answer[4]\n          });\n\n          // Cleanup\n          delete this._handleRegister[handleID];\n        }\n\n        // Unknown error\n        else {\n          T3D.Logger.log(\n            T3D.Logger.TYPE_ERROR,\n            \"Inflater threw an error\",\n            answer\n          );\n        }\n      }\n\n      this._workNext(selfWorkerId);\n    };\n\n    // Handle errors, we assume worse case: it crashed and corrupted its memory\n    worker.onerror = _ => {\n      // Get all handles sent to this worker and reject them\n      for (let handle in this._handleRegister) {\n        if (this._handleRegister[handle].workerId === selfWorkerId) {\n          this._handleRegister[handle].reject(\n            // TODO\n            `Error: Worker crashed while processing ${\n              this._handleRegister[handle].mftId\n            }`\n          );\n          delete this._handleRegister[handle];\n        }\n      }\n\n      // Clean and restart the worker\n      this._workerPool[selfWorkerId].terminate();\n      this._startWorker(this._settings.workerPath, selfWorkerId);\n    };\n  }\n\n  // Returns -1 if there are no free worker, or the index of a free worker\n  _getFreeWorkerIndex() {\n    return this._workerLoad.indexOf(0);\n  }\n}\n\nmodule.exports = DataReader;\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst GW2File = require(\"../format/file/GW2File.js\");\n\n/**\n * @namespace FileTypes\n */\n\n/**\n * Parse the beginning of a file to find its type\n *\n * @memberof FileTypes\n * @param {DataStream} ds\n * @return {number}\n */\nfunction getFileType(ds) {\n  let first4 = ds.readCString(4);\n\n  let fileType = \"UNKNOWN\";\n\n  // Parse textures\n  const textureType = getAnetTextureType(first4);\n  if (textureType) fileType = textureType;\n  else if (first4.indexOf(\"DDS\") === 0) fileType = \"TEXTURE_DDS\";\n  else if (first4.indexOf(\"PNG\") === 1) fileType = \"TEXTURE_PNG\";\n  else if (first4.indexOf(\"RIFF\") === 0) fileType = \"TEXTURE_RIFF\";\n  else if (first4.indexOf(\"YUI\") === 0) fileType = \"TEXT_YUI\";\n  // PackFiles\n  else if (first4.indexOf(\"PF\") === 0) {\n    let file = new GW2File(ds, 0, true); /// true for \"plz no load chunkz\"\n    fileType = \"PF_\" + file.header.type;\n  }\n\n  // Binaries\n  else if (first4.indexOf(\"MZ\") === 0) fileType = \"BINARIES\";\n  // Strings\n  else if (first4.indexOf(\"strs\") === 0) fileType = \"STRINGS\";\n  // Raw asnd chunk (without pack file)\n  else if (first4.indexOf(\"asnd\") === 0) fileType = \"CHUNK_ASND\";\n\n  // TODO: parse all datastream and if all bytes are valid unicode symbols then\n  // TEXT_UNKNOWN;\n\n  // Unknown\n  return fileType;\n}\n\n/**\n * Returns the texture type if it's the Anet format, if not it returns undefined\n * @param {String} first4 First 4 bytes of the file\n * @returns {String|undefined}\n */\nfunction getAnetTextureType(first4) {\n  let textureType;\n  if (first4 === \"ATEC\") textureType = \"TEXTURE_ATEC\";\n  else if (first4 === \"ATEP\") textureType = \"TEXTURE_ATEP\";\n  else if (first4 === \"ATET\") textureType = \"TEXTURE_ATET\";\n  else if (first4 === \"ATEU\") textureType = \"TEXTURE_ATEU\";\n  else if (first4 === \"ATEX\") textureType = \"TEXTURE_ATEX\";\n  else if (first4 === \"ATTX\") textureType = \"TEXTURE_ATTX\";\n  return textureType;\n}\n\nmodule.exports = {\n  getFileType,\n  getAnetTextureType\n};\n","/*\r\nCopyright  Tyria3DLibrary project contributors\r\n\r\nThis file is part of the Tyria 3D Library.\r\n\r\nTyria 3D Library is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nTyria 3D Library is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nconst ArchiveParser = require(\"./ArchiveParser\");\r\nconst PersistantStore = require(\"./PersistantStore\");\r\nconst DataReader = require(\"./DataReader\");\r\nconst MapFileList = require(\"../MapFileList\");\r\nconst FileTypes = require(\"./FileTypes\");\r\n\r\n/**\r\n * A statefull class that handles reading and inflating data from a local GW2 dat file.\r\n * LocalReader have been completely rewritten from scratch,\r\n * the API changed quite a lot between 1.0.4 and 1.1.0.\r\n *\r\n * API CHANGES: LocalReader (1.1.0 from 1.0.4)\r\n * - The constructor have __changed__.\r\n * - parseHeaderAsync have been __removed__.\r\n * - connectInflated have been __removed__.\r\n * - NaClListener have been __removed__.\r\n * - readANDatHeader have been __removed__.\r\n * - readMFTHeader have been __removed__.\r\n * - readMFTIndexFile have been __removed__.\r\n * - loadFileList is now __deprecated__.\r\n * - loadMapList is now __deprecated__.\r\n * - storeFileList have been __removed__.\r\n * - storeMapList have been __removed__.\r\n * - readFileListAsync is now __deprecated__.\r\n * - readMapListAsync is now __deprecated__.\r\n * - listFiles have been __removed__.\r\n * - getFileIndex have been slightly __changed__.\r\n * - loadTextureFile is now __deprecated__.\r\n * - loadFile have been __deprecated__.\r\n * - inflate have been __removed__.\r\n * - loadFilePart have been __removed__.\r\n *\r\n * @param {{workerPath: String, workersNb: number, noIndexedDB: boolean}} settings\r\n *   * workerPath: the path to the t3dtools worker script file.\r\n *   * workersNb: amount of threads spawned for decompression.\r\n *   * noIndexedDB: Do not use indexedDB (persistant storage, default is true)\r\n */\r\nclass LocalReader {\r\n  constructor(settings) {\r\n    this._settings = settings;\r\n\r\n    /**\r\n     * @private\r\n     * @type {DataReader}\r\n     */\r\n    this._dataReader = new DataReader(settings);\r\n\r\n    /**\r\n     * @private\r\n     * @type {PersistantStore}\r\n     */\r\n    this._persistantStore = undefined;\r\n\r\n    /**\r\n     * @private\r\n     * @type {File}\r\n     */\r\n    this._file = undefined;\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<number>}\r\n     */\r\n    this._indexTable = [];\r\n\r\n    /**\r\n     * @private\r\n     * @type {Array<{offset: number, size: number, compressed: number, crc: number}>}\r\n     */\r\n    this._fileMetaTable = [];\r\n\r\n    if (settings.noIndexedDB !== false) {\r\n      this._persistantStore = new PersistantStore();\r\n    }\r\n  }\r\n\r\n  /**\r\n   *   Asynchronously loads the archive by parsing its file index and header.\r\n   *\r\n   * @param {File} file\r\n   * @returns {Promise}\r\n   */\r\n  async openArchive(file) {\r\n    let { metaTable, indexTable } = await ArchiveParser.readArchive(file);\r\n    this._fileMetaTable = metaTable;\r\n    this._indexTable = indexTable;\r\n    this._file = file;\r\n  }\r\n\r\n  /**\r\n   *   Gets MFT index by baseId\r\n   *\r\n   * @param  {Number} baseId   A base Id\r\n   * @return {Number}          MFT index\r\n   */\r\n  getFileIndex(baseId) {\r\n    return this._indexTable[baseId];\r\n  }\r\n\r\n  /**\r\n   *   \"Meta\" informations to deal with files in the archive.\r\n   * @typedef     {Object}    FileMetaData\r\n   * @property    {number}    offset\r\n   * @property    {number}    size\r\n   * @property    {number}    compressed\r\n   * @property    {number}    crc\r\n   */\r\n\r\n  /**\r\n   *   Returns the metadata of a file stored in the archive\r\n   *\r\n   * @param {number} mftId Mft index of the file\r\n   * @returns {FileMetaData} Metadata informations\r\n   */\r\n  getFileMeta(mftId) {\r\n    return this._fileMetaTable[mftId];\r\n  }\r\n\r\n  /**\r\n   *   Fetch a file and uncompress it if needed / required.\r\n   *\r\n   * @param {number} mftId File's archive ID\r\n   * @param {boolean} [isImage] Try to read the data as a Dxt texture.\r\n   * @param {boolean} [raw] Force no decompression.\r\n   * @param {number} [fileLength] Slice the uncompressed file.\r\n   * @param {number} [extractLength] Slice the decompression.\r\n   * @param {boolean} [isBaseId] If true, the first parameter mftId becomes a baseId\r\n   * @returns {Promise<{buffer: ArrayBuffer, dxtType: number|undefined, imageWidth: number|undefined, imageHeight: number|undefined}>}\r\n   */\r\n  async readFile(mftId, isImage, raw, fileLength, extractLength, isBaseId) {\r\n    if (isBaseId) {\r\n      const baseId = mftId;\r\n      mftId = this.getFileIndex(baseId);\r\n      if (!(mftId > 0)) throw new Error(`Unexistant file: ${baseId} (baseId)`);\r\n    }\r\n\r\n    let meta = this.getFileMeta(mftId);\r\n    if (!meta) throw new Error(`Unexistant file: ${mftId} (mftId)`);\r\n\r\n    // Slice up the data\r\n    let { ds, len } = await ArchiveParser.getFilePart(\r\n      this._file,\r\n      meta.offset,\r\n      fileLength || meta.size\r\n    );\r\n\r\n    // If needed we decompress, if not we keep raw\r\n    if (meta.compressed || raw !== false) {\r\n      let data;\r\n      await this._dataReader\r\n        .inflate(ds, len, mftId, isImage, extractLength || 0)\r\n        .then(result => {\r\n          data = result;\r\n        })\r\n        .catch(_ => {\r\n          data = {\r\n            buffer: undefined,\r\n            dxtType: undefined,\r\n            imageWidth: undefined,\r\n            imageHeight: undefined\r\n          };\r\n        });\r\n      return data;\r\n    } else {\r\n      return {\r\n        buffer: ds.buffer\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   *   Scans asynchronously the types of all the files listed in the archive.\r\n   *   Uses persistant store to cache and speed up a rescan.\r\n   *\r\n   * @param {Array<{baseId: number, size: number, crc: number, fileType: string}>|undefined} oldFileList\r\n   *   Way for platform not supporting indexDB to provide their own persistant storage.\r\n   * @returns {Promise<Array<FileItem>>}\r\n   */\r\n  async readFileList(oldFileList) {\r\n    let persistantList = oldFileList || [];\r\n    let persistantId;\r\n\r\n    // Load previously saved data\r\n    if (this._persistantStore) {\r\n      let lastListing = await this._persistantStore.getLastListing(\r\n        this._file.name\r\n      );\r\n      persistantList = lastListing.array;\r\n      // If the last scan was not completed then we will just update it..\r\n      if (!lastListing.complete) {\r\n        persistantId = lastListing.key;\r\n      }\r\n    }\r\n\r\n    // Create a list of all the baseIds we need to inspect\r\n    let iterateList = Object.keys(this._indexTable).map(i => Number(i));\r\n    for (let index in persistantList) {\r\n      if (!(index in this._indexTable)) iterateList.push(index);\r\n    }\r\n\r\n    // Spawn the decompression tasks\r\n    let taskArray = [];\r\n    for (let i = 0; i < 1; i++) {\r\n      taskArray[i] = Promise.resolve({\r\n        task: i\r\n      });\r\n    }\r\n\r\n    let persistantNeedsUpdate = false;\r\n\r\n    // Iterate through the array\r\n    for (let index in iterateList) {\r\n      let baseId = iterateList[index];\r\n\r\n      // First use a synchronous function to know if we need to scan the file\r\n      let result = this._needsScan(baseId, persistantList);\r\n      if (result.scan === true) {\r\n        let taskId = (await Promise.race(taskArray)).task;\r\n        taskArray[taskId] = this.readFileType(baseId).then(scanResult => {\r\n          // Put the result into our persistant storage\r\n          persistantList[baseId] = {\r\n            baseId: baseId,\r\n            size: scanResult.size,\r\n            crc: scanResult.crc,\r\n            fileType: scanResult.fileType\r\n          };\r\n          return {\r\n            task: taskId\r\n          };\r\n        });\r\n      }\r\n      if (result.change === \"removed\") {\r\n        // Update the persistant storage\r\n        delete persistantList[baseId];\r\n      }\r\n\r\n      // Handle persistant storage update\r\n      if (result.change !== \"none\") persistantNeedsUpdate = true;\r\n\r\n      // Tasks to do only every %\r\n      if (index % Math.floor(iterateList.length / 100) === 0) {\r\n        // Print progress\r\n        T3D.Logger.log(\r\n          T3D.Logger.TYPE_PROGRESS,\r\n          \"Finding types\",\r\n          index / Math.floor(iterateList.length / 100)\r\n        );\r\n\r\n        // Update the persistant storage if needed\r\n        if (this._persistantStore && persistantNeedsUpdate) {\r\n          persistantNeedsUpdate = false;\r\n          this._persistantStore\r\n            .putListing(persistantId, persistantList, this._file.name, false)\r\n            .then(res => (persistantId = res));\r\n        }\r\n      }\r\n    }\r\n\r\n    await Promise.all(taskArray).then(() => {\r\n      // Finally update the listing as complete\r\n      if (this._persistantStore) {\r\n        this._persistantStore.putListing(\r\n          persistantId,\r\n          persistantList,\r\n          this._file.name,\r\n          true\r\n        );\r\n      }\r\n    });\r\n    this._persistantData = persistantList;\r\n    return this.getFileList();\r\n  }\r\n\r\n  /**\r\n   * @typedef {Object} MapItem\r\n   * @property {string} name\r\n   * @property {string} category\r\n   * @property {number} baseId\r\n   */\r\n\r\n  /**\r\n   *   Returns a list of all the maps with their name and category.\r\n   *   Uncategorized maps are available only if readFileList have been used before.\r\n   *\r\n   * @returns {Array<MapItem>}\r\n   */\r\n  getMapList() {\r\n    let mapArray = [];\r\n    // If the archive have been scanned for all its file we iterate through the results\r\n    if (this._persistantData) {\r\n      // Filter the maps out of all our files\r\n      let reversedIndex = this.getReverseIndex();\r\n      let maps = this._persistantData\r\n        .filter(file => file.fileType === \"PF_mapc\")\r\n        .filter(\r\n          id => id.baseId === reversedIndex[this.getFileIndex(id.baseId)][0]\r\n        );\r\n\r\n      for (let map of maps) {\r\n        let found = false;\r\n        // Try to see if we already have some informations on this map\r\n        for (let category of MapFileList.maps) {\r\n          let fileMap = category.maps.find(\r\n            item => Number(item.fileName.split(\".data\")[0]) === map.baseId\r\n          );\r\n          if (fileMap) {\r\n            mapArray.push({\r\n              name: fileMap.name,\r\n              category: category.name,\r\n              baseId: map.baseId\r\n            });\r\n            found = true;\r\n            break;\r\n          }\r\n        }\r\n        // If not we register it as Uncategorized\r\n        if (!found) {\r\n          mapArray.push({\r\n            name: map.baseId.toString(),\r\n            category: \"Uncategorized\",\r\n            baseId: map.baseId\r\n          });\r\n        }\r\n      }\r\n    } else {\r\n      // If not then we check only known maps\r\n      for (let category of MapFileList.maps) {\r\n        for (let mapEntry of category.maps) {\r\n          if (Number(mapEntry.fileName.split(\".data\")[0]) in this._indexTable) {\r\n            mapArray.push({\r\n              name: mapEntry.name,\r\n              category: category.name,\r\n              baseId: Number(mapEntry.fileName.split(\".data\")[0])\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return mapArray;\r\n  }\r\n\r\n  /**\r\n   * @typedef {Object} FileItem\r\n   * @property {number} mftId\r\n   * @property {Array<number>} baseIdList\r\n   * @property {number} size\r\n   * @property {number} crc\r\n   * @property {string} fileType\r\n   **/\r\n\r\n  /**\r\n   *   Return the meta table with extra information such as an array of baseIds and the file types.\r\n   *   The filetype is available only if readFileList have been used before of course.\r\n   *\r\n   * @returns {Array<FileItem>}\r\n   */\r\n  getFileList() {\r\n    let typeList = this._persistantData\r\n      ? this._persistantData.map(i => i.fileType)\r\n      : [];\r\n    let reverseBaseIdList = this.getReverseIndex();\r\n\r\n    let fileList = this._fileMetaTable.map((meta, mftId) => {\r\n      let baseIds = reverseBaseIdList[mftId] ? reverseBaseIdList[mftId] : [];\r\n      let type = reverseBaseIdList[mftId]\r\n        ? typeList[baseIds[0]]\r\n        : \"Non-Registered\";\r\n      return {\r\n        mftId: mftId,\r\n        baseIdList: baseIds,\r\n        size: meta.size,\r\n        crc: meta.crc,\r\n        fileType: type\r\n      };\r\n    });\r\n    fileList[0] = {\r\n      mftId: 0,\r\n      baseIdList: [],\r\n      size: 0,\r\n      crc: 0,\r\n      fileType: \"Non-Registered\"\r\n    };\r\n    return fileList;\r\n  }\r\n\r\n  /**\r\n   * @returns {Array<Array<number>>}\r\n   */\r\n  getReverseIndex() {\r\n    return this._indexTable.reduce((reversed, mftId, baseId) => {\r\n      if (mftId in reversed) reversed[mftId].push(baseId);\r\n      else reversed[mftId] = [baseId];\r\n      return reversed;\r\n    }, []);\r\n  }\r\n\r\n  // API Compatibility\r\n\r\n  /**\r\n     * Looks up mft indices for all mapc pack files in the dat. Either looks trough all files or\r\n     * only the list defined in {@link MapFileList}\r\n     *\r\n     * @deprecated Use now the getFileList method.\r\n     * @param  {boolean}   searchAll if true forces re-indexing of entire dat.\r\n     * If false only reads indices specified in \"T3D/MapFileList\".\r\n     * @param  {Function} callback Fired when the list is generated\r\n     *\r\n     * First argument is the a list of mft indices grouped by file type. For exmample:\r\n     *\r\n     * \t\t{\r\n     * \t\t\tmaps:[\r\n     * \t\t\t\t{\r\n     * \t\t\t\t\tname: 'Heart of Maguuma',\r\n     * \t\t\t\t\tmaps: [\r\n     * \t\t\t\t\t\t{fileName:1151420, name:'HoT BWE3 Raid'},\r\n     * \t\t\t\t\t\t{fileName:969663, name:'Verdant Brink}\r\n     * \t\t\t\t\t]\r\n     * \t\t\t\t},\r\n     * \t\t\t\t{\r\n     * \t\t\t\t\tname: 'Unknown maps',\r\n     * \t\t\t\t\tmaps: [\r\n     * \t\t\t\t\t\t{fileName:12345678, name:'Unknown map 12345678'}\r\n     * \t\t\t\t\t]\r\n     * \t\t\t\t}\r\n     * \t\t\t]\r\n\r\n    *\t    };\r\n    */\r\n  readMapListAsync(searchAll, callback) {\r\n    T3D.Logger.log(\r\n      T3D.Logger.TYPE_WARNING,\r\n      \"LocalReader.readMapListAsync is deprecated !\"\r\n    );\r\n\r\n    // Let's preserve the old output way\r\n    function restoreOuput(array) {\r\n      let returnArray = [];\r\n      for (let elt of array) {\r\n        let category = returnArray.findIndex(i => i.name === elt.category);\r\n        if (category === -1) {\r\n          category =\r\n            returnArray.push({\r\n              name: elt.category,\r\n              maps: []\r\n            }) - 1;\r\n        }\r\n        returnArray[category].maps.push({\r\n          fileName: elt.baseId,\r\n          name: elt.name\r\n        });\r\n      }\r\n      // And resort it in order\r\n      returnArray.sort((i, j) => {\r\n        if (i.name < j.name) return -1;\r\n        if (i.name > j.name) return 1;\r\n        return 0;\r\n      });\r\n      return {\r\n        maps: returnArray\r\n      };\r\n    }\r\n\r\n    /// If seachAll flag is true, force a deep search\r\n    if (searchAll) {\r\n      this.readFileList().then(() => {\r\n        callback(restoreOuput(this.getMapList()));\r\n      });\r\n    } else {\r\n      callback(restoreOuput(this.getMapList()));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reads the file type of each file in the dat and stores the resulting list in\r\n   * the browser's local storage.\r\n   *\r\n   * @deprecated Use now the readFileList or getFileList methods.\r\n   * @param  {Function} callback Fired when the list is generated and stores\r\n   *\r\n   * First argument is the a list of mft indices grouped by file type.\r\n   */\r\n  readFileListAsync(callback) {\r\n    T3D.Logger.log(\r\n      T3D.Logger.TYPE_WARNING,\r\n      \"LocalReader.readFileListAsync is deprecated !\"\r\n    );\r\n\r\n    // Because the API changed we reform the data as wanted previously\r\n    this.readFileList().then(result => {\r\n      let returnObj = {};\r\n      for (let fileEntry of result) {\r\n        if (returnObj[fileEntry.fileType] === undefined) {\r\n          returnObj[fileEntry.fileType] = [];\r\n        }\r\n        returnObj[fileEntry.fileType].push(fileEntry.mftId);\r\n      }\r\n      callback(returnObj);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Reads data from a file in the dat.\r\n   *\r\n   * @deprecated Use now the Promise-based method readFile.\r\n   * @param  {Number}   baseId   Base or File id of the texture to load\r\n   * @param  {Function} callback Fires when the inflater has read the data.\r\n   *\r\n   * The passed arguments are\r\n   * -ArrayBuffer raw data\r\n   * -Number DXT Type if applicable\r\n   * -Number image width if applicable\r\n   * -Number image height if applicable\r\n   *\r\n   *\r\n   * @param  {boolean}  isImage\r\n   * @param  {boolean}   raw      If true, any infation is skipped and raw data is returned.\r\n   */\r\n  loadFile(baseId, callback, isImage, raw) {\r\n    T3D.Logger.log(\r\n      T3D.Logger.TYPE_WARNING,\r\n      \"LocalReader.loadFile is deprecated !\"\r\n    );\r\n    this.readFile(baseId, isImage, raw, undefined, undefined, true).then(\r\n      result => {\r\n        if (result.buffer === undefined) return callback(null);\r\n        callback(\r\n          result.buffer,\r\n          result.dxtType,\r\n          result.imageWidth,\r\n          result.imageHeight\r\n        );\r\n      }\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Reads a bitmap from a texture file in the dat.\r\n   *\r\n   * @deprecated\r\n   * @param  {Number}   baseId   Base or File id of the texture to load\r\n   * @param  {Function} callback Fires when the inflater has read the texture data.\r\n   *\r\n   * The passed arguments are\r\n   * -ArrayBuffer Bitmap\r\n   * -Number DXT Type\r\n   * -Number image width\r\n   * -Number image height\r\n   *\r\n   */\r\n  loadTextureFile(baseId, callback) {\r\n    T3D.Logger.log(\r\n      T3D.Logger.TYPE_WARNING,\r\n      \"LocalReader.loadTextureFile is deprecated !\"\r\n    );\r\n\r\n    /// Old way:\r\n    // this.loadFile(baseId, callback, true);\r\n\r\n    /// New way:\r\n    this.readFile(\r\n      baseId,\r\n      undefined, // isImage\r\n      undefined, // raw\r\n      undefined, // fileLength\r\n      undefined, // extractLength\r\n      true\r\n    ).then(result => {\r\n      if (result.buffer === undefined) return callback(null);\r\n      callback(\r\n        result.buffer,\r\n        result.dxtType,\r\n        result.imageWidth,\r\n        result.imageHeight\r\n      );\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Used to read the cached list of files corresponding to the reader's .dat from the localStorage.\r\n   * Now kept only for backward compatibility, but doesn't do anything.\r\n   * Please use getFileList now.\r\n   *\r\n   * @deprecated\r\n   */\r\n  loadFileList() {\r\n    T3D.Logger.log(\r\n      T3D.Logger.TYPE_WARNING,\r\n      \"LocalReader.loadFileList is deprecated !\"\r\n    );\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Used to read the cached list of maps corresponding to the reader's .dat from the localStorage.\r\n   * Now kept only for backward compatibility, but doesn't do anything.\r\n   * Please use getMapList now.\r\n   *\r\n   * @deprecated\r\n   */\r\n  loadMapList() {\r\n    T3D.Logger.log(\r\n      T3D.Logger.TYPE_WARNING,\r\n      \"LocalReader.loadMapList is deprecated !\"\r\n    );\r\n    return undefined;\r\n  }\r\n\r\n  // Private\r\n\r\n  /**\r\n   * @private\r\n   * @param {number} baseId\r\n   * @param {Array<{baseId: number, crc: number, size: number, fileType: string}>} persistantData\r\n   * @returns {{scan: boolean, change: string }}\r\n   */\r\n  _needsScan(baseId, persistantData) {\r\n    if (baseId <= 0) {\r\n      return {\r\n        change: \"none\",\r\n        scan: false\r\n      };\r\n    }\r\n\r\n    let mftId = this.getFileIndex(baseId);\r\n    let metaData = this.getFileMeta(mftId);\r\n\r\n    if (metaData === undefined && !(baseId in persistantData)) {\r\n      // Nothing interesting\r\n      return {\r\n        change: \"none\",\r\n        scan: false\r\n      };\r\n    } else if (metaData === undefined) {\r\n      // If the file have been deleted\r\n      return {\r\n        change: \"removed\",\r\n        scan: false\r\n      };\r\n    } else if (!(baseId in persistantData)) {\r\n      // If the file is new\r\n      return {\r\n        change: \"added\",\r\n        scan: true\r\n      };\r\n    } else if (\r\n      metaData.size !== persistantData[baseId].size ||\r\n      metaData.crc !== persistantData[baseId].crc\r\n    ) {\r\n      // If the size or crc don't match\r\n      return {\r\n        change: \"modified\",\r\n        scan: true\r\n      };\r\n    } else {\r\n      // If everything is the same\r\n      return {\r\n        change: \"none\",\r\n        scan: false\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reads the file type and gives back an object with fileType, crc and size informations\r\n   * @param {number} baseId\r\n   * @param {Array<{baseId: number, crc: number, size: number, fileType: string}>} persistantData\r\n   * @returns {Promise<{fileType: string, crc: number, size: number}>}\r\n   */\r\n  async readFileType(baseId) {\r\n    if (!this._fileTypeCache) this._fileTypeCache = [];\r\n\r\n    let mftId = this.getFileIndex(baseId);\r\n    let metaData = this.getFileMeta(mftId);\r\n\r\n    let fileType;\r\n    if (this._fileTypeCache[baseId] !== undefined) {\r\n      fileType = this._fileTypeCache[baseId];\r\n    } else {\r\n      let fileBuffer = (await this.readFile(\r\n        mftId,\r\n        false,\r\n        false,\r\n        Math.min(metaData.size, 1000),\r\n        32\r\n      )).buffer;\r\n      if (fileBuffer === undefined) return undefined;\r\n      fileType = FileTypes.getFileType(new DataStream(fileBuffer));\r\n    }\r\n    return {\r\n      fileType: fileType,\r\n      crc: metaData.crc,\r\n      size: metaData.size\r\n    };\r\n  }\r\n}\r\n\r\nmodule.exports = LocalReader;\r\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/// Indexed DB versioning\nconst DB_VERSION = 4;\n\n/**\n * This class handles offline storage of the .dat indexes and files metadata\n * @class PersistantStore\n */\nclass PersistantStore {\n  constructor() {\n    // They may be multiple connection request issued at the same time, but it's actually okay since\n    // as soon as they are registered, the not-used ones will get garbage collected\n    this._dbConnection = undefined;\n    this._getConnection(() => {});\n  }\n\n  /**\n   *   Initialize the IndexedDB connection and manages version changes.\n   *\n   * @async\n   * @private\n   * @returns {Promise<IDBDatabase>} Promise to the Database connection\n   */\n  _getConnection() {\n    return new Promise((resolve, reject) => {\n      if (this._dbConnection) resolve(this._dbConnection);\n\n      // Let us open our database\n      let request = window.indexedDB.open(\"Tyria3DLibrary\", DB_VERSION);\n\n      /// onblocked is fired when the db needs an upgrade but an older version is opened in another tab\n      request.onblocked = event => {\n        T3D.Logger.log(\n          T3D.Logger.TYPE_ERROR,\n          \"The T3D persistant database cannot be upgraded while the app is opened somewhere else.\"\n        );\n      };\n\n      /// fired when the database needs to be upgraded (or the first time)\n      request.onupgradeneeded = event => {\n        /** @type {IDBDatabase} */\n        let db = event.target.result;\n        let currentVersion = event.oldVersion;\n\n        if (currentVersion < 2) {\n          db.createObjectStore(\"listings\", {\n            autoIncrement: true\n          });\n        }\n\n        if (currentVersion < 3) {\n          let storeListing = event.currentTarget.transaction.objectStore(\n            \"listings\"\n          );\n          storeListing.createIndex(\"filename\", \"filename\", {\n            unique: false\n          });\n        }\n      };\n\n      request.onsuccess = event => {\n        this._dbConnection = event.target.result;\n        this.isReady = true;\n        resolve(this._dbConnection);\n      };\n\n      request.onerror = event => {\n        T3D.Logger.log(\n          T3D.Logger.TYPE_ERROR,\n          \"The T3D persistant database could not be opened.\"\n        );\n        reject(new Error(\"IndexedDB failed to open\"));\n      };\n    });\n  }\n\n  /**\n   *   Add or update a listing into the database\n   *\n   * @async\n   * @param {number|undefined} id This ID doesn't really matter, it's just the index of the object in the database, can be undefined\n   * @param {Array} listing\n   * @param {string} fileName .dat file name, allows to have multiple listings for different .dat files.\n   * @param {boolean} isComplete Keep back the information if that was the last update on the current scan or not.\n   * @returns {Promise<number>} On success, the number is the object key in the database\n   */\n  putListing(id, listing, fileName, isComplete) {\n    return new Promise((resolve, reject) => {\n      this._getConnection().then(db => {\n        let store = db\n          .transaction([\"listings\"], \"readwrite\")\n          .objectStore(\"listings\");\n\n        let request = id\n          ? store.put(\n              {\n                array: listing,\n                filename: fileName,\n                complete: isComplete\n              },\n              id\n            )\n          : store.put({\n              array: listing,\n              name: fileName\n            });\n\n        request.onsuccess = event => {\n          resolve(request.result);\n        };\n        request.onerror = event => {\n          reject(new Error(\"Could not put listing to Indexed DB\"));\n        };\n      });\n    });\n  }\n\n  /**\n   * Returns the last valid listing in the database\n   *\n   * @async\n   * @param {string} fileName .dat file name, allows to have multiple listings for different .dat files.\n   * @returns {Promise<{array: Array, key: number, complete: boolean}>}\n   *      array: the last listing\n   *      key: the index of the last listing in the database\n   */\n  getLastListing(fileName) {\n    return new Promise((resolve, reject) => {\n      this._getConnection().then(db => {\n        let listingsStore = db\n          .transaction([\"listings\"], \"readonly\")\n          .objectStore(\"listings\")\n          .index(\"filename\");\n\n        listingsStore.openCursor(\n          IDBKeyRange.only(fileName),\n          \"prev\"\n        ).onsuccess = event => {\n          let cursor = event.target.result;\n          if (!cursor) {\n            resolve({\n              array: [],\n              key: undefined,\n              complete: true\n            });\n          } else {\n            resolve({\n              array: cursor.value.array,\n              key: cursor.primaryKey,\n              complete: cursor.value.complete\n            });\n          }\n        };\n      });\n    });\n  }\n}\n\nmodule.exports = PersistantStore;\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * A Logger class for T3D\n *\n * This satic class defines severity levels of messages and provides\n * basic logging functionality. Replacing the reference to\n *\n * @namespace\n * @static\n */\nlet Logger = {};\n\n/**\n * @readonly\n * @property {number} TYPE_ERROR\n */\nLogger.TYPE_ERROR = 4;\n\n/**\n * @readonly\n * @property {number} TYPE_WARNING\n */\nLogger.TYPE_WARNING = 3;\n\n/**\n * @readonly\n * @property {number} TYPE_MESSAGE\n */\nLogger.TYPE_MESSAGE = 2;\n\n/**\n * @readonly\n * @property {number} TYPE_PROGRESS\n */\nLogger.TYPE_PROGRESS = 1;\n\n/**\n * @readonly\n * @property {number} TYPE_DEBUG\n */\nLogger.TYPE_DEBUG = 0;\n\n/**\n * The logging functions, indexed by severity/type.\n *\n * @property logFunctions\n * @type Function[]\n */\nLogger.logFunctions = new Array(5);\n\n/**\n * Main logging method. Takes 1 to N arguments. If there are more than 1 arguments\n * the first argument is interpreted as severity. If there is only one argument\n * severity defaults to\n * {{#crossLink \"Logger/TYPE_MESSAGE:property\"}}{{/crossLink}}.\n *  \n * The following arguments are passed to a logging function matching the\n * severity.\n * \n \n * \n */\nLogger.log = function() {\n  /// Require at least 1 argument\n  if (arguments.length === 0) {\n    return;\n  }\n\n  /// Parse arguments to an actual array\n  let argArr = Logger.argsToArr(arguments);\n\n  /// Default to message if just one argument was passed\n  if (argArr.length === 1) {\n    argArr.unshift(Logger.TYPE_MESSAGE);\n  }\n\n  /// Otherwise 1st arg is severity, log/warn/error\n  let severity = Math.max(\n    0,\n    Math.min(Logger.logFunctions.length, argArr.shift())\n  );\n  let logFunc = Logger.logFunctions[severity];\n\n  /// Ouput the rest of the arguments\n  logFunc.apply(this, argArr);\n};\n\nLogger.argsToArr = function(args) {\n  let argArr = new Array(args.length);\n  for (let i = 0; i < argArr.length; ++i) {\n    argArr[i] = args[i];\n  }\n  return argArr;\n};\n\nLogger.logFunctions[Logger.TYPE_ERROR] = function() {\n  console.error.apply(console, arguments);\n};\n\nLogger.logFunctions[Logger.TYPE_WARNING] = function() {\n  console.warn.apply(console, arguments);\n};\n\nLogger.logFunctions[Logger.TYPE_MESSAGE] = function() {\n  console.log.apply(console, arguments);\n};\n\nLogger.logFunctions[Logger.TYPE_PROGRESS] = function() {\n  let argArr = Logger.argsToArr(arguments);\n  argArr.unshift(\"Progress: \");\n  console.log.apply(console, argArr);\n};\n\nLogger.logFunctions[Logger.TYPE_DEBUG] = function() {\n  let argArr = Logger.argsToArr(arguments);\n  console.debug.apply(console, argArr);\n};\n\nmodule.exports = Logger;\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nmodule.exports = {\n  /**\n   * @property maps\n   * @type {Array.<{name: String, maps: Array.<{fileName: String, name: String}>}>}\n   */\n  maps: [\n    {\n      name: \"01. Shiverpeaks\",\n      maps: [\n        {\n          fileName: \"125199.data\",\n          name: \"Wayfarer Foothills (0)\"\n        },\n        {\n          fileName: \"187611.data\",\n          name: \"Wayfarer Foothills (1)\"\n        },\n        {\n          fileName: \"568778.data\",\n          name: \"Cragstead\"\n        },\n        {\n          fileName: \"132434.data\",\n          name: \"Hoelbrak (0)\"\n        },\n        {\n          fileName: \"197122.data\",\n          name: \"Hoelbrak (1)\"\n        },\n        {\n          fileName: \"1966018.data\",\n          name: \"Hoelbrak (2)\"\n        },\n        {\n          fileName: \"124093.data\",\n          name: \"Snowden Drifts (0)\"\n        },\n        {\n          fileName: \"186397.data\",\n          name: \"Snowden Drifts (1)\"\n        },\n        {\n          fileName: \"275155.data\",\n          name: \"Dredgehaunt Cliffs\"\n        },\n        {\n          fileName: \"276252.data\",\n          name: \"Frostgorge Sound\"\n        },\n        {\n          fileName: \"277587.data\",\n          name: \"Lornar's Pass\"\n        },\n        {\n          fileName: \"278717.data\",\n          name: \"Timberline Falls (0)\"\n        },\n        {\n          fileName: \"846866.data\",\n          name: \"Timberline Falls (1)\"\n        },\n        {\n          fileName: \"1018612.data\",\n          name: \"Timberline Falls (2)\"\n        },\n        {\n          fileName: \"295282.data\",\n          name: \"Eye of the North\"\n        }\n      ]\n    },\n    {\n      name: \"02. Ascalon\",\n      maps: [\n        {\n          fileName: \"126118.data\",\n          name: \"Plains of Ashford (0)\"\n        },\n        {\n          fileName: \"188591.data\",\n          name: \"Plains of Ashford (1)\"\n        },\n        {\n          fileName: \"127888.data\",\n          name: \"Diessa Plateau (0)\"\n        },\n        {\n          fileName: \"190490.data\",\n          name: \"Diessa Plateau (1)\"\n        },\n        {\n          fileName: \"131944.data\",\n          name: \"Black Citadel (0)\"\n        },\n        {\n          fileName: \"196585.data\",\n          name: \"Black Citadel (1)\"\n        },\n        {\n          fileName: \"1968107.data\",\n          name: \"Black Citadel (2)\"\n        },\n        {\n          fileName: \"280025.data\",\n          name: \"Blazeridge Steppes\"\n        },\n        {\n          fileName: \"281313.data\",\n          name: \"Fireheart Rise\"\n        },\n        {\n          fileName: \"282668.data\",\n          name: \"Iron Marches\"\n        },\n        {\n          fileName: \"283574.data\",\n          name: \"Fields of Ruin\"\n        }\n      ]\n    },\n    {\n      name: \"03. Kryta\",\n      maps: [\n        {\n          fileName: \"191000.data\",\n          name: \"Lion's Arch (0)\"\n        },\n        {\n          fileName: \"814803.data\",\n          name: \"Lion's Arch (1)\"\n        },\n        {\n          fileName: \"1019669.data\",\n          name: \"Lion's Arch (Legacy)\"\n        },\n        {\n          fileName: \"1796999.data\",\n          name: \"Lion's Arch (2)\"\n        },\n        {\n          fileName: \"1869665.data\",\n          name: \"Lion's Arch (3)\"\n        },\n        {\n          fileName: \"1968576.data\",\n          name: \"Lion's Arch (4)\"\n        },\n        {\n          fileName: \"128151.data\",\n          name: \"Divinity's Reach (0)\"\n        },\n        {\n          fileName: \"191265.data\",\n          name: \"Divinity's Reach (1)\"\n        },\n        {\n          fileName: \"705746.data\",\n          name: \"Divinity's Reach (2)\"\n        },\n        {\n          fileName: \"1968748.data\",\n          name: \"Divinity's Reach (3)\"\n        },\n        {\n          fileName: \"129834.data\",\n          name: \"North of Divinity's Reach (0)\"\n        },\n        {\n          fileName: \"193081.data\",\n          name: \"North of Divinity's Reach (1)\"\n        },\n        {\n          fileName: \"129524.data\",\n          name: \"Queensdale (0)\"\n        },\n        {\n          fileName: \"192711.data\",\n          name: \"Queensdale (1)\"\n        },\n        {\n          fileName: \"130970.data\",\n          name: \"Kessex Hills (0)\"\n        },\n        {\n          fileName: \"194288.data\",\n          name: \"Kessex Hills (1)\"\n        },\n        {\n          fileName: \"672138.data\",\n          name: \"Kessex Hills (2)\"\n        },\n        {\n          fileName: \"861815.data\",\n          name: \"Kessex Hills (3)\"\n        },\n        {\n          fileName: \"286945.data\",\n          name: \"Bloodtide Coast\"\n        },\n        {\n          fileName: \"287870.data\",\n          name: \"Harathi Hinterlands\"\n        },\n        {\n          fileName: \"289176.data\",\n          name: \"Gendarran Fields\"\n        },\n        {\n          fileName: \"295005.data\",\n          name: \"Chantry of Secrets\"\n        },\n        {\n          fileName: \"294938.data\",\n          name: \"Claw Island\"\n        }\n      ]\n    },\n    {\n      name: \"04. Maguuma Jungle\",\n      maps: [\n        {\n          fileName: \"195149.data\",\n          name: \"Caledon Forest\"\n        },\n        {\n          fileName: \"195493.data\",\n          name: \"Metrica Province\"\n        },\n        {\n          fileName: \"922320.data\",\n          name: \"Metrica Province Instance\"\n        },\n        {\n          fileName: \"198076.data\",\n          name: \"The Grove (0)\"\n        },\n        {\n          fileName: \"1969341.data\",\n          name: \"The Grove (1)\"\n        },\n        {\n          fileName: \"198272.data\",\n          name: \"Rata Sum (0)\"\n        },\n        {\n          fileName: \"1968896.data\",\n          name: \"Rata Sum (1)\"\n        },\n        {\n          fileName: \"291064.data\",\n          name: \"Mount Maelstrom\"\n        },\n        {\n          fileName: \"292254.data\",\n          name: \"Sparkfly Fen\"\n        },\n        {\n          fileName: \"293307.data\",\n          name: \"Brisban Wildlands\"\n        }\n      ]\n    },\n    {\n      name: \"05. Ruins of Orr\",\n      maps: [\n        {\n          fileName: \"284829.data\",\n          name: \"Straits of Devastation\"\n        },\n        {\n          fileName: \"285089.data\",\n          name: \"Malchor's Leap\"\n        },\n        {\n          fileName: \"285634.data\",\n          name: \"Cursed Shore\"\n        },\n        {\n          fileName: \"295179.data\",\n          name: \"Cathedral of Hidden Depths\"\n        },\n        {\n          fileName: \"295962.data\",\n          name: \"A Light in the Darkness\"\n        }\n      ]\n    },\n    {\n      name: \"06. Living World S1\",\n      maps: [\n        {\n          fileName: \"520479.data\",\n          name: \"Southsun Cove\"\n        },\n        {\n          fileName: \"679089.data\",\n          name: \"Tower of Nightmares\"\n        }\n      ]\n    },\n    {\n      name: \"07. Living World S2\",\n      maps: [\n        {\n          fileName: \"836211.data\",\n          name: \"Dry top (0)\"\n        },\n        {\n          fileName: \"861770.data\",\n          name: \"Dry top (1)\"\n        },\n        {\n          fileName: \"909361.data\",\n          name: \"The Silverwastes (0)\"\n        },\n        {\n          fileName: \"996202.data\",\n          name: \"The Silverwastes (1)\"\n        },\n        {\n          fileName: \"908730.data\",\n          name: \"Glint's Lair\"\n        }\n      ]\n    },\n    {\n      name: \"08. Heart of Maguuma\",\n      maps: [\n        {\n          fileName: \"969663.data\",\n          name: \"Verdant Brink\"\n        },\n        {\n          fileName: \"1262460.data\",\n          name: \"Hearts and Minds\"\n        },\n        {\n          fileName: \"969964.data\",\n          name: \"Unknown Airship in tree\"\n        },\n        {\n          fileName: \"1262310.data\",\n          name: \"Dragon Stand\"\n        },\n        {\n          fileName: \"1263739.data\",\n          name: \"Tarir\"\n        },\n        {\n          fileName: \"1264291.data\",\n          name: \"Tangled Depths\"\n        }\n      ]\n    },\n    {\n      name: \"09. Living World S3\",\n      maps: [\n        {\n          fileName: \"1472635.data\",\n          name: \"(E1) Bloodstone Fen\"\n        },\n        {\n          fileName: \"1498071.data\",\n          name: \"(E2) Taimi Simulator\"\n        },\n        {\n          fileName: \"1498578.data\",\n          name: \"(E2) Ring of Fire\"\n        },\n        {\n          fileName: \"1605211.data\",\n          name: \"(E3) Bitterfrost Frontier\"\n        },\n        {\n          fileName: \"1645474.data\",\n          name: \"(E4) Caudecus Manor\"\n        },\n        {\n          fileName: \"1646520.data\",\n          name: \"(E4) Lake Doric\"\n        },\n        {\n          fileName: \"1682493.data\",\n          name: \"(E5) Draconis Mons\"\n        },\n        {\n          fileName: \"1682763.data\",\n          name: \"(E5) Titan's Throat\"\n        },\n        {\n          fileName: \"1734839.data\",\n          name: \"(E6) White Mantle Fortress\"\n        },\n        {\n          fileName: \"1735346.data\",\n          name: \"(E6) Siren's Landing\"\n        },\n        {\n          fileName: \"1735440.data\",\n          name: \"(E6) Shining Blade Headquarters\"\n        }\n      ]\n    },\n    {\n      name: \"10. Crystal Desert\",\n      maps: [\n        {\n          fileName: \"1794574.data\",\n          name: \"Crystal Oasis\"\n        },\n        {\n          fileName: \"1833034.data\",\n          name: \"Desert Highlands\"\n        },\n        {\n          fileName: \"1833726.data\",\n          name: \"PoF story instances\"\n        },\n        {\n          fileName: \"1839188.data\",\n          name: \"Domain of Vabbi\"\n        },\n        {\n          fileName: \"1840103.data\",\n          name: \"Elon Riverlands\"\n        },\n        {\n          fileName: \"1840368.data\",\n          name: \"Kormir Sanctuary\"\n        },\n        {\n          fileName: \"1842533.data\",\n          name: \"The Desolation\"\n        }\n      ]\n    },\n    {\n      name: \"11. Living World S4\",\n      maps: [\n        {\n          fileName: \"1901428.data\",\n          name: \"(E1) Fahranur\"\n        },\n        {\n          fileName: \"1902235.data\",\n          name: \"(E1) Istan\"\n        },\n        {\n          fileName: \"1903523.data\",\n          name: \"(E1) Crystal Oasis\"\n        },\n        {\n          fileName: \"1954984.data\",\n          name: \"(E2) Desert Highlands\"\n        },\n        {\n          fileName: \"1955224.data\",\n          name: \"(E2) Inquest Lab Tower\"\n        },\n        {\n          fileName: \"1955471.data\",\n          name: \"(E2) Rata Primus\"\n        },\n        {\n          fileName: \"1955642.data\",\n          name: \"(E2) Divinity's Reach\"\n        },\n        {\n          fileName: \"1955915.data\",\n          name: \"(E2) Mount Maelstrom\"\n        },\n        {\n          fileName: \"1956140.data\",\n          name: \"(E2) Frostgorge Sound\"\n        },\n        {\n          fileName: \"1956245.data\",\n          name: \"(E2) Void\"\n        },\n        {\n          fileName: \"1956299.data\",\n          name: \"(E2) Hided Inquest Lab\"\n        },\n        {\n          fileName: \"1957526.data\",\n          name: \"(E2) Sandswept Isles\"\n        }\n      ]\n    },\n    {\n      name: \"12. Seasonal Activities\",\n      maps: [\n        {\n          fileName: \"506592.data\",\n          name: \"Ascent to Madness\"\n        },\n        {\n          fileName: \"506670.data\",\n          name: \"Mad King's Labyrinth (Past)\"\n        },\n        {\n          fileName: \"662436.data\",\n          name: \"Mad King's Labyrinth (Present)\"\n        },\n        {\n          fileName: \"506739.data\",\n          name: \"Mad King's Clock Tower\"\n        },\n        {\n          fileName: \"622681.data\",\n          name: \"The Crown Pavilion\"\n        },\n        {\n          fileName: \"569756.data\",\n          name: \"SAB Hub (0)\"\n        },\n        {\n          fileName: \"636133.data\",\n          name: \"SAB Hub (1)\"\n        },\n        {\n          fileName: \"635555.data\",\n          name: \"SAB World 1\"\n        },\n        {\n          fileName: \"635960.data\",\n          name: \"SAB World 2\"\n        },\n        {\n          fileName: \"606255.data\",\n          name: \"Zephyr Sanctum\"\n        },\n        {\n          fileName: \"529896.data\",\n          name: \"Tixx's Infinirarium\"\n        },\n        {\n          fileName: \"529945.data\",\n          name: \"Winter Wonderland\"\n        }\n      ]\n    },\n    {\n      name: \"13. Activites\",\n      maps: [\n        {\n          fileName: \"605983.data\",\n          name: \"Sanctum Sprint\"\n        },\n        {\n          fileName: \"606030.data\",\n          name: \"Basket Brawl\"\n        }\n      ]\n    },\n    {\n      name: \"14. Dungeons\",\n      maps: [\n        {\n          fileName: \"126840.data\",\n          name: \"Ascalonian Catacombs (0)\"\n        },\n        {\n          fileName: \"189364.data\",\n          name: \"Ascalonian Catacombs (1)\"\n        },\n        {\n          fileName: \"275474.data\",\n          name: \"Sorrow's Embrace\"\n        },\n        {\n          fileName: \"276520.data\",\n          name: \"Honor of the Waves\"\n        },\n        {\n          fileName: \"284039.data\",\n          name: \"Citadel of Flame\"\n        },\n        {\n          fileName: \"287214.data\",\n          name: \"Caudecus's Manor\"\n        },\n        {\n          fileName: \"291284.data\",\n          name: \"Twilight Arbor (0)\"\n        },\n        {\n          fileName: \"645968.data\",\n          name: \"Twilight Arbor (1)\"\n        },\n        {\n          fileName: \"293606.data\",\n          name: \"Crucible of Eternity\"\n        },\n        {\n          fileName: \"473930.data\",\n          name: \"The Ruined City of Arah\"\n        },\n        {\n          fileName: \"473765.data\",\n          name: \"Arah - Story\"\n        },\n        {\n          fileName: \"580061.data\",\n          name: \"Molten Facility\"\n        },\n        {\n          fileName: \"595722.data\",\n          name: \"Aetherblade Retreat\"\n        }\n      ]\n    },\n    {\n      name: \"15. Fractals\",\n      maps: [\n        {\n          fileName: \"519839.data\",\n          name: \"Fractals of the Mists\"\n        },\n        {\n          fileName: \"697450.data\",\n          name: \"Thaumanova Reactor\"\n        },\n        {\n          fileName: \"1426653.data\",\n          name: \"Cliffside Fractal\"\n        },\n        {\n          fileName: \"1472361.data\",\n          name: \"Chaos Isle Fractal\"\n        },\n        {\n          fileName: \"1472382.data\",\n          name: \"Snowblind Fractal\"\n        },\n        {\n          fileName: \"1472406.data\",\n          name: \"Swampland Fractal\"\n        },\n        {\n          fileName: \"1498016.data\",\n          name: \"Mistlock Observatory\"\n        },\n        {\n          fileName: \"1498798.data\",\n          name: \"Aetherblade/Mai Trin Fractal\"\n        },\n        {\n          fileName: \"1605344.data\",\n          name: \"Nightmare Fractal\"\n        },\n        {\n          fileName: \"1733857.data\",\n          name: \"Shattered Observatory Fractal\"\n        },\n        {\n          fileName: \"1733961.data\",\n          name: \"Mistlock Sanctuary\"\n        },\n        {\n          fileName: \"1905739.data\",\n          name: \"Molten Boss Fractal\"\n        },\n        {\n          fileName: \"1905889.data\",\n          name: \"Twilight Oasis Fractal\"\n        }\n      ]\n    },\n    {\n      name: \"16. Raid\",\n      maps: [\n        {\n          fileName: \"1151420.data\",\n          name: \"(W1) Spirit Vale\"\n        },\n        {\n          fileName: \"1383309.data\",\n          name: \"(W2) Salvation Pass\"\n        },\n        {\n          fileName: \"1427048.data\",\n          name: \"Special Forces Training Area\"\n        },\n        {\n          fileName: \"1454070.data\",\n          name: \"(W3) Stronghold of the Faithful\"\n        },\n        {\n          fileName: \"1645215.data\",\n          name: \"(W4) Bastion of the Penitent\"\n        },\n        {\n          fileName: \"1906329.data\",\n          name: \"(W5) Hall of Chains\"\n        }\n      ]\n    },\n    {\n      name: \"17. Structured PvP\",\n      maps: [\n        {\n          fileName: \"871093.data\",\n          name: \"Original Stronghold\"\n        },\n        {\n          fileName: \"870987.data\",\n          name: \"Battle of Champion's Dusk (0)\"\n        },\n        {\n          fileName: \"1666233.data\",\n          name: \"Battle of Champion's Dusk (1)\"\n        },\n        {\n          fileName: \"132570.data\",\n          name: \"Heart of the Mists (0)\"\n        },\n        {\n          fileName: \"197249.data\",\n          name: \"Heart of the Mists (1)\"\n        },\n        {\n          fileName: \"1734729.data\",\n          name: \"Heart of the Mists (2)\"\n        },\n        {\n          fileName: \"1712986.data\",\n          name: \"Hall of the Mists\"\n        },\n        {\n          fileName: \"132710.data\",\n          name: \"The Battle of Khylo (0)\"\n        },\n        {\n          fileName: \"197402.data\",\n          name: \"The Battle of Khylo (1)\"\n        },\n        {\n          fileName: \"132837.data\",\n          name: \"Forest of Niflhel (0)\"\n        },\n        {\n          fileName: \"197545.data\",\n          name: \"Forest of Niflhel (1)\"\n        },\n        {\n          fileName: \"376916.data\",\n          name: \"Legacy of the Foefire\"\n        },\n        {\n          fileName: \"467374.data\",\n          name: \"Raid on the Capricorn\"\n        },\n        {\n          fileName: \"520609.data\",\n          name: \"Temple of the Silent Storm\"\n        },\n        {\n          fileName: \"579383.data\",\n          name: \"Skyhammer (0)\"\n        },\n        {\n          fileName: \"677968.data\",\n          name: \"Skyhammer (1)\"\n        },\n        {\n          fileName: \"1934470.data\",\n          name: \"Skyhammer (2)\"\n        },\n        {\n          fileName: \"791564.data\",\n          name: \"Courtyard (0)\"\n        },\n        {\n          fileName: \"1713054.data\",\n          name: \"Courtyard (1)\"\n        },\n        {\n          fileName: \"556199.data\",\n          name: \"Spirit Watch (0)\"\n        },\n        {\n          fileName: \"1473061.data\",\n          name: \"Spirit Watch (1)\"\n        },\n        {\n          fileName: \"506539.data\",\n          name: \"Reaper's Rumble\"\n        },\n        {\n          fileName: \"529718.data\",\n          name: \"Snowball Mayhem\"\n        },\n        {\n          fileName: \"595582.data\",\n          name: \"Dragon Ball Arena\"\n        },\n        {\n          fileName: \"617120.data\",\n          name: \"Aspect Arena\"\n        },\n        {\n          fileName: \"1644624.data\",\n          name: \"Revenge of the Capricorn\"\n        },\n        {\n          fileName: \"1704155.data\",\n          name: \"Eternal Coliseum\"\n        }\n      ]\n    },\n    {\n      name: \"18. World vs World\",\n      maps: [\n        {\n          fileName: \"131235.data\",\n          name: \"Eternal Battlegrounds (0)\"\n        },\n        {\n          fileName: \"195806.data\",\n          name: \"Eternal Battlegrounds (1)\"\n        },\n        {\n          fileName: \"1885693.data\",\n          name: \"Eternal Battlegrounds (2)\"\n        },\n        {\n          fileName: \"1918037.data\",\n          name: \"Eternal Battlegrounds (3)\"\n        },\n        {\n          fileName: \"131574.data\",\n          name: \"Alpine Borderlands (0)\"\n        },\n        {\n          fileName: \"641501.data\",\n          name: \"Alpine Borderlands (1)\"\n        },\n        {\n          fileName: \"1799855.data\",\n          name: \"Alpine Borderlands (2)\"\n        },\n        {\n          fileName: \"1647236.data\",\n          name: \"Desert Borderlands (0)\"\n        },\n        {\n          fileName: \"1799442.data\",\n          name: \"Desert Borderlands (1)\"\n        },\n        {\n          fileName: \"736241.data\",\n          name: \"Edge of the Mists\"\n        }\n      ]\n    },\n    {\n      name: \"19. Guild Halls\",\n      maps: [\n        {\n          fileName: \"1255378.data\",\n          name: \"Gilded Hollow\"\n        },\n        {\n          fileName: \"1256064.data\",\n          name: \"Lost Precipice\"\n        },\n        {\n          fileName: \"1843274.data\",\n          name: \"Windswept Haven\"\n        }\n      ]\n    },\n    {\n      name: \"20. Concept and not released\",\n      maps: [\n        {\n          fileName: \"122695.data\",\n          name: \"Empty Plane\"\n        },\n        {\n          fileName: \"184799.data\",\n          name: \"Empty Plane v1\"\n        },\n        {\n          fileName: \"197562.data\",\n          name: \"Empty Plane v2\"\n        },\n        {\n          fileName: \"875614.data\",\n          name: \"Unknown Mists Platforms\"\n        },\n        {\n          fileName: \"132853.data\",\n          name: \"Empty Box\"\n        },\n        {\n          fileName: \"1255516.data\",\n          name: \"Guild Coliseum\"\n        },\n        {\n          fileName: \"1498193.data\",\n          name: \"Concept sPVP Map 1\"\n        },\n        {\n          fileName: \"1513556.data\",\n          name: \"Concept sPVP Map 2\"\n        },\n        {\n          fileName: \"1513607.data\",\n          name: \"Concept sPVP Map 3\"\n        },\n        {\n          fileName: \"1513620.data\",\n          name: \"Concept sPVP Map 4\"\n        },\n        {\n          fileName: \"1513675.data\",\n          name: \"Concept sPVP Map 5\"\n        },\n        {\n          fileName: \"1712945.data\",\n          name: \"Concept sPVP Map 6\"\n        }\n      ]\n    }\n  ]\n};\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/* INCLUDES */\nconst LocalReader = require(\"./LocalReader/LocalReader\");\n\n/* PRIVATE VARS */\nconst _version = \"1.2.0\";\nconst _settings = {\n  t3dtoolsWorker: \"modules/t3dtools/t3dworker.js\",\n  concurrentTasks:\n    typeof navigator !== \"undefined\" ? navigator.hardwareConcurrency : 1\n};\n\nlet T3D;\n\n/* PUBLIC PROPERTIES */\n\n/**\n * Tyria 3D Library main module.\n *\n * Use this static class to access file parsers- and data renderer classes.\n *\n * This class also works as a factory for creating\n * LocalReader instances that looks up and inflates files from the Guild Wars 2 .dat.\n * @module T3D\n */\nT3D = module.exports = {\n  /**\n   * The current library version. Used to make sure local storage caches are not\n   * shared between different releases.\n   *\n   * @property version\n   * @type String\n   */\n  version: _version,\n\n  /* FILES */\n\n  /**\n   * A static reference to the GW2File class, the preferred way of\n   * accessing this class.\n   *\n   * @memberof T3D\n   * @property GW2File\n   * @type Class\n   */\n  GW2File: require(\"./format/file/GW2File\"),\n\n  /**\n   * A static reference to the GW2Chunk class, the preferred way of\n   * accessing this class.\n   *\n   * @memberOf T3D\n   * @property GW2Chunk\n   * @type Class\n   */\n  GW2Chunk: require(\"./format/file/GW2Chunk\"),\n\n  /* RENDERERS */\n\n  /**\n   * A static reference to the DataRenderer class, the preferred way of\n   * accessing this class.\n   *\n   * @readonly\n   * @property DataRenderer\n   * @type Class\n   */\n  DataRenderer: require(\"./dataRenderer/DataRenderer\"),\n\n  /**\n   * A static reference to the EnvironmentRenderer class, the preferred way of\n   * accessing this class.\n   *\n   * @readonly\n   * @property EnvironmentRenderer\n   * @type Class\n   */\n  EnvironmentRenderer: require(\"./dataRenderer/EnvironmentRenderer\"),\n\n  /**\n   * A static reference to the HavokRenderer class, the preferred way of\n   * accessing this class.\n   *\n   * @readonly\n   * @property HavokRenderer\n   * @type Class\n   */\n  HavokRenderer: require(\"./dataRenderer/HavokRenderer\"),\n\n  /**\n   * A static reference to the PropertiesRenderer class, the preferred way of\n   * accessing this class.\n   *\n   * @readonly\n   * @property PropertiesRenderer\n   * @type Class\n   */\n  PropertiesRenderer: require(\"./dataRenderer/PropertiesRenderer\"),\n\n  /**\n   * A static reference to the SingleModelRenderer class, the preferred way of\n   * accessing this class.\n   *\n   * @readonly\n   * @property SingleModelRenderer\n   * @type Class\n   */\n  SingleModelRenderer: require(\"./dataRenderer/SingleModelRenderer\"),\n\n  /**\n   * A static reference to the TerrainRenderer class, the preferred way of\n   * accessing this class.\n   *\n   * @readonly\n   * @property TerrainRenderer\n   * @type Class\n   */\n  TerrainRenderer: require(\"./dataRenderer/TerrainRenderer\"),\n\n  /**\n   * A static reference to the ZoneRenderer class, the preferred way of\n   * accessing this class.\n   *\n   * @readonly\n   * @property ZoneRenderer\n   * @type Class\n   */\n  ZoneRenderer: require(\"./dataRenderer/ZoneRenderer\"),\n\n  /**\n   * A static reference to the StringRenderer class, the preferred way of\n   * accessing this class.\n   *\n   * @readonly\n   * @property StringRenderer\n   * @type Class\n   */\n  StringRenderer: require(\"./dataRenderer/StringRenderer\"),\n\n  /* LOGGING */\n\n  /**\n   * A static reference to the static Logger object, the preferred way of\n   * accessing this object. A simple way of providing your own logging methods\n   * is to simply overwrite any or all of the logging methods specified in\n   * {{#crossLink \"Logger/logFunctions:property\"}}{{/crossLink}}\n   *\n   * @property Logger\n   * @type Object\n   */\n  Logger: require(\"./Logger\"),\n\n  /* SETTINGS */\n\n  /**\n   * Contains a list of known map fileID:s and their names. Used in order to quickly\n   * look up what maps are in a .dat file. Note that this property is hard coded and\n   * has high probablity of being outdated. Also note that the names are just guesses\n   * by RequestTimeout.\n   *\n   * The format of this list objects is\n   *\n   *\n   * \t{\n   *  \tmaps : [\n   *\t  \t\t{\n   *     \t\t\tname:\"World Area Name\",\n   *\t       \t\tmaps:[\n   *\t         \t\t{ fileName :\"[numeric fileId].data\", name:\"Map Name One\" },\n   *\t           \t\t{ fileName :\"[numeric fileId].data\", name:\"Map Name Two\" },\n   *\t             \t{ fileName :\"[numeric fileId].data\", name:\"Map Name Three\" }\n   *\t              ]\n   *           },\n   *\t         {\n   *\t\t\t    name:\"Another World Area Name\",\n   *\t\t \t   \tmaps:[\n   *\t\t \t\t   \t{ fileName :\"[numeric fileId].data\", name:\"Map Name 408\" }\n   *\t\t\t    ]\n   *\t\t     }\n   * \t\t]\n   *   }\n   *\n   * @readonly\n   * @property MapFileList\n   * @type Object\n   */\n  MapFileList: require(\"./MapFileList\"),\n\n  /* UTILS */\n\n  /**\n   * A static reference to the MaterialUtils class.\n   *\n   * @readonly\n   * @property MaterialUtils\n   * @type Object\n   */\n  //MaterialUtils: require(\"./util/MaterialUtils.js\"),\n\n  /**\n   * A static reference to the MathUtils class.\n   *\n   * @readonly\n   * @property MathUtils\n   * @type Object\n   */\n  //MathUtils: require(\"./util/MathUtils.js\"),\n\n  /**\n   * A static reference to the ParserUtils class.\n   *\n   * @readonly\n   * @property ParserUtils\n   * @type Object\n   */\n  //ParserUtils: require(\"./util/ParserUtils.js\"),\n\n  /**\n   * A static reference to the RenderUtils class.\n   *\n   * @readonly\n   * @property RenderUtils\n   * @type Object\n   */\n  RenderUtils: require(\"./util/RenderUtils.js\"),\n\n  /**\n   * A static reference to the PersistantStore class.\n   *\n   * @readonly\n   * @property PersistantStore\n   * @type Class\n   */\n  //PersistantStore: require(\"./LocalReader/PersistantStore\"),\n\n  /**\n   * A static reference to the FileTypes tools and list.\n   *\n   * @readonly\n   * @property FileTypes\n   * @type Object\n   */\n  //FileTypes: require(\"./LocalReader/FileTypes\"),\n\n  /* PUBLIC METHODS */\n\n  /**\n   * Creates a new instance of LocalReader with an pNaCl inflater connected to it.\n   *\n   * @async\n   * @param  {File}   \tfile\t\tCore JS File instance, must refer to a GW2 .dat file\n   * @param  {Function}\tcallback\tCallback function, fired when the file index is fully\n   *                             \t\tconstructed. Takes no arguments.\n   *\n   * @param  {String} \tt3dtoolsWorker URL to the inflater file. If omitted\n   *                               \t_settings.t3dtoolsWorker will be used instead.\n   *\n   * @return {LocalReader}\t\t\tThe contructed LocalReader, note that this object\n   *                             \t\twill not be fully initialized until the callback\n   *                             \t\tis fired.\n   */\n  getLocalReader: function(file, callback, t3dtoolsWorker) {\n    let path = t3dtoolsWorker || _settings.t3dtoolsWorker;\n\n    // Create the instance and init the threads\n    const lrInstance = new LocalReader({\n      workerPath: path,\n      workersNb: _settings.concurrentTasks\n    });\n\n    /// Callback with the lrInstance\n    lrInstance.openArchive(file).then(() => {\n      callback(lrInstance);\n    });\n\n    return lrInstance;\n  },\n\n  /**\n   * Utility method for acceccing a list containing information about all files\n   * in the .dat connected to the provided LocalReader instance. This method first\n   * tries to read a local indexing list from the client's localstorage and\n   * fallbacks to generating the list by scanning the MFT indices of the .dat\n   * and peeking each file in order to find out what filetype it has.\n   *\n   * Note that peeking the files is the time consuming task, so if you don't want\n   * yout application to spend time indexing the .dat and have a priori knowledge\n   * about the required file Id's you should not use this method.\n   *\n   * @async\n   * @param  {LocalReader}\tlocalReader A fully initialized LocalReader instance\n   * @param  {Function}\t\tcallback    Fires when the index has been loaded\n   *                                 \t\tfrom the localstorage or after it has\n   *                                 \t\tbeen built and stored in localstorage.\n   *                                 \t\tTakes the generated object list of\n   *                                 \t\tfiles as an argument. This list groups\n   *                                 \t\tarrays of MFT indices per file type,\n   *                                 \t\tfor exmample:\n   *\n   *\n   * \t{\n   *\t  \t\"Unknown\"\t: [444, 555, 333],\n   *\t  \t\"MODL\"\t\t: [444, 555, 333],\n   * \t  \t\"String\"\t: [666, 777, 888]\n   * \t}\n   *\n   * For more details see\n   * {{#crossLink \"LocalReader/listFiles:method\"}}{{/crossLink}}\n   */\n  getFileListAsync: function(localReader, callback) {\n    // Because the localreader API changed we reform the data as wanted\n    localReader.readFileList().then(result => {\n      let returnObj = {};\n      for (let fileEntry of result) {\n        if (returnObj[fileEntry.fileType] === undefined)\n          returnObj[fileEntry.fileType] = [];\n        returnObj[fileEntry.fileType].push(fileEntry.mftId);\n      }\n      callback(returnObj);\n    });\n  },\n\n  /**\n\t * Utility method for acceccing a list containing information about all map files\n\t * in the .dat connected to the provided LocalReader instance. This method first\n\t * tries to read a local indexing list from the client's localstorage and\n\t * fallbacks to generating the list by scanning the MFT indices of the .dat\n\t * and peeking each file in order to find out what filetype it has.\n\t *\n\t * If the searchAll flag is not set to true, this process will only scan files\n\t * from the {{#crossLink \"T3D/MapFileList:property\"}}{{/crossLink}}\n\t * \n\t * @async\n\t * @param {LocalReader}\tlocalReader\tA fully initialized LocalReader instance\n\t * @param {Function}\tcallback\tFires when the index has been loaded\n\t *                                 \tfrom the localstorage or after it has\n\t *                                 \tbeen built and stored in localstorage.\n\t *                                 \tTakes the generated object list of\n\t *                                 \tfiles as an argument. This list groups\n\t *                                 \tarrays of MFT indices per file type,\n\t *                                 \tfor exmample:\n\t * \n\t * \t\t{\t\n\t * \t\t\tmaps:[\n\t * \t\t\t\t{\n\t * \t\t\t\t\tname: 'Heart of Maguuma',\n\t * \t\t\t\t\tmaps: [\n\t * \t\t\t\t\t\t{fileName:1151420, name:'HoT BWE3 Raid'},\n\t * \t\t\t\t\t\t{fileName:969663, name:'Verdant Brink}\n\t * \t\t\t\t\t]\n\t * \t\t\t\t},\n\t * \t\t\t\t{\n\t * \t\t\t\t\tname: 'Unknown maps',\n\t * \t\t\t\t\tmaps: [\n\t * \t\t\t\t\t\t{fileName:12345678, name:'Unknown map 12345678'}\n\t * \t\t\t\t\t]\n\t * \t\t\t\t}\n\t * \t\t\t]\n\t \n\t*\t    };\n\t* @param {boolean} searchAll if true forces re-indexing of entire dat.\n\t*/\n  getMapListAsync: function(localReader, callback, searchAll) {\n    // Define a function that transforms the localreader output to what we want\n    function restoreOuput(array) {\n      let returnArray = [];\n      for (let elt of array) {\n        let category = returnArray.findIndex(i => i.name === elt.category);\n        if (category === -1)\n          category =\n            returnArray.push({\n              name: elt.category,\n              maps: []\n            }) - 1;\n        returnArray[category].maps.push({\n          fileName: elt.baseId,\n          name: elt.name\n        });\n      }\n      // And resort it in order\n      returnArray.sort((i, j) => {\n        if (i.name < j.name) return -1;\n        if (i.name > j.name) return 1;\n        return 0;\n      });\n      return {\n        maps: returnArray\n      };\n    }\n\n    /// If seachAll flag is true, force a deep search\n    if (searchAll) {\n      localReader.readFileList().then(() => {\n        callback(restoreOuput(localReader.getMapList()));\n      });\n    }\n    /// If not, it's only looking through known maps\n    else {\n      callback(restoreOuput(localReader.getMapList()));\n    }\n  },\n\n  /**\n   * Utility method used for rendering map files. Loads a map file and applies\n   * the provided renderers to it.\n   *\n   * @async\n   * @param  {LocalReader}\tlocalReader A fully initialized LocalReader instance\n   * @param  {Number}   \t\tfileName\tThe File Id of a mapc file.\n   * @param  {Array}   \t\trenderers\tAn array of renderer classes. Each\n   *                               \t\tclass should extend\n   *                               \t\t{{#crossLink \"DataRenderer\"}}{{/crossLink}}\n   * @param  {Function}\t\tcallback    Callback function, takes the shared\n   *                                 \t\trenderer context as an argument.\n   * @param  {Class}\t\t\tlogger      A logger class of the same type as\n   *                               \t\t{{#crossLink \"Logger\"}}{{/crossLink}}\n   */\n  renderMapContentsAsync: function(\n    localReader,\n    fileName,\n    renderers,\n    callback,\n    logger\n  ) {\n    /// VO for storing result from renderers\n    let context = {};\n\n    /// Make sure we got an actuall ID number\n    if (parseInt(fileName)) {\n      /// File name is baseId, load using local reader.\n      localReader\n        .readFile(parseInt(fileName), false, false, undefined, undefined, true)\n        .then(result => {\n          let arrayBuffer = result.buffer;\n\n          /// Set up datastream\n          let ds = new DataStream(arrayBuffer, 0, DataStream.LITTLE_ENDIAN);\n\n          /// Initiate Map file object. Connect callback\n          let mapFile = new T3D.GW2File(ds, 0);\n\n          /// Populate VO by running the renderers\n          const runAllRenderers = function(i) {\n            /// Run each renderer\n            if (i < renderers.length) {\n              T3D.runRenderer(\n                renderers[i].renderClass,\n                localReader,\n                Object.assign(renderers[i].settings, {\n                  mapFile: mapFile\n                }),\n                context,\n                runAllRenderers.bind(this, i + 1)\n              );\n            }\n\n            /// Fire callback with VO when done\n            else {\n              callback(context);\n            }\n          };\n\n          /// Starting point for running each renderer\n          runAllRenderers(0);\n        });\n    }\n\n    /// Primitive error message...\n    else {\n      let outputLogger = logger || T3D.Logger;\n      outputLogger.log(\n        T3D.Logger.TYPE_ERROR,\n        \"Map id must be an integer!, was:\",\n        fileName\n      );\n    }\n  },\n\n  /**\n   * Utility method for applying a single renderer to a LocalReader insatnce.\n   *\n   * @async\n   *\n   * @param  {Class}\t\trenderClass\tA class extending\n   *                                \t{{#crossLink \"DataRenderer\"}}{{/crossLink}}\n   * @param  {LocalReader}localReader A fully initialized LocalReader instance\n   * @param  {Object}\t\tsettings    Settings passed to the renderer. Often\n   *                               \tspecifies thinks like what file ID should\n   *                               \tbe loaded.\n   * @param  {Object}\t\tcontext     The shared renderer context value object.\n   * @param  {Function} \tcb          Callback method passed to the renderAsync\n   *                                 \tmethod of the renderer.\n   */\n  runRenderer: function(RenderClass, localReader, settings, context, cb) {\n    let r = new RenderClass(localReader, settings, context);\n\n    r.renderAsync(cb);\n  },\n\n  /**\n   * @param  {Object} context      \tA shared renderer context value object.\n   * @param  {Class} \tclazz        \tA class extending\n   *                                \t{{#crossLink \"DataRenderer\"}}{{/crossLink}}.\n   *                                \tSpecifies for renderer class you want to read\n   *                                \toutput.\n   * @param  {String} propName     \tThe name of the property written by the\n   *                                \trenderer that should retrtieved.\n   * @param  {any} \tdefaultValue \tThis value is passed back if no data could\n   *                              \tbe found.\n   * @return {any}    \t\t\t\tThe specified value from the conext if any,\n   *                          \t\totherwise defaultValue.\n   */\n  getContextValue: function(context, clazz, propName, defaultValue) {\n    let output = context[clazz.name];\n    if (output) {\n      return output[propName] ? output[propName] : defaultValue;\n    }\n    return defaultValue;\n  },\n\n  /**\n   * Check if the client web browser can render WebGL 3D content.\n   *\n   * @private\n   * @param  {boolean} returnContext flag making this method return the canvas object instead of true\n   * @return {boolean} true if the client is WebGL enabled, false otherwise\n   */\n  hasWebGL: function(returnContext) {\n    if (window.WebGLRenderingContext) {\n      let canvas = document.createElement(\"canvas\");\n\n      let names = [\"webgl\", \"experimental-webgl\", \"moz-webgl\", \"webkit-3d\"];\n\n      let context = false;\n\n      for (let i = 0; i < 4; i++) {\n        try {\n          context = canvas.getContext(names[i]);\n          if (context && typeof context.getParameter === \"function\") {\n            // WebGL is enabled\n            if (returnContext) {\n              // return WebGL object if the function's argument is present\n              return {\n                name: names[i],\n                gl: context\n              };\n            }\n            // else, return just true\n            return true;\n          }\n        } catch (e) {}\n      }\n\n      // WebGL is supported, but disabled\n      return false;\n    }\n\n    // WebGL not supported\n    return false;\n  }\n};\n\n/* PRIVATE METHODS */\n\n/**\n * Performs checks for required browser capabilities and required third party libraries.\n * Loggs any warnings or error messages.\n *\n * @private\n * @return {Number} The ammount of errors and warnings generated.\n */\nfunction checkRequirements() {\n  let numErrors = 0;\n\n  if (!global.window || !window.indexedDB) {\n    T3D.Logger.log(\n      T3D.Logger.TYPE_ERROR,\n      \"T3D persistant storing and loading requires indexedDB support.\"\n    );\n    numErrors++;\n  }\n\n  if (typeof DataStream === \"undefined\") {\n    T3D.Logger.log(\n      T3D.Logger.TYPE_ERROR,\n      \"T3D core functionality requires DataStream library.\"\n    );\n    numErrors++;\n  }\n\n  if (typeof THREE === \"undefined\") {\n    T3D.Logger.log(\n      T3D.Logger.TYPE_WARNING,\n      \"T3D mesh generation requires three.js library.\"\n    );\n    numErrors++;\n  }\n\n  if (numErrors < 1) {\n    T3D.Logger.log(\n      T3D.Logger.TYPE_MESSAGE,\n      \"Tyria 3D API v\" + T3D.version + \" initialized.\"\n    );\n  }\n\n  return numErrors;\n}\n\n/// Library checks requirements on startup\ncheckRequirements();\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst GW2File = require(\"../format/file/GW2File\");\nconst FileTypes = require(\"../LocalReader/FileTypes\");\n\n/**\n * Base class for data interpretors a.k.a. 'Renderers'\n *\n * Renderers are classes that collect and interpret data from the dat file.\n *\n * A {{#crossLink \"LocalReader\"}}{{/crossLink}} instance is used for accessing data from the dat.\n *\n * A {{#crossLink \"Logger\"}}{{/crossLink}} is used for posting progress output or error messages.\n *\n * Most Renderers use one or more\n * {{#crossLink \"GW2Chunk\"}}GW2Chunks{{/crossLink}}, typed data structures that can be read from\n * {{#crossLink \"GW2File\"}}GW2Files{{/crossLink}}.\n *\n * The generated data, be it strings, numbers or meshes are put into a value object structure called\n * the 'context'. The context can store data generated by multiple renderers and makes sure each\n * renderer type, or class has it's own value object within the context. This enables one renderer\n * to read data written by another renderer wihtout having to worry about overwriting existing data\n * within the context. Keep in mind that you will have to manually pass and clean the conext object!\n *\n * A clean context object should just be the empty javasript object : {}.\n *\n * When a Renderer is done it will fire the callback and any view interrested in retrieving the generated\n * data from the context can read it using\n * {{#crossLink \"T3D/getContextValue:method\"}}{{/crossLink}}.\n *\n *\n *\n *\n * @class DataRenderer\n * @constructor\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nclass DataRenderer {\n  constructor(localReader, settings, context, logger) {\n    /// Just storing parameters\n    this.localReader = localReader;\n    this.settings = settings;\n    if (!settings) {\n      settings = {};\n    }\n    this.context = context;\n    this.context[this.constructor.name] = {};\n\n    if (logger) this.logger = logger;\n    else this.logger = T3D.Logger;\n  }\n\n  /**\n   * Gets the output value object for a specified class within the context.\n   *\n   * @param  {Class} otherClass The class to fetch the output value object for.\n   * If not specified the class of this instance will be used.\n   * @return {Object}            The output value object for this class within the context.\n   */\n  getOutput(otherClass) {\n    return this.context[otherClass ? otherClass.name : this.constructor.name];\n  }\n\n  /**\n   * Basic rendering of unknown files. Output fileds generated:\n   *\n   * - *fileId* The fileId passed in the settings parameter when constructing this instance.\n   *\n   * - *rawData* An ArrayBuffer containg the infalted binary data of the loaded file.\n   *\n   * - *rawString* A string representation of the rawData\n   *\n   * - *image* A value object witht he fields 'width', 'height' and 'data' describing a RGBA bitmap\n   * image. Only set if the loaded file was a texture.\n   *\n   * - *file* A GW2File representation of the loaded file. Only set if the loaded file was a Pack File.\n   *\n   * @async\n   * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n   */\n  renderAsync(callback) {\n    this.localReader\n      .readFile(this.settings.id, false, false, undefined, undefined, true)\n      .then(result => {\n        let inflatedData = result.buffer;\n\n        /// Set fileId so callers can identify this VO\n        this.getOutput().fileId = this.settings.id;\n\n        /// Share inflated data\n        this.getOutput().rawData = inflatedData;\n\n        /// Construct raw string\n        let uarr = new Uint8Array(inflatedData);\n        let textDecoder = new TextDecoder(\"latin2\");\n        this.getOutput().rawString = textDecoder.decode(uarr);\n\n        /// Check if this is an PF or ATEX file\n        // Binareis are MZ\n        let ds = new DataStream(inflatedData);\n        let first4 = ds.readCString(4);\n\n        /// Do special stuff for different fcc signatures\n        if (FileTypes.getAnetTextureType(first4)) {\n          this.localReader\n            .readFile(this.settings.id, true, false, undefined, undefined, true)\n            .then(result => {\n              /// Create image using returned data.\n              let image = {\n                data: new Uint8Array(result.buffer),\n                width: result.imageWidth,\n                height: result.imageHeight\n              };\n\n              this.getOutput().image = image;\n              callback();\n            });\n        } else if (first4.indexOf(\"PF\") === 0) {\n          this.getOutput().file = new GW2File(ds, 0);\n          callback();\n        } else {\n          this.getOutput().file = null;\n          callback();\n        }\n      });\n  }\n}\n\nmodule.exports = DataRenderer;\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst MapEnvUtils = require(\"../util/MapEnvUtils\");\nconst DataRenderer = require(\"./DataRenderer\");\n\n/**\n *\n * A renderer that generates some of the environment objects of a map.\n *\n * @class EnvironmentRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"mapFile\", a GW2File.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nclass EnvironmentRenderer extends DataRenderer {\n  constructor(localReader, settings, context, logger) {\n    super(localReader, settings, context, logger);\n\n    this.mapFile = this.settings.mapFile;\n  }\n\n  /**\n   * Output fileds generated:\n   *\n   * - *hazeColor* Array of RGBA values describing the global haze color of the map.\n   * - *lights* An array of THREE.DirectionalLight and  THREE.AmbientLight objects.\n   * - *hasLight* Boolean is false if no directional lights were added to \"lights\".\n   * - *skyElements* A textured THREE.Mesh skybox.\n   *\n   * @async\n   * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n   */\n  renderAsync(callback) {\n    let environmentChunkData = this.mapFile.getChunk(\"env\").data;\n    let parameterChunkData = this.mapFile.getChunk(\"parm\").data;\n\n    /// Set renderer clear color from environment haze\n    let hazeColor = MapEnvUtils.getHazeColor(environmentChunkData);\n    let hazeColorAsInt =\n      hazeColor[2] * 256 * 256 + hazeColor[1] * 256 + hazeColor[0];\n    this.getOutput().hazeColor = hazeColor;\n\n    /// Add directional lights to output. Also write hasLight flag\n    let lightData = MapEnvUtils.parseLights(environmentChunkData);\n    this.getOutput().hasLight = lightData.hasLight;\n    this.getOutput().lights = lightData.lights;\n\n    /// Generate skybox\n    this.getOutput().skyElements = MapEnvUtils.parseSkybox(\n      environmentChunkData,\n      parameterChunkData,\n      hazeColorAsInt,\n      // TODO: Move outside of library\n      [\"img/193068.png\", \"img/193070.png\", \"img/193072.png\"],\n      this.localReader\n    ).skyElements;\n\n    /// All parsing is synchronous, just fire callback\n    callback();\n  }\n}\n\nmodule.exports = EnvironmentRenderer;\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst DataRenderer = require(\"./DataRenderer\");\nconst MapHavokUtils = require(\"../util/MapHavokUtils\");\n\n/**\n *\n * A renderer that generates meshes describing the collisions of a map.\n *\n * @class HavokRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"mapFile\", a GW2File. If \"visible\" is specified and true, the generated meshes will be textured\n * with a MeshNormalMaterial, otherwise they will not be visible.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\n\nclass HavokRenderer extends DataRenderer {\n  constructor(localReader, settings, context, logger) {\n    super(localReader, settings, context, logger);\n\n    this.mapFile = this.settings.mapFile;\n\n    this.lastP = -1;\n    this.seed = 1;\n    this.meshes = [];\n  }\n\n  /**\n   * Output fileds generated:\n   *\n   * - *boundingBox* Array of values describing the bounding box of all collision.\n   * - *meshes* An array of THREE.Mesh objects visualizing all collision in the map.\n   *\n   * @async\n   * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n   */\n  renderAsync(callback) {\n    // TODO:The design of this method pretty much requires one instance\n    // of the class per parallel async render. Should probably fix this\n    // at some point...\n\n    /// Get required chunks\n    this.havokChunkData = this.mapFile.getChunk(\"havk\").data;\n\n    /// Set static bounds to the bounds of the havk models\n    this.getOutput().boundingBox = this.havokChunkData.boundsMax;\n\n    this.meshes = [];\n\n    /// Grab model raw data from the chunk.\n    /// Add missing scale value to obs models.\n    let propModels = this.havokChunkData.propModels;\n    let zoneModels = this.havokChunkData.zoneModels;\n    let obsModels = this.havokChunkData.obsModels;\n    for (const mdl of obsModels) {\n      mdl.scale = 1;\n    }\n\n    /// Store geoms and animations from the file in the instance so we don't\n    /// have to pass them around too much. (fix this later)\n    this.geometries = this.havokChunkData.geometries;\n    this.animations = this.havokChunkData.animations;\n\n    /// Render \"prop\", \"zone\" and \"obs\" models in that order.\n    let renderPropModelsCB = () => {\n      this.renderModels(zoneModels, \"zone\", renderZoneModelsCB);\n    };\n    const renderZoneModelsCB = () => {\n      this.renderModels(obsModels, \"obs\", callback);\n    };\n    this.renderModels(propModels, \"prop\", renderPropModelsCB);\n  }\n\n  renderModels(models, title, callback) {\n    MapHavokUtils.renderModels(\n      {\n        settings: this.settings,\n        lastP: this.lastP,\n        geometries: this.geometries,\n        animations: this.animations,\n        havokChunkData: this.havokChunkData,\n        meshes: this.meshes,\n        output: { meshes: [] }\n      },\n      models,\n      title,\n      output => {\n        // Add to current output before calling the callback\n        let currentOutput = this.getOutput().meshes;\n        this.getOutput().meshes = currentOutput\n          ? currentOutput.concat(output.meshes)\n          : output.meshes;\n        callback();\n      }\n    );\n  }\n}\n\nmodule.exports = HavokRenderer;\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst DataRenderer = require(\"./DataRenderer\");\nconst MapPropsUtils = require(\"../util/MapPropsUtils\");\n\n/**\n *\n * A renderer that generates property models for a map.\n *\n * @class PropertiesRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"mapFile\", a GW2File.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\n\nclass PropertiesRenderer extends DataRenderer {\n  constructor(localReader, settings, context, logger) {\n    super(localReader, settings, context, logger);\n\n    this.mapFile = this.settings.mapFile;\n  }\n\n  /**\n   * Renders all property meshes in a GW2 map described by the map's PROP chunk.\n   * Output fileds generated:\n   *\n   * - *meshes* An array of THREE.Mesh objects visualizing all property models refered by this map.\n   *\n   * @async\n   * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n   */\n  renderAsync(callback) {\n    let propertiesChunkData = this.mapFile.getChunk(\"prp2\").data;\n\n    if (!propertiesChunkData) {\n      callback();\n      return;\n    }\n\n    let props = propertiesChunkData.propArray;\n    let animProps = propertiesChunkData.propAnimArray;\n    let instanceProps = propertiesChunkData.propInstanceArray;\n    let metaProps = propertiesChunkData.propMetaArray;\n\n    /// Concat all prop types\n    props = props\n      .concat(animProps)\n      .concat(instanceProps)\n      .concat(metaProps);\n\n    /// Start serial loading and redering. (to allow re-using meshes and textures)\n    MapPropsUtils.renderIndex(this.localReader, props, 0, output => {\n      this.getOutput().meshes = output.meshes;\n      callback();\n    });\n  }\n\n  /**\n   * TODO: write description. Used for export feature\n   * @param  {Function} callback [description]\n   * @return {*}            [description]\n   */\n  getFileIdsAsync(callback) {\n    const propertiesChunkData = this.mapFile.getChunk(\"prp2\").data;\n\n    let props = propertiesChunkData.propArray;\n    const animProps = propertiesChunkData.propAnimArray;\n    const instanceProps = propertiesChunkData.propInstanceArray;\n    const metaProps = propertiesChunkData.propMetaArray;\n\n    props = props\n      .concat(animProps)\n      .concat(instanceProps)\n      .concat(metaProps);\n\n    MapPropsUtils.getIdsForProp(props, 0, callback);\n  }\n}\n\nmodule.exports = PropertiesRenderer;\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst ModelUtils = require(\"../util/ModelUtils\");\nconst DataRenderer = require(\"./DataRenderer\");\n\n/**\n *\n * A renderer that generates meshes for a single model file.\n *\n * @class SingleModelRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"id\" the base ID or file ID of the model to generate meshes for.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nclass SingleModelRenderer extends DataRenderer {\n  constructor(localReader, settings, context, logger) {\n    super(localReader, settings, context, logger);\n  }\n\n  /**\n   * Output fileds generated:\n   *\n   * - *meshes* An array of THREE.Mesh objects visualizing this model file.\n   *\n   * @async\n   * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n   */\n  renderAsync(callback) {\n    let self = this;\n\n    /// Get file id\n    let fileId = this.settings.id;\n    let showUnmaterialed = true;\n\n    /// Load the model file\n    let meshCache = {};\n    let textureCache = {};\n\n    /// Set up output array\n    self.getOutput().meshes = [];\n\n    ModelUtils.getMeshesForFilename(\n      fileId,\n      0x00ff00,\n      self.localReader,\n      meshCache,\n      textureCache,\n      showUnmaterialed,\n      true,\n      function(meshes, isCached, boundingSphere) {\n        if (meshes) {\n          meshes.forEach(function(mesh) {\n            mesh.boundingSphere = boundingSphere;\n            self.getOutput().meshes.push(mesh);\n          });\n        }\n\n        /// Fire callback after all meshes have been added.\n        meshCache = {};\n        callback();\n      }\n    );\n  }\n}\n\nmodule.exports = SingleModelRenderer;\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst DataRenderer = require(\"./DataRenderer\");\n\n/**\n *\n * A renderer that generates a list of readable strings from a \"strs\" file.\n *\n * @class StringRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"id\" the base ID or file ID of the string file to read strings from.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nclass StringRenderer extends DataRenderer {\n  constructor(localReader, settings, context, logger) {\n    super(localReader, settings, context, logger);\n  }\n\n  /**\n   * Output fileds generated:\n   *\n   * - *strings* An array of objects. Each object has a \"recid\"-property specifing on what index within the file\n   * a given string was found, and a \"value\"-property specigying the string value.\n   *\n   * - *language* An integer specifing the language of the loaded file.\n   *\n   * @async\n   * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n   */\n  renderAsync(callback) {\n    let self = this;\n\n    /// Get file id\n    let fileId = this.settings.id;\n    let showUnmaterialed = true;\n\n    /// Load the string file\n\n    /// Set up output array\n    this.getOutput().strings = [];\n\n    this.localReader\n      .readFile(this.settings.id, false, false, undefined, undefined, true)\n      .then(result => {\n        let inflatedData = result.buffer;\n        let ds = new DataStream(inflatedData);\n        let end = ds.byteLength - 2;\n\n        /// skip past fcc\n        ds.seek(4);\n\n        let entryHeaderDef = [\n          \"size\",\n          \"uint16\",\n          \"decryptionOffset\",\n          \"uint16\",\n          \"bitsPerSymbol\",\n          \"uint16\"\n        ];\n\n        let entryIndex = 0;\n\n        while (end - ds.position > 6) {\n          let entry = ds.readStruct(entryHeaderDef);\n          entry.size -= 6;\n\n          if (entry.size > 0) {\n            let isEncrypted =\n              entry.decryptionOffset !== 0 || entry.bitsPerSymbol !== 0x10;\n\n            /// UTF-16\n            if (!isEncrypted) {\n              let value = ds.readUCS2String(entry.size / 2);\n              self.getOutput().strings.push({\n                value: value,\n                recid: entryIndex\n              });\n            }\n\n            /// Other... ignored\n            else {\n            }\n          }\n\n          entryIndex++;\n        }\n\n        ds.seek(ds.byteLength - 2);\n        self.getOutput().language = ds.readUint16();\n        callback();\n      });\n  }\n}\n\nmodule.exports = StringRenderer;\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst DataRenderer = require(\"./DataRenderer\");\n\nconst MapTerrainUtils = require(\"../util/MapTerrainUtils\");\n\n/**\n *\n * A renderer that generates the meshes for the terrain of a map.\n *\n *\n * Requires a context previously populated by a\n * {{#crossLink \"EnvironmentRenderer\"}}{{/crossLink}}.\n *\n * @class TerrainRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"mapFile\", a GW2File.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nclass TerrainRenderer extends DataRenderer {\n  constructor(localReader, settings, context, logger) {\n    super(localReader, settings, context, logger);\n\n    this.mapFile = this.settings.mapFile;\n  }\n\n  /**\n   * Output fileds generated:\n   *\n   * - *terrainTiles* An array of THREE.Mesh objects visualizing terrain of the map.\n   *\n   * - *water* A THREE.Mesh object visualizing the bounds of the map.\n   *\n   * - *bounds* An object wiht x1, x2, y1, and y2 properties specifying the bounds of the map.\n   *\n   * @async\n   * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n   */\n  renderAsync(callback) {\n    /// Load all paged Images, requires inflation of other pack files!\n    const pagedImageId = this.mapFile.getChunk(\"trn\").data.materials.pagedImage;\n    this.localReader\n      .readFile(pagedImageId, false, false, undefined, undefined, true)\n      .then(result => {\n        return MapTerrainUtils.loadPagedImageCallback(\n          result.buffer,\n          this.mapFile,\n          this.settings.anisotropy,\n          this.getOutput(T3D.EnvironmentRenderer),\n          this.localReader\n        );\n      })\n      .then(terrainResult => {\n        // Populate the output\n        this.getOutput().terrainTiles = terrainResult.terrainTiles;\n        this.getOutput().water = terrainResult.water;\n        this.getOutput().bounds = terrainResult.mapRect;\n\n        callback();\n      });\n  }\n\n  /**\n   * TODO: write description. Used for export feature\n   *\n   * @param  {Function} callback [description]\n   * @return {*}            [description]\n   */\n  getFileIdsAsync(callback) {\n    callback(MapTerrainUtils.getTerrainFilesId(this.mapFile));\n  }\n}\n\nmodule.exports = TerrainRenderer;\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst DataRenderer = require(\"./DataRenderer\");\nconst MapZoneUtils = require(\"../util/MapZoneUtils\");\n\n/**\n *\n * A renderer that generates zone models for a map.\n *\n * @class ZoneRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"mapFile\", a GW2File.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nclass ZoneRenderer extends DataRenderer {\n  constructor(localReader, settings, context, logger) {\n    super(localReader, settings, context, logger);\n\n    this.mapFile = this.settings.mapFile;\n  }\n\n  /**\n   * Renders all zone meshes in a GW2 map described by the map's \"zon2\" chunk.\n   * Output fileds generated:\n   *\n   * - *meshes* An array of THREE.Mesh objects visualizing all zone models refered by this map.\n   *\n   * @async\n   * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n   */\n  renderAsync(callback) {\n    /// Set up output array\n    this.getOutput().meshes = [];\n\n    let zoneChunkData = this.mapFile.getChunk(\"zon2\").data;\n    let parameterChunkData = this.mapFile.getChunk(\"parm\").data;\n    // let terrainChunkData = this.mapFile.getChunk(\"trn\").data;\n    let mapRect = parameterChunkData.rect;\n\n    /// Zone data\n    let zones = zoneChunkData.zoneArray;\n    let zoneDefs = zoneChunkData.zoneDefArray;\n\n    /// Render each zone\n    let lastPct = -1;\n\n    const dataForUtils = {\n      localReader: this.localReader,\n      terrainTiles: this.getOutput(T3D.TerrainRenderer).terrainTiles,\n      output: { meshes: [] }\n    };\n\n    /// Main render loop, render each zone\n    const stepZone = i => {\n      let pct = Math.round((100.0 * i) / zones.length);\n      if (lastPct !== pct) {\n        T3D.Logger.log(\n          T3D.Logger.TYPE_PROGRESS,\n          \"Loading 3D Models (Zone)\",\n          pct\n        );\n        lastPct = pct;\n      }\n\n      if (i >= zones.length) {\n        callback();\n        return;\n      }\n\n      /// Main zone render function call\n      MapZoneUtils.renderZone(dataForUtils, zones[i], zoneDefs, mapRect, () => {\n        this.getOutput().meshes = this.getOutput().meshes.concat(\n          dataForUtils.output.meshes\n        );\n        stepZone(i + 1);\n      });\n    };\n\n    stepZone(0);\n  }\n}\n\nmodule.exports = ZoneRenderer;\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst HEAD_STRUCT = [\n  \"type\",\n  \"cstring:4\",\n  \"chunkDataSize\",\n  \"uint32\",\n  \"chunkVersion\",\n  \"uint16\",\n  \"chunkHeaderSize\",\n  \"uint16\",\n  \"offsetTableOffset\",\n  \"uint32\"\n];\n\n/**\n * Settings for resolving conflicting chunk names in different files.\n * @private\n * @property DUPLICATE_SETTINGS\n * @type {Object}\n */\nlet DUPLICATE_SETTINGS;\n\n// Replacement for DUPLICATE_SETTINGS, based on the name of the root property.\nconst PACKTOCHUNK = [\n  {\n    pack: \"MODL\",\n    chunk: \"ANIM\",\n    root: \"ModelFileAnimation\"\n  },\n  {\n    pack: \"MODL\",\n    chunk: \"GAME\",\n    root: \"ModelFileGame\"\n  },\n  {\n    pack: \"MODL\",\n    chunk: \"SKEL\",\n    root: \"ModelFileSkeleton\"\n  },\n  {\n    pack: \"MODL\",\n    chunk: \"TOOL\",\n    root: \"ModelFileTool\"\n  },\n  {\n    pack: \"cntc\",\n    chunk: \"Main\",\n    root: \"PackContent\"\n  },\n  {\n    pack: \"mMet\",\n    chunk: \"Main\",\n    root: \"PackMapMetadata\"\n  },\n  {\n    pack: \"AMAT\",\n    chunk: \"TOOL\",\n    root: \"AmatToolParams\"\n  },\n  {\n    pack: \"cmaC\",\n    chunk: \"main\",\n    root: \"CollideModelManifest\"\n  }\n];\n\n// Builds the DUPLICATE_SETTINGS based on the provided T3D.formats.\n// Required to be done dynamically since the 32 bit and 64bits have different ordering\nfunction genDuplicateSettings() {\n  // Early return if the settings have been already generated\n  if (DUPLICATE_SETTINGS) return;\n\n  function getRootName(Definition) {\n    let a = new Definition();\n    return Object.keys(a).filter(v => {\n      return a[v] === a.__root && v !== \"__root\";\n    })[0];\n  }\n\n  DUPLICATE_SETTINGS = {};\n  for (let setting of PACKTOCHUNK) {\n    let regex = new RegExp(`^${setting.root}(V[0-9]*)?$`);\n    let chunkDef = T3D.formats.filter(v => {\n      return v.name === setting.chunk;\n    });\n\n    for (let defsIdx in chunkDef) {\n      let defs = chunkDef[defsIdx].versions;\n      let lastVersion = defs[Object.keys(defs).pop()];\n      let rootName = getRootName(lastVersion);\n      if (rootName.match(regex)) {\n        if (!DUPLICATE_SETTINGS[setting.chunk])\n          DUPLICATE_SETTINGS[setting.chunk] = [];\n        DUPLICATE_SETTINGS[setting.chunk][defsIdx] = setting.pack;\n        break;\n      }\n    }\n  }\n}\n\n/**\n * Basic chunk parsing functionality for Guild Wars 2 file chunks\n *\n * @constructor\n * @param {DataStream} ds A DataStream containing deflated chunk binary data.\n * @param {Number} addr Offset of chunk start within the DataStream\n */\nclass GW2Chunk {\n  constructor(ds, addr) {\n    // Early returns if already called, it defines the DUPLICATE_SETTINGS variable\n    genDuplicateSettings();\n\n    /**\n     * @property {DataStream} ds The DataStream data source used by this chunk.\n     */\n    this.ds = ds;\n\n    /**\n     * @property {Number} addr The address to this Chunk within ds.\n     */\n    this.addr = addr;\n\n    /**\n     * @property {Object} data The typed data read from the body of this chunk.\n     */\n    this.data = null;\n\n    /**\n     * @property {Number} headerLength The length in bytes of the chunk header.\n     */\n    this.headerLength = NaN;\n\n    /**\n     * @property {Object} header Chunk header data.\n     */\n    this.loadHead();\n  }\n\n  /**\n   * Parses the chunk header data, populating the header property.\n   */\n  loadHead() {\n    this.ds.seek(this.addr);\n    this.header = this.ds.readStruct(HEAD_STRUCT);\n\n    this.headerLength = this.ds.position - this.addr;\n  }\n\n  /**\n   * @param  {String} fileType The main type of the pack file containing this chunk.\n   * Used for resolving chunk naming conflicts between pack file types.\n   * @return {Array}\tDataStream formatted array describing the data\n   * sctructures of this chunk\n   */\n  getDefinition(fileType) {\n    /// Normally we're looking for the 0th occurance\n    /// But some chunk names occur multiple times and we're interrested\n    /// in the N:th occurance of the definition.\n\n    /// I've no idea how this is automated, for now just use the\n    /// settings object I've put together from experience.\n    let useNthIndex = 0;\n\n    /// If this chunk has multiple definitions\n    /// get to know what def to use...\n    let fileTypes = DUPLICATE_SETTINGS[this.header.type];\n    if (fileTypes) {\n      useNthIndex = -1;\n\n      /// Check what file name entry matches this file name\n      for (let i = 0; i < fileTypes.length && useNthIndex === -1; i++) {\n        let ft = fileTypes[i];\n\n        if (ft === fileType) {\n          useNthIndex = i;\n        }\n      }\n\n      /// We didnt find this file name!\n      /// TODO: if you get this error, please update the DUPLICATE_SETTINGS above\n      if (useNthIndex === -1) {\n      }\n    }\n\n    let defsFound = 0;\n    for (let i = 0; i < T3D.formats.length; i++) {\n      let f = T3D.formats[i];\n\n      /// Chunk name needs to match\n      if (f.name === this.header.type) {\n        /// There needs to be a chunk def version matching the one specifiend\n\n        /// AND If this is the Nth occurance of the chunk definition\n        /// and we're looking for the Nth occurance, return it.\n\n        /// chunkVersion in the dat uses 0 indexing\n        if (defsFound === useNthIndex && f.versions[this.header.chunkVersion]) {\n          return new f.versions[this.header.chunkVersion]().__root;\n        }\n\n        defsFound++;\n      }\n    }\n  }\n\n  /**\n   * Parses the chunk main data, populating the data property.\n   *\n   * @param  {String} fileType The main type of the pack file containing this chunk.\n   * Used for resolving chunk naming conflicts between pack file types when\n   * looking up the structure definition for this chunk.\n   */\n  loadData(fileType) {\n    let def = this.getDefinition(fileType);\n\n    if (def) {\n      this.ds.seek(this.addr + this.headerLength);\n      this.data = this.ds.readStruct(def);\n    } else {\n      T3D.Logger.log(\n        T3D.Logger.TYPE_WARNING,\n        \"Could not find a definition for chunk\",\n        this.header.type,\n        \"version\",\n        this.header.chunkVersion,\n        \"file name\",\n        fileType\n      );\n    }\n  }\n\n  /**\n   * Retrieves the next chunk is the datastream. In practice this means the next chunk\n   * within the same pack file.\n   *\n   * @return {GW2Chunk} The next chunk if any, otherwise null.\n   */\n  next() {\n    try {\n      // Calculate actual data size, as mChunkDataSize\n      // does not count the size of some header variables\n      return new GW2Chunk(this.ds, this.addr + 8 + this.header.chunkDataSize);\n    } catch (e) {\n      /// Out of bounds probably\n    }\n    return null;\n  }\n}\n\nmodule.exports = GW2Chunk;\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst Chunk = require(\"./GW2Chunk\");\n\nconst HEAD_STRUCT = [\n  \"identifier\",\n  \"cstring:2\",\n  \"unknownField1\",\n  \"uint16\",\n  \"unknownField2\",\n  \"uint16\",\n  \"pkFileVersion\",\n  \"uint16\",\n  \"type\",\n  \"cstring:4\"\n];\n\n/**\n * Basic header and chunk parsing functionality for Guild Wars 2 pack files (PF)\n *\n * @constructor\n * @param {DataStream} ds A DataStream containing deflated file binary data.\n * @param {Number} addr Offset of file start within the DataStream\n * @param {boolean} noChunks If true, the file does not parse its\n * chunks on creation.\n */\nclass GW2File {\n  constructor(ds, addr, noChunks) {\n    /**\n     * @property {DataStream} ds The DataStream data source used by this file.\n     */\n    this.ds = ds;\n\n    /**\n     * @property {Number} addr The address to this File within ds.\n     */\n    this.addr = addr;\n\n    /// Not used anymore I think\n    this.data = null;\n\n    /**\n     * @property {Number} headerLength The length in bytes of the file header.\n     */\n    this.headerLength = NaN;\n\n    /**\n     * All {{#crossLink \"GW2Chunk\"}}chunks{{/crossLink}} contained in the file.\n     *\n     * @property chunks\n     * @type GW2Chunk[]\n     */\n    this.chunks = [];\n\n    /**\n     * @property {Object} header Chunk header data.\n     */\n    this.readHead();\n\n    if (!noChunks) {\n      this.readChunks();\n    }\n  }\n\n  /**\n   * Parses the file header data, populating the header property.\n   */\n  readHead() {\n    this.ds.seek(this.addr);\n    this.header = this.ds.readStruct(HEAD_STRUCT);\n    this.headerLength = this.ds.position - this.addr;\n  }\n\n  /**\n   * Parses the file headers and populates the chunks property.\n   */\n  readChunks() {\n    /// Reset chunks\n    this.chunks = [];\n\n    // var structs = this.getChunkStructs && this.getChunkStructs();\n\n    /// Load basic Chunk in order to read the chunk header.\n    let ch = new Chunk(this.ds, this.headerLength + this.addr);\n\n    // while(structs && ch!=null && ch.header.type){\n    while (ch != null && ch.header.type) {\n      /// Load data and pass file type if we need to determine what chunk entry to use\n      /// (Some chunks in different files share the same chunk name)\n      ch.loadData(this.header.type);\n      this.chunks.push(ch);\n\n      /// Load next basic Chunk in order to read the chunk header.\n      ch = ch.next();\n    }\n  }\n\n  /**\n   * Get a GW2Chunk from this file\n   *\n   * @param  {String} type The name, or type of the desired chunk.\n   * @return {GW2Chunk} The first GW2Chunk in this file matching the type name, or null if no matching GW2Chunk was found.\n   */\n  getChunk(type) {\n    for (let i = 0; i < this.chunks.length; i++) {\n      if (this.chunks[i].header.type.toLowerCase() === type.toLowerCase())\n        return this.chunks[i];\n    }\n    return null;\n  }\n\n  /**\n   * Provides a list of known header types and their parsing structure. Should be defined by each file type individually.\n   *\n   * @return {Object} An object mapping chunk identifiers to DataStream structure descriptors.\n   */\n  getChunkStructs() {\n    return {};\n  }\n}\n\nmodule.exports = GW2File;\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * Object describing the meaning of the bits in fvf integers.\n * @private\n * @type {Object}\n */\nlet fvfFormat = {\n  Position: 0x00000001,\n  /** < 12 bytes. Position as three 32-bit floats in the order x, y, z. */\n  Weights: 0x00000002,\n  /** < 4 bytes. Contains bone weights. */\n  Group: 0x00000004,\n  /** < 4 bytes. Related to bone weights. */\n  Normal: 0x00000008,\n  /** < 12 bytes. Normal as three 32-bit floats in the order x, y, z. */\n  Color: 0x00000010,\n  /** < 4 bytes. Vertex color. */\n  Tangent: 0x00000020,\n  /** < 12 bytes. Tangent as three 32-bit floats in the order x, y, z. */\n  Bitangent: 0x00000040,\n  /** < 12 bytes. Bitangent as three 32-bit floats in the order x, y, z. */\n  TangentFrame: 0x00000080,\n  /** < 12 bytes. */\n  UV32Mask: 0x0000ff00,\n  /** < 8 bytes for each set bit. Contains UV-coords as two 32-bit floats in the order u, v. */\n  UV16Mask: 0x00ff0000,\n  /** < 4 bytes for each set bit. Contains UV-coords as two 16-bit floats in the order u, v. */\n  Unknown1: 0x01000000,\n  /** < 48 bytes. Unknown data. */\n  Unknown2: 0x02000000,\n  /** < 4 bytes. Unknown data. */\n  Unknown3: 0x04000000,\n  /** < 4 bytes. Unknown data. */\n  Unknown4: 0x08000000,\n  /** < 16 bytes. Unknown data. */\n  PositionCompressed: 0x10000000,\n  /** < 6 bytes. Position as three 16-bit floats in the order x, y, z. */\n  Unknown5: 0x20000000\n  /** < 12 bytes. Unknown data. **/\n};\n\n/// Known material flags, not used yet\nconst knownflags = [\n  0, // 0 0000 0000 0000\t\tGround / Wall splashes\n  8, // 0 0000 0000 1000\t\tBroken Khylo roof DDS\n  9, // 0 0000 0000 1001\t\tTree leaves\n\n  520, // 0 0010 0000 1000\t\tSome LOD modules, fires, smoke, inside of tents (some DSS textures)\n\n  2056, // 0 1000 0000 1000\t\tSolid objects, also broken animations\n\n  /// Solids here are unhappy, or are they? could be animations etc\n  2057, // 0 1000 0000 1001\t\tWindmill sails, bushes, trees, but also a statue and a few pieces of wall\n\n  2060, // 0 1000 0000 1100\t\tA few solid objects, like wooden barricades, one(!) painting\n  2061, // 0 1000 0000 1101\t\tA few bushes, two paintings\n\n  2312, // 0 1001 0000 1000\t\tOpaque Clock tower main walls AND IVY\n  2316, // 0 1001 0000 1100\t\tBushes, inner flower walkway a ramp and a box\n\n  // Number 10\n  2568, // 0 1010 0000 1000\t\tLots of solids; walls, tents also some tent details WITH alpa\n\n  // Number 11\n  2569, // 0 1010 0000 1001\t\tSolids like walls and roofs and appernt non solids like ropes\n\n  2572, // 0 1010 0000 1100\t\tSolid wooden beems, lamp posts\n  2573, // 0 1010 0000 1101\t\tLamp holders, bushes, fences, apparent non solids\n  2584, // 0 1010 0001 1000\t\tFountain Well water\n\n  2824, // 0 1011 0000 1000\t\tWindows, sign arrows, cloth roofs (non solids) BUT straw roofs\n  2828, // 0 1011 0000 1100\t\tA few fence post (non solids)\n  2840, // 0 1011 0001 1000\t\tFountain running water + pipe water\n\n  4617, // 1 0010 0000 1001\t\tFound nothing\n  6664 // 1 1010 0000 1000\t\tTwo groups of solid boxes\n];\n\nmodule.exports = {\n  fvfFormat: fvfFormat\n};\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst MaterialUtils = require(\"./MaterialUtils\");\n\nfunction getMat(tex) {\n  return new THREE.MeshBasicMaterial({\n    map: tex,\n    side: THREE.BackSide,\n    fog: false,\n    depthWrite: false\n  });\n}\n\nfunction loadTextureWithFallback(\n  targetMatIndices,\n  materialArray,\n  filename,\n  fallbackFilename,\n  hazeColorAsInt,\n  localReader\n) {\n  function writeMat(mat) {\n    for (let i of targetMatIndices) {\n      materialArray[i] = mat;\n    }\n  }\n\n  function loadFallback() {\n    let mat = getMat(new THREE.TextureLoader().load(fallbackFilename));\n\n    writeMat(mat);\n  }\n\n  function errorCallback() {\n    setTimeout(loadFallback, 1);\n  }\n\n  let mat = getMat(\n    MaterialUtils.loadLocalTexture(\n      localReader,\n      filename,\n      null,\n      hazeColorAsInt,\n      errorCallback\n    )\n  );\n\n  writeMat(mat);\n}\n\nfunction getHazeColor(environmentChunkData) {\n  let hazes = environmentChunkData && environmentChunkData.dataGlobal.haze;\n\n  if (!hazes || hazes.length <= 0) {\n    return [190, 160, 60];\n  } else {\n    return hazes[0].farColor;\n  }\n}\n\nfunction parseLights(environmentChunkData) {\n  let lightOutput = [];\n\n  let lights = environmentChunkData\n    ? environmentChunkData.dataGlobal.lighting\n    : [\n        {\n          lights: [],\n          backlightIntensity: 1.0,\n          backlightColor: [255, 255, 255]\n        }\n      ];\n\n  let ambientLight;\n\n  let hasLight = false;\n\n  // Iterate on each light\n  for (let idx in lights) {\n    let light = lights[idx];\n\n    if (hasLight) break;\n\n    /// Directional lights\n    let sumDirLightIntensity = 0;\n\n    for (let dirLightData of light.lights) {\n      hasLight = true;\n\n      let color = new THREE.Color(\n        dirLightData.color[2] / 255.0,\n        dirLightData.color[1] / 255.0,\n        dirLightData.color[0] / 255.0\n      );\n\n      let directionalLight = new THREE.DirectionalLight(\n        color.getHex(),\n        dirLightData.intensity\n      );\n\n      directionalLight.position\n        .set(\n          -dirLightData.direction[0],\n          dirLightData.direction[2],\n          dirLightData.direction[1]\n        )\n        .normalize();\n\n      sumDirLightIntensity += dirLightData.intensity;\n\n      lightOutput.push(directionalLight);\n    } // END for each directional light in light\n\n    /// Add some random directional lighting if there was no, in order to se SOME depth on models\n    if (!light.lights || light.lights.length === 0) {\n      const directions = [[0, 1, 0, 0.3], [1, 2, 1, 0.3], [-1, -2, -1, 0.3]];\n\n      for (let lightDir of directions) {\n        const color = new THREE.Color(1, 1, 1);\n        let intensity = lightDir[3];\n        let directionalLight = new THREE.DirectionalLight(\n          color.getHex(),\n          intensity\n        );\n\n        directionalLight.position\n          .set(lightDir[0], lightDir[1], lightDir[2])\n          .normalize();\n\n        sumDirLightIntensity += intensity;\n\n        lightOutput.push(directionalLight);\n      }\n    }\n\n    /// Ambient light\n    // light.backlightIntensity /= sumDirLightIntensity +light.backlightIntensity;\n    light.backlightIntensity = sumDirLightIntensity; // light.backlightIntensity;\n    const color = new THREE.Color(\n      (light.backlightIntensity * (255.0 - light.backlightColor[2])) / 255.0,\n      (light.backlightIntensity * (255.0 - light.backlightColor[1])) / 255.0,\n      (light.backlightIntensity * (255.0 - light.backlightColor[0])) / 255.0\n    );\n\n    ambientLight = new THREE.AmbientLight(color);\n  } // END for each light in lighting\n\n  let ambientTotal = 0;\n  if (ambientLight) {\n    ambientTotal =\n      ambientLight.color.r + ambientLight.color.g + ambientLight.color.b;\n    lightOutput.push(ambientLight);\n  }\n\n  /// Parsing done, return hasLight flag and lights\n  return {\n    lights: lightOutput,\n    hasLight: hasLight || ambientTotal > 0\n  };\n}\n\nfunction parseSkybox(\n  environmentChunkData,\n  parameterChunkData,\n  hazeColorAsInt,\n  skyboxFallbackArray,\n  localReader\n) {\n  /// set up output array\n  let skyElements = [];\n\n  /// Grab sky texture.\n  /// index 0 and 1 day\n  /// index 2 and 3 evening\n  let skyModeTex =\n    this.environmentChunkData &&\n    this.environmentChunkData.dataGlobal.skyModeTex[0];\n\n  /// Fallback skyboxfrom dat.\n  if (!skyModeTex) {\n    skyModeTex = {\n      texPathNE: 1930687,\n      texPathSW: 193069,\n      texPathT: 193071\n    };\n  }\n\n  /// Calculate bounds\n  const bounds = parameterChunkData.rect;\n  let mapW = Math.abs(bounds.x1 - bounds.x2);\n  let mapD = Math.abs(bounds.y1 - bounds.y2);\n  let boundSide = Math.max(mapW, mapD);\n\n  let materialArray = [];\n\n  /// Load skybox textures, fallback to hosted png files.\n  loadTextureWithFallback(\n    [1, 4],\n    materialArray,\n    skyModeTex.texPathNE + 1,\n    skyboxFallbackArray[0],\n    hazeColorAsInt,\n    localReader\n  );\n  loadTextureWithFallback(\n    [0, 5],\n    materialArray,\n    skyModeTex.texPathSW + 1,\n    skyboxFallbackArray[1],\n    hazeColorAsInt,\n    localReader\n  );\n  loadTextureWithFallback(\n    [2],\n    materialArray,\n    skyModeTex.texPathT + 1,\n    skyboxFallbackArray[2],\n    hazeColorAsInt,\n    localReader\n  );\n  materialArray[3] = new THREE.MeshBasicMaterial({\n    visible: false\n  });\n\n  /// Create skybox geometry\n  const boxSize = 1024;\n  let skyGeometry = new THREE.BoxGeometry(boxSize, boxSize / 2, boxSize); // Width Height Depth\n\n  /// Ugly way of fixing UV maps for the skybox (I think)\n  for (let idx in skyGeometry.faceVertexUvs[0]) {\n    let vecs = skyGeometry.faceVertexUvs[0][idx];\n\n    let face = Math.floor(idx / 2);\n\n    // PX NX\n    // PY NY\n    // PZ NZ\n\n    /// PX - WEST \tNX - EAST\n    if (face === 0 || face === 1) {\n      for (let vec2 of vecs) {\n        vec2.x = 1 - vec2.x;\n        vec2.y /= 2.0;\n        vec2.y += 0.5;\n      }\n    }\n\n    /// NZ - SOUTH \tPZ - NORTH\n    else if (face === 5 || face === 4) {\n      for (let vec2 of vecs) {\n        vec2.y /= -2.0;\n        vec2.y += 0.5;\n      }\n    } else {\n      for (let vec2 of vecs) {\n        vec2.x = 1 - vec2.x;\n      }\n    }\n  }\n\n  skyGeometry.uvsNeedUpdate = true;\n\n  /// Generate final skybox\n  let skyBox = new THREE.Mesh(skyGeometry, materialArray);\n\n  /// Put horizon in camera center\n  skyBox.translateY(boxSize / 4);\n  // skyBox.translateY( -environmentChunk.data.dataGlobal.sky.verticalOffset );\n\n  /// Write to output\n  skyElements.push(skyBox);\n\n  /// And return\n  return {\n    skyElements: skyElements\n  };\n}\n\nmodule.exports = {\n  getHazeColor: getHazeColor,\n  parseLights: parseLights,\n  parseSkybox: parseSkybox\n};\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nfunction renderModels(rendererData, models, title, callback) {\n  let mat;\n  if (rendererData.settings && rendererData.settings.visible) {\n    mat = new THREE.MeshNormalMaterial({\n      side: THREE.DoubleSide\n    });\n  } else {\n    mat = new THREE.MeshBasicMaterial({\n      visible: false\n    });\n  }\n\n  parseAllModels(rendererData, models, mat, title, 200, 0, callback);\n}\n\nfunction getCollisionsForAnimation(animation, collisions) {\n  let ret = [];\n\n  for (let i = 0; i < animation.collisionIndices.length; i++) {\n    let index = animation.collisionIndices[i];\n    let collision = collisions[index];\n    collision.index = index;\n    ret.push(collision);\n  }\n\n  return ret;\n}\n\nfunction parseAllModels(\n  rendererData,\n  models,\n  mat,\n  title,\n  chunkSize,\n  offset,\n  callback\n) {\n  let i = offset;\n\n  for (; i < offset + chunkSize && i < models.length; i++) {\n    let p = Math.round((i * 100) / models.length);\n    if (p !== rendererData.lastP) {\n      T3D.Logger.log(\n        T3D.Logger.TYPE_PROGRESS,\n        \"Loading Collision Models (\" + title + \")\",\n        p\n      );\n      rendererData.lastP = p;\n    }\n\n    /// Get animation object\n    let animation = animationFromGeomIndex(\n      models[i].geometryIndex,\n      rendererData.geometries,\n      rendererData.animations\n    );\n\n    let collisions = getCollisionsForAnimation(\n      animation,\n      rendererData.havokChunkData.collisions\n    );\n\n    for (let j = 0; j < collisions.length; j++) {\n      let collision = collisions[j];\n      renderMesh(rendererData, collision, models[i], mat);\n    }\n  }\n\n  if (i < models.length) {\n    window.setTimeout(() => {\n      parseAllModels(\n        rendererData,\n        models,\n        mat,\n        title,\n        chunkSize,\n        offset + chunkSize,\n        callback\n      );\n    }, 10 /* time in ms to next call */);\n  } else {\n    callback(rendererData.output);\n  }\n}\n\nfunction animationFromGeomIndex(propGeomIndex, geometries, animations) {\n  // geometries is just list of all geometries.animations[end] for now\n  let l = geometries[propGeomIndex].animations.length;\n\n  return animations[geometries[propGeomIndex].animations[l - 1]];\n  // return animations[ geometries[propGeomIndex].animations[0] ];\n}\n\nfunction renderMesh(rendererData, collision, model, mat) {\n  let pos = model.translate;\n  let rot = model.rotate;\n  let scale = 32 * model.scale;\n\n  /// Generate mesh\n  let mesh = parseHavokMesh(rendererData, collision, mat);\n\n  /// Position mesh\n  /// \"x\",\"float32\",\"z\",\"float32\",\"y\",\"float32\"\n  mesh.position.set(pos[0], -pos[2], -pos[1]);\n\n  /// Scale mesh\n  if (scale) mesh.scale.set(scale, scale, scale);\n\n  /// Rotate mesh\n  if (rot) {\n    mesh.rotation.order = \"ZXY\";\n\n    // [\"x\",\"float32\",\"z\",\"float32\",\"y\",\"float32\"],\n    mesh.rotation.set(rot[0], -rot[2], -rot[1]);\n  }\n\n  /// Add mesh to scene and collisions\n  rendererData.output.meshes.push(mesh);\n}\n\nfunction parseHavokMesh(rendererData, collision, mat) {\n  let index = collision.index;\n\n  if (!rendererData.meshes[index]) {\n    let geom = new THREE.Geometry();\n\n    /// Pass vertices\n    for (let i = 0; i < collision.vertices.length; i++) {\n      let v = collision.vertices[i];\n      // \"x\",\"float32\",\"z\",\"float32\",\"y\",\"float32\"]\n      geom.vertices.push(new THREE.Vector3(v[0], v[2], -v[1]));\n    }\n\n    /// Pass faces\n    for (let i = 0; i < collision.indices.length; i += 3) {\n      let f1 = collision.indices[i];\n      let f2 = collision.indices[i + 1];\n      let f3 = collision.indices[i + 2];\n\n      if (\n        f1 <= collision.vertices.length &&\n        f2 <= collision.vertices.length &&\n        f3 <= collision.vertices.length\n      ) {\n        geom.faces.push(new THREE.Face3(f1, f2, f3));\n      } else {\n        T3D.Logger.log(\n          T3D.Logger.TYPE_ERROR,\n          \"Errorus index in havok model geometry.\"\n        );\n      }\n    }\n\n    /// Prepare geometry and pass new mesh\n    geom.computeFaceNormals();\n    // geom.computeVertexNormals();\n\n    rendererData.meshes[index] = new THREE.Mesh(geom, mat);\n\n    return rendererData.meshes[index];\n  } else {\n    return rendererData.meshes[index].clone();\n  }\n}\n\nmodule.exports = { renderModels };\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst ModelUtils = require(\"../util/ModelUtils\");\n\nconst renderIndex = function(\n  localReader,\n  propsArray,\n  idx,\n  callback,\n  lastPct = -1,\n  meshCache = {},\n  textureCache = {},\n  output = { meshes: [] }\n) {\n  if (idx >= propsArray.length) {\n    /// Empty mesh cache\n    meshCache = {};\n    textureCache = {};\n    callback(output);\n    return;\n  }\n\n  let pct = Math.round((1000.0 * idx) / propsArray.length);\n  pct /= 10.0;\n\n  /// Log progress\n  if (lastPct !== pct) {\n    let pctStr = pct + (pct.toString().indexOf(\".\") < 0 ? \".0\" : \"\");\n\n    T3D.Logger.log(\n      T3D.Logger.TYPE_PROGRESS,\n      \"Loading 3D Models (Props)\",\n      pctStr\n    );\n    lastPct = pct;\n  }\n\n  /// Read prop at index.\n  let prop = propsArray[idx];\n\n  /// Adds a single mesh to a group.\n  let addMeshToLOD = function(mesh, groups, lod, prop, needsClone) {\n    /// Read lod distance before overwriting mesh variable\n    let lodDist = prop.lod2 !== 0 ? prop.lod2 : mesh.lodOverride[1];\n\n    /// Read flags before overwriting mesh variable\n    let flags = mesh.flags;\n\n    /// Mesh flags are 0 1 4\n    /// For now, use flag 0 as the default level of detail\n    if (flags === 0) lodDist = 0;\n\n    /// Create new empty mesh if needed\n    if (needsClone) {\n      mesh = new THREE.Mesh(mesh.geometry, mesh.material);\n    }\n\n    mesh.updateMatrix();\n    mesh.matrixAutoUpdate = false;\n\n    // Find group for this LOD distance\n    if (groups[lodDist]) {\n      groups[lodDist].add(mesh);\n    }\n    // Or create LOD group and add to a level of detail\n    // WIP, needs some testing!\n    else {\n      let group = new THREE.Group();\n      group.updateMatrix();\n      group.matrixAutoUpdate = false;\n      group.add(mesh);\n      groups[lodDist] = group;\n      lod.addLevel(group, lodDist);\n    }\n\n    return lodDist;\n  };\n\n  /// Adds array of meshes to the scene, also adds transform clones\n  let addMeshesToScene = function(meshArray, needsClone, boundingSphere) {\n    /// Add original\n\n    /// Make LOD object and an array of groups for each LOD level\n    let groups = {};\n    let lod = new THREE.LOD();\n\n    /// Each mesh is added to a group corresponding to its LOD distane\n    let maxDist = 0;\n    meshArray.forEach(function(mesh) {\n      maxDist = Math.max(\n        maxDist,\n        addMeshToLOD(mesh, groups, lod, prop, needsClone)\n      );\n    });\n\n    /// Add invisible level (the raycaster crashes on lod without any levels)\n    lod.addLevel(new THREE.Group(), 100000);\n\n    /// Set position, scale and rotation of the LOD object\n    if (prop.rotation) {\n      lod.rotation.order = \"ZXY\";\n      // [\"x\",\"float32\",\"z\",\"float32\",\"y\",\"float32\"],\n      lod.rotation.set(prop.rotation[0], -prop.rotation[2], -prop.rotation[1]);\n    }\n    lod.scale.set(prop.scale, prop.scale, prop.scale);\n    lod.position.set(prop.position[0], -prop.position[2], -prop.position[1]);\n\n    lod.boundingSphereRadius =\n      (boundingSphere && boundingSphere.radius ? boundingSphere.radius : 1.0) *\n      prop.scale;\n\n    lod.updateMatrix();\n    lod.matrixAutoUpdate = false;\n\n    /// Show highest level always\n    // lod.update(lod);\n\n    // Add LOD containing mesh instances to scene\n    // self.getOutput().meshes.push(lod);\n    output.meshes.push(lod);\n\n    // Add one copy per transform, needs to be within it's own LOD\n    if (prop.transforms) {\n      prop.transforms.forEach(function(transform) {\n        /// Make LOD object and an array of groups for each LOD level\n        let groups = {};\n        let lod = new THREE.LOD();\n\n        /// Each mesh is added to a group corresponding to its LOD distane\n        let maxDist = 0;\n        meshArray.forEach(function(mesh) {\n          maxDist = Math.max(\n            maxDist,\n            addMeshToLOD(mesh, groups, lod, prop, true)\n          );\n        });\n\n        /// Add invisible level\n        // lod.addLevel(new THREE.Group(),10000);\n\n        /// Set position, scale and rotation of the LOD object\n        if (transform.rotation) {\n          lod.rotation.order = \"ZXY\";\n          lod.rotation.set(\n            transform.rotation[0],\n            -transform.rotation[2],\n            -transform.rotation[1]\n          );\n        }\n        lod.scale.set(transform.scale, transform.scale, transform.scale);\n        lod.position.set(\n          transform.position[0],\n          -transform.position[2],\n          -transform.position[1]\n        );\n\n        lod.updateMatrix();\n        lod.matrixAutoUpdate = false;\n\n        lod.boundingSphereRadius =\n          (boundingSphere && boundingSphere.radius\n            ? boundingSphere.radius\n            : 1.0) * prop.scale;\n\n        /// Show highest level always\n        lod.update(lod);\n\n        /// Add LOD containing mesh instances to scenerender: function(propertiesChunkHeader, map, localReader, renderCallback){\n        // self.getOutput().meshes.push(lod);\n        output.meshes.push(lod);\n      });\n    }\n  };\n\n  /// Get meshes\n  let showUnmaterialed = false;\n  ModelUtils.getMeshesForFilename(\n    prop.filename,\n    prop.color,\n    localReader,\n    meshCache,\n    textureCache,\n    showUnmaterialed,\n    false,\n    function(meshes, isCached, boundingSphere) {\n      if (meshes) {\n        addMeshesToScene(meshes, isCached, boundingSphere);\n      }\n\n      /// Render next prop\n      renderIndex(\n        localReader,\n        propsArray,\n        idx + 1,\n        callback,\n        lastPct,\n        meshCache,\n        textureCache,\n        output\n      );\n    }\n  );\n};\n\nconst getIdsForProp = function(props, idx, callback, fileIds = []) {\n  if (idx >= props.length) {\n    callback(fileIds);\n    return;\n  }\n\n  if (idx % 100 === 0) {\n    T3D.Logger.log(\n      T3D.Logger.TYPE_MESSAGE,\n      \"getting ids for entry\",\n      idx,\n      \"of\",\n      props.length\n    );\n  }\n\n  let prop = props[idx];\n  ModelUtils.getFilesUsedByModel(prop.filename, this.localReader, function(\n    propFileIds\n  ) {\n    fileIds = fileIds.concat(propFileIds);\n    getIdsForProp(props, idx + 1, callback, fileIds);\n  });\n};\n\nmodule.exports = {\n  renderIndex: renderIndex,\n  getIdsForProp: getIdsForProp\n};\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst RenderUtils = require(\"./RenderUtils\");\nconst MaterialUtils = require(\"./MaterialUtils\");\nconst TerrainShader = require(\"./TerrainShader\");\nconst GW2File = require(\"../format/file/GW2File\");\n\nfunction drawWater(rect) {\n  /// Add Water\n  const material = new THREE.MeshBasicMaterial({\n    color: 0x5bb1e8,\n    wireframe: false,\n    opacity: 0.35\n  });\n\n  material.transparent = true;\n  return RenderUtils.renderRect(rect, 0, material);\n}\n\nfunction parseNumChunks(terrainData) {\n  terrainData.numChunksD_1 = Math.sqrt(\n    (terrainData.dims[0] * terrainData.chunkArray.length) / terrainData.dims[1]\n  );\n  terrainData.numChunksD_2 =\n    terrainData.chunkArray.length / terrainData.numChunksD_1;\n}\n\n/**\n *\n * @param {*} inflatedBuffer\n * @param {*} mapFile\n * @param {*} anisotropy\n * @param {*} envOutput\n * @param {*} localReader\n * @returns {Promise<{terrainTiles: Array, water: *, mapRect: *}>}\n */\nasync function loadPagedImageCallback(\n  inflatedBuffer,\n  mapFile,\n  anisotropy,\n  envOutput,\n  localReader\n) {\n  // Prep output variables\n  let terrainTiles = [];\n\n  let pimgDS = new DataStream(inflatedBuffer);\n  let pimgFile = new GW2File(pimgDS, 0);\n  let pimgTableDataChunk = pimgFile.getChunk(\"pgtb\");\n  let pimgData = pimgTableDataChunk && pimgTableDataChunk.data;\n\n  let mapRect = null;\n\n  /// Fetch chunks\n  let terrainData = mapFile.getChunk(\"trn\").data;\n  let parameterData = mapFile.getChunk(\"parm\").data;\n\n  /// Read settings\n  let maxAnisotropy = anisotropy || 1;\n\n  let chunkW = 35;\n\n  /// Calculate numChunksD_1 and _2\n  parseNumChunks(terrainData);\n\n  let xChunks = terrainData.numChunksD_1;\n  let yChunks = terrainData.numChunksD_2;\n\n  let allMaterials = terrainData.materials.materials;\n  let allTextures = terrainData.materials.texFileArray;\n\n  // Total map dx and dy\n  let dx = parameterData.rect[2] - parameterData.rect[0];\n  let dy = parameterData.rect[3] - parameterData.rect[1];\n\n  // Each chunk dx and dy\n  let cdx = (dx / terrainData.numChunksD_1) * 1; //  35/33;\n  let cdy = (dy / terrainData.numChunksD_2) * 1; // 35/33;\n  let n = 0;\n  let allMats = [];\n  let customMaterial = new THREE.MeshLambertMaterial({\n    side: THREE.DoubleSide,\n    color: 0x666666,\n    flatShading: true\n  });\n\n  /// Load textures from PIMG and inject as material maps (textures)\n  let chunkTextures = {};\n\n  /// Load textures\n  if (pimgData) {\n    let strippedPages = pimgData.strippedPages;\n\n    /// Only use layer 0\n    strippedPages.forEach(function(page) {\n      /// Only load layer 0 and 1\n      if (page.layer <= 1) {\n        let filename = page.filename;\n        let coord = page.coord;\n\n        let matName = coord[0] + \",\" + coord[1];\n        if (page.layer === 1) matName += \"-2\";\n\n        /// Add texture to list, note that coord name is used, not actual file name\n        if (!chunkTextures[matName]) {\n          /// Load local texture, here we use file name!\n          let chunkTex = MaterialUtils.loadLocalTexture(localReader, filename);\n\n          if (chunkTex) {\n            /// Set repeat, antistropy and repeat Y\n            chunkTex.anisotropy = maxAnisotropy;\n            chunkTex.wrapS = THREE.RepeatWrapping;\n            chunkTex.wrapT = THREE.RepeatWrapping;\n          }\n\n          /// ...But store in coord name\n          chunkTextures[matName] = chunkTex;\n        }\n      }\n    }); /// end for each stripped page in pimgData\n  }\n\n  /// Render Each chunk\n  /// We'll make this async in order for the screen to be able to update\n\n  let renderChunk = function(cx, cy) {\n    let chunkIndex = cy * xChunks + cx;\n\n    let pageX = Math.floor(cx / 4);\n    let pageY = Math.floor(cy / 4);\n\n    // TODO: Terrain texture LOD ?\n    let chunkTextureIndices =\n      allMaterials[chunkIndex].loResMaterial.texIndexArray;\n\n    // var chunkTextureIndices = allMaterials[chunkIndex].hiResMaterial.texIndexArray;\n    // var matFileName = allMaterials[chunkIndex].hiResMaterial.materialFile;\n\n    let mat = customMaterial;\n\n    /// TODO: just tick invert y = false...?\n    let pageOffetX = (cx % 4) / 4.0;\n    let pageOffetY = 0.75 - (cy % 4) / 4.0;\n\n    // offset 0 -> 0.75\n\n    // Make sure we have shared textures\n\n    /// Load and store all tiled textures\n    let fileNames = [];\n    for (let gi = 0; gi < chunkTextureIndices.length / 2; gi++) {\n      let textureFileName = allTextures[chunkTextureIndices[gi]].filename;\n\n      fileNames.push(textureFileName);\n\n      /// If the texture is not already loaded, read it from the .dat!\n      if (!chunkTextures[textureFileName]) {\n        /// Load local texture\n        let chunkTex = MaterialUtils.loadLocalTexture(\n          localReader,\n          textureFileName\n        );\n\n        if (chunkTex) {\n          /// Set repeat, antistropy and repeat Y\n          chunkTex.anisotropy = maxAnisotropy;\n          chunkTex.wrapS = THREE.RepeatWrapping;\n          chunkTex.wrapT = THREE.RepeatWrapping;\n        }\n\n        chunkTextures[textureFileName] = chunkTex;\n      }\n    } /// End for each chunkTextureIndices\n\n    /// Create Composite texture material, refering the shared textures\n    let pageTexName = pageX + \",\" + pageY;\n    let pageTexName2 = pageX + \",\" + pageY + \"-2\";\n\n    // var fog = SceneUtils.getScene().fog;\n    let fog = {\n      color: {\n        r: 1,\n        g: 1,\n        b: 1\n      },\n      near: 0,\n      far: 0\n    };\n\n    /// Set the haze from the environment output\n    if (envOutput.hazeColor) {\n      fog.color.r = envOutput.hazeColor[2] / 255.0;\n      fog.color.g = envOutput.hazeColor[1] / 255.0;\n      fog.color.b = envOutput.hazeColor[0] / 255.0;\n    }\n\n    let uniforms = THREE.UniformsUtils.merge([THREE.UniformsLib[\"lights\"]]);\n\n    /// TODO: READ FROM VO, don't default to hard coded scale\n    uniforms.uvScale = {\n      type: \"v2\",\n      value: new THREE.Vector2(8.0, 8.0)\n    };\n    uniforms.offset = {\n      type: \"v2\",\n      value: new THREE.Vector2(pageOffetX, pageOffetY)\n    };\n\n    uniforms.texturePicker = {\n      type: \"t\",\n      value: chunkTextures[pageTexName]\n    };\n    uniforms.texturePicker2 = {\n      type: \"t\",\n      value: chunkTextures[pageTexName2]\n    };\n\n    uniforms.texture1 = {\n      type: \"t\",\n      value: chunkTextures[fileNames[0]]\n    };\n    uniforms.texture2 = {\n      type: \"t\",\n      value: chunkTextures[fileNames[1]]\n    };\n    uniforms.texture3 = {\n      type: \"t\",\n      value: chunkTextures[fileNames[2]]\n    };\n    uniforms.texture4 = {\n      type: \"t\",\n      value: chunkTextures[fileNames[3]]\n    };\n\n    mat = new THREE.ShaderMaterial({\n      uniforms: uniforms,\n      fragmentShader: TerrainShader.getFragmentShader(),\n      vertexShader: TerrainShader.getVertexShader()\n    });\n\n    /// Store referenceto each material\n    allMats.push(mat);\n\n    /// -1 for faces -> vertices , -2 for ignoring outer faces\n    let chunkGeo = new THREE.PlaneBufferGeometry(\n      cdx,\n      cdy,\n      chunkW - 3,\n      chunkW - 3\n    );\n\n    let cn = 0;\n\n    /// Render chunk\n\n    /// Each chunk vertex\n    for (let y = 0; y < chunkW; y++) {\n      for (let x = 0; x < chunkW; x++) {\n        if (x !== 0 && x !== chunkW - 1 && y !== 0 && y !== chunkW - 1) {\n          chunkGeo.getAttribute(\"position\").array[cn * 3 + 2] =\n            terrainData.heightMapArray[n];\n          cn++;\n        }\n\n        n++;\n      }\n    } // End each chunk vertex\n\n    /// Flip the plane to fit wonky THREE js world axes\n    let mS = new THREE.Matrix4().identity();\n    mS.elements[5] = -1;\n    chunkGeo.applyMatrix(mS);\n\n    /// Compute face normals for lighting, not used when textured\n    chunkGeo.computeFaceNormals();\n    // chunkGeo.computeVertexNormals();\n\n    /// Build chunk mesh!\n    let chunk;\n    chunk = new THREE.Mesh(chunkGeo, customMaterial);\n    if (mat.length) {\n      chunk = THREE.SceneUtils.createMultiMaterialObject(chunkGeo, mat);\n    } else {\n      chunk = new THREE.Mesh(chunkGeo, mat);\n    }\n\n    /// Move and rotate Mesh to fit in place\n    chunk.rotation.set(Math.PI / 2, 0, 0);\n\n    /// Last term is the new one: -cdx*(2/35)\n    let globalOffsetX = parameterData.rect[0] + cdx / 2;\n    let chunkOffsetX = cx * cdx;\n\n    chunk.position.x = globalOffsetX + chunkOffsetX;\n\n    /// Adjust for odd / even number of chunks\n    if (terrainData.numChunksD_2 % 2 === 0) {\n      /// Last term is the new one: -cdx*(2/35)\n      const globalOffsetY = parameterData.rect[1] + cdy / 2 - 0; // -cdy*(1/35);\n      const chunkOffsetY = cy * cdy * 1; // 33/35;\n\n      chunk.position.z = chunkOffsetY + globalOffsetY;\n    } else {\n      const globalOffsetY = parameterData.rect[1] - cdy / 2 + 0; // cdy*(1/35);\n      const chunkOffsetY = cy * cdy * 1; // 33/35;\n\n      chunk.position.z = globalOffsetY + chunkOffsetY;\n    }\n\n    let px = chunk.position.x;\n    let py = chunk.position.z;\n\n    if (!mapRect) {\n      mapRect = {\n        x1: px - cdx / 2,\n        x2: px + cdx / 2,\n        y1: py - cdy / 2,\n        y2: py + cdy / 2\n      };\n    }\n\n    mapRect.x1 = Math.min(mapRect.x1, px - cdx / 2);\n    mapRect.x2 = Math.max(mapRect.x2, px + cdx / 2);\n\n    mapRect.y1 = Math.min(mapRect.y1, py - cdy / 2);\n    mapRect.y2 = Math.max(mapRect.y2, py + cdy / 2);\n\n    chunk.updateMatrix();\n    chunk.updateMatrixWorld();\n\n    /// Add to list of stuff to render\n    /// TODO: Perhaps use some kind of props for each entry instead?\n    terrainTiles.push(chunk);\n  }; /// End render chunk function\n\n  let cx = 0;\n\n  let cy = 0;\n\n  while (cy < yChunks) {\n    // Process chunk\n    renderChunk(cx, cy);\n\n    // Step to next chunk\n    cx += 1;\n    if (cx >= xChunks) {\n      cx = 0;\n      cy++;\n    }\n\n    await new Promise(resolve => setTimeout(resolve, 1));\n\n    // Log\n    let pct = Math.floor((100 * (cy * xChunks + cx)) / (xChunks * yChunks));\n    T3D.Logger.log(T3D.Logger.TYPE_PROGRESS, \"Loading Terrain\", pct);\n  }\n\n  return {\n    terrainTiles: terrainTiles,\n\n    // Draw water surface using map bounds:\n    water: drawWater(mapRect),\n\n    // Return bounds:\n    mapRect: mapRect\n  };\n}\n\nfunction getTerrainFilesId(mapFile) {\n  let terrainChunk = mapFile.getChunk(\"trn\");\n  let pimgTableDataChunk = mapFile.getChunk(\"pimg\");\n  let fileIds = [];\n\n  /// ------------ SPLASH TEXTURES ------------\n  let pimgData = pimgTableDataChunk && pimgTableDataChunk.data;\n  let strippedPages = pimgData.strippedPages;\n\n  /// Only use layer 0\n  strippedPages.forEach(function(page) {\n    /// Only load layer 0 and 1\n    if (page.layer <= 1 && page.filename > 0) {\n      fileIds.push(page.filename);\n    }\n  });\n  /// ------------ END SPLASH TEXTURES ------------\n\n  /// ------------ TILED IMAGES ------------\n  let terrainData = terrainChunk.data;\n  let allTextures = terrainData.materials.texFileArray;\n  allTextures.forEach(function(texture) {\n    if (texture.filename > 0) fileIds.push(texture.filename);\n  });\n  /// ------------ END TILED IMAGES ------------\n\n  return fileIds;\n}\n\nmodule.exports = {\n  loadPagedImageCallback: loadPagedImageCallback,\n  getTerrainFilesId: getTerrainFilesId\n};\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\nconst ModelUtils = require(\"../util/ModelUtils\");\n\nfunction renderZone(rendererData, zone, zoneDefs, mapRect, renderZoneCallback) {\n  /// Get Zone Definition\n  let zoneDef = null;\n  zoneDefs.forEach(function(zd) {\n    if (!zoneDef && zd.token === zone.defToken) zoneDef = zd;\n  });\n\n  /// Create array of all models to add:\n  let modelGroups = getModelGroups(rendererData, zone, zoneDef, mapRect);\n\n  /// Create empty mesh cache\n  rendererData.meshCache = {};\n  rendererData.textureCache = {};\n\n  /*\n   * ---Keeping this out of the doc for now---\n   * Steps trough each model and renders it to the scene, allowing for efficient caching.\n   * @param  {Number} i - Current index within the models array\n   */\n  // var lastPct = -1;\n  let groupKeys = Object.keys(modelGroups);\n\n  function stepModels(i) {\n    /* var pct = Math.round(100.0*i / groupKeys.length);\n    if(lastPct!=pct){\n      console.log(\"Rendering ZONE models \"+pct);\n      lastPct = pct;\n    } */\n\n    if (i >= groupKeys.length) {\n      /// Empty mesh cache\n      rendererData.meshCache = {};\n      rendererData.textureCache = {};\n\n      /// Tell caller this zone is done loading\n      renderZoneCallback();\n      return;\n    }\n\n    /// Read model at index\n    /// var model = models[i];\n    let key = groupKeys[i]; /// key is model filename\n    let group = modelGroups[key];\n\n    let meshGroups = [];\n\n    /// Get model just once for this group\n    let showUnmaterialed = false;\n    ModelUtils.getMeshesForFilename(\n      key,\n      null,\n      rendererData.localReader,\n      rendererData.meshCache,\n      rendererData.textureCache,\n      showUnmaterialed,\n      false,\n\n      function(meshes, isCached) {\n        /// If there were meshes, add them to the scene with correct scaling rotation etc.\n        if (meshes /* && meshes.length == 3 */) {\n          /// Add one copy per model instance\n          /// TODO: add rotation!\n          /// TODO: fine tune position?\n          /// TODO: POTIMIZE!\n\n          group.forEach(function(model, instanceIdx) {\n            /// For each Mesh in the model\n            meshes.forEach(function(mesh, meshIdx) {\n              if (\n                mesh.materialFlags ===\n                525 /* || mesh.materialFlags == 520 || mesh.materialFlags == 521 */\n              ) {\n                // console.log(\"Skipping lod\");\n                return;\n              }\n\n              let move = {\n                x: 0,\n                y: 0,\n                z: 0\n              };\n\n              /// Add to big mesh\n              if (!meshGroups[meshIdx]) {\n                let mg = mesh.geometry.clone();\n                meshGroups[meshIdx] = {\n                  readVerts: mg.getAttribute(\"position\").array,\n                  verts: new Float32Array(\n                    group.length * mg.getAttribute(\"position\").array.length\n                  ),\n\n                  readIndices: mg.getIndex().array,\n                  indices: new Uint32Array(\n                    group.length * mg.getIndex().array.length\n                  ),\n\n                  readUVs: mg.getAttribute(\"uv\").array,\n                  uvs: new Float32Array(\n                    group.length * mg.getAttribute(\"uv\").array.length\n                  ),\n\n                  readNormals: mg.getAttribute(\"normal\").array,\n                  normals: new Float32Array(\n                    group.length * mg.getAttribute(\"normal\").array.length\n                  ),\n\n                  material: mesh.material,\n                  // material:new THREE.MeshBasicMaterial( {color: 0xffcccc, wireframe:true} ),\n                  /* material : new THREE.PointCloudMaterial ({\n                  color: 0xFF0000,\n                  size: 20\n                  }), */\n                  position: {\n                    x: model.x,\n                    y: model.y,\n                    z: model.z\n                  }\n                };\n              } else {\n                /// Translate\n                move.x = model.x - meshGroups[meshIdx].position.x;\n                move.y = model.z - meshGroups[meshIdx].position.z;\n                move.z = model.y - meshGroups[meshIdx].position.y;\n              }\n\n              /// Add geom verts\n              let readVerts = meshGroups[meshIdx].readVerts;\n              let writeVerts = meshGroups[meshIdx].verts;\n              let stride = readVerts.length;\n\n              for (\n                let i = 0, j = instanceIdx * stride;\n                i < stride;\n                i += 3, j += 3\n              ) {\n                writeVerts[j + 0] = readVerts[i + 0] + move.x;\n                writeVerts[j + 1] = readVerts[i + 1] + move.y;\n                writeVerts[j + 2] = readVerts[i + 2] + move.z;\n              }\n\n              let readIndices = meshGroups[meshIdx].readIndices;\n              let writeIndices = meshGroups[meshIdx].indices;\n              let strideIndices = readIndices.length;\n              let shift = (stride * instanceIdx) / 3;\n\n              for (\n                let i = 0, j = instanceIdx * strideIndices;\n                i < strideIndices;\n                i++, j++\n              ) {\n                writeIndices[j] = readIndices[i] + shift;\n              }\n\n              let readUVs = meshGroups[meshIdx].readUVs;\n              let writeUvs = meshGroups[meshIdx].uvs;\n              let uvStride = readUVs.length;\n              for (\n                let i = 0, j = instanceIdx * uvStride;\n                i < uvStride;\n                i++, j++\n              ) {\n                writeUvs[j] = readUVs[i];\n              }\n\n              let readNormals = meshGroups[meshIdx].readNormals;\n              let writeNormals = meshGroups[meshIdx].normals;\n              let normalStride = readNormals.length;\n              for (\n                let i = 0, j = instanceIdx * normalStride;\n                i < normalStride;\n                i++, j++\n              ) {\n                writeNormals[j] = readNormals[i];\n              }\n            });\n          }); // End for each model in group\n        } /// End if meshes\n\n        /// Add each cluster of merged meshes to scene\n        meshGroups.forEach(function(meshGroup) {\n          let mergedGeom = new THREE.BufferGeometry();\n\n          mergedGeom.addAttribute(\n            \"position\",\n            new THREE.BufferAttribute(meshGroup.verts, 3)\n          );\n          // mergedGeom.addAttribute( 'index', new THREE.BufferAttribute( meshGroup.indices, 1) );\n          mergedGeom.setIndex(new THREE.BufferAttribute(meshGroup.indices, 1));\n          mergedGeom.addAttribute(\n            \"normal\",\n            new THREE.BufferAttribute(meshGroup.normals, 3)\n          );\n          mergedGeom.addAttribute(\n            \"uv\",\n            new THREE.BufferAttribute(meshGroup.uvs, 2)\n          );\n\n          mergedGeom.buffersNeedUpdate = true;\n\n          let mesh = new THREE.Mesh(mergedGeom, meshGroup.material);\n          mesh.position.set(\n            meshGroup.position.x,\n            meshGroup.position.z,\n            meshGroup.position.y\n          );\n\n          rendererData.output.meshes.push(mesh);\n        }); // End for each meshgroup\n\n        /// Rendering is done, render next.\n        stepModels(i + 1);\n      }\n    );\n  } /// End function stepModels\n\n  /// Begin stepping trough the models, rendering them.\n  stepModels(0);\n}\n\nfunction getModelGroups(rendererData, zone, zoneDef, mapRect) {\n  /// Calculate rect in global coordinates\n\n  let mapX = mapRect[0];\n  let mapY = mapRect[1];\n  let c = 32 + 16;\n\n  // [\"x1\",\"uint32\",\"y1\",\"uint32\",\"x2\",\"uint32\", \"y2\", \"uint32\"]\n  let zoneRect = {\n    x1: zone.vertRect[0] * c + mapX,\n    x2: zone.vertRect[2] * c + mapX,\n    y1: zone.vertRect[1] * -c - mapY,\n    y2: zone.vertRect[3] * -c - mapY\n  };\n\n  /// Zone width and depth in local corrdinates\n  /* var zdx = zone.vertRect.x1-zone.vertRect.x2;\n  var zdy = zone.vertRect.y1-zone.vertRect.y2; */\n\n  /// These zones seems to overflow :/\n  if (zone.encodeData.length === 0) {\n    return {};\n  }\n\n  let zdx = zone.vertRect[0] - zone.vertRect[2];\n  // let zdy = zone.vertRect[1] - zone.vertRect[3];\n\n  /// Zone Flags increases a linear position, used to step trough the Zone.\n  let linearPos = 0;\n\n  let modelGroups = {};\n\n  let terrainTiles = rendererData.terrainTiles;\n\n  for (let i = 0; i < zone.flags.length; i += 2) {\n    /// Step forward\n    linearPos += zone.flags[i];\n\n    /// Check if a model should be placed\n    let flag = zone.flags[i + 1];\n    if (flag !== 0) {\n      /// Extract flag data\n      /// Layer is written in the last 4 bytes\n      let zoneDefLayer = flag >> 4;\n\n      /// Get Zone Definition Layer\n      let layer = zoneDef.layerDefArray[zoneDefLayer - 1];\n\n      /// TESTING Only show layers with height >= 3\n      if (layer /* && layer.height >= 0 */) {\n        /// Get X and Y from linear position\n        let modelX = (linearPos % zdx) * c + zoneRect.x1;\n        let modelY = Math.floor(linearPos / zdx) * c + zoneRect.y1;\n\n        /// Get Z from intersection with terrain\n        let modelZ = null;\n\n        const startZ = 100000;\n\n        const raycaster = new THREE.Raycaster(\n          new THREE.Vector3(modelX, startZ, modelY),\n          new THREE.Vector3(0, -1, 0)\n        );\n\n        /// TODO: OPT?\n        terrainTiles.forEach(function(chunk) {\n          if (modelZ === null) {\n            let intersections = raycaster.intersectObject(chunk);\n            if (intersections.length > 0) {\n              modelZ = startZ - intersections[0].distance;\n            }\n          }\n        });\n\n        /// Get model id\n        /// TODO: check with modelIdx = flag & 0xf;\n        let modelIdx = 0;\n        let model = layer.modelArray[modelIdx];\n        let modelFilename = model.filename;\n        // let zOffsets = model.zOffsets;\n\n        // let layerFlags = layer.layerFlags; // NOrmaly 128, 128\n\n        // TODO: flip z,y?\n        let rotRangeX = layer.rotRangeX; // max min\n        let rotRangeY = layer.rotRangeY; // max min\n        let rotRangeZ = layer.rotRangeZ; // max min\n        let scaleRange = layer.scaleRange; // max min\n        let fadeRange = layer.fadeRange; // max min\n\n        // Unused\n        // tiling: 3\n        // type: 1\n        // width: 2\n        // radiusGround: 2\n\n        /// Create modelGroup (this zone only)\n        if (!modelGroups[modelFilename]) {\n          modelGroups[modelFilename] = [];\n        }\n\n        /// Add entry to model group\n        modelGroups[modelFilename].push({\n          x: modelX,\n          y: modelY,\n          z: modelZ,\n          rotRangeX: rotRangeX,\n          rotRangeY: rotRangeY,\n          rotRangeZ: rotRangeZ,\n          scaleRange: scaleRange,\n          fadeRange: fadeRange\n        });\n      } /// End if layer\n    } /// End if flag != 0\n  } /// End for each flag\n\n  return modelGroups;\n}\n\nmodule.exports = { renderZone };\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/*\n\tguid 1683952224941671000 is fucked up floor in SAB HUB\n\tmaterialFilename for that mesh is 564821, shared with lots of stuff\n\tlod 1 and 2 are both 0\n\tmaterial flags is 2056\n*/\n\n/**\n * Collection of methods for generating THREE materials and textures\n * from Guild Wars 2 data formats.\n * @namespace MaterialUtils\n */\n\n/**\n * Builds a custom vertex shader for a given number of uv cannels.\n * WIP not implemented yet!\n *\n * @memberof MaterialUtils\n * @param  {Number} numUv Number of UV channels used by this shader\n * @return {String}       Genereted vertex shader source\n */\nfunction buildVS(numUv) {\n  let vdefs = \"\";\n  let adefs = \"\";\n  let reads = \"\";\n  for (let i = 0; i < numUv; i++) {\n    vdefs += \"varying vec2 vUv_\" + (i + 1) + \";\\n\";\n\n    /// uv and uv2 are defined by THREE\n    if (i > 1) adefs += \"attribute vec2 uv\" + (i + 1) + \";\\n\";\n\n    reads += \"vUv_\" + (i + 1) + \" = uv\" + (i > 0 ? i + 1 : \"\") + \";\\n\";\n  }\n\n  return (\n    adefs +\n    vdefs +\n    \"void main()\\n\" +\n    \"{\\n\" +\n    reads +\n    \"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\" +\n    \"gl_Position = projectionMatrix * mvPosition;\\n\" +\n    \"}\"\n  );\n}\n\n/**\n * Generate a texture of a specified color, used to be part of THREEjs\n *\n * @memberof MaterialUtils\n * @param {Number} width\n * @param {Number} height\n * @param {THREE.Color} color\n * @returns {THREE.DataTexture}\n */\nfunction generateDataTexture(width, height, color) {\n  // create a buffer with color data\n  let size = width * height;\n  let data = new Uint8Array(4 * size);\n  let r = Math.floor(color.r * 255);\n  let g = Math.floor(color.g * 255);\n  let b = Math.floor(color.b * 255);\n  let a = 255;\n\n  for (let i = 0; i < size; i++) {\n    let stride = i * 4;\n\n    data[stride] = r;\n    data[stride + 1] = g;\n    data[stride + 2] = b;\n    data[stride + 3] = a;\n  }\n  // used the buffer to create a DataTexture\n  return new THREE.DataTexture(data, width, height, THREE.RGBAFormat);\n}\n\n/**\n * Builds a custom pixel shader for a given number of uv cannels.\n * WIP not implemented yet!\n *\n * @memberof MaterialUtils\n * @param  {Array}  textures  THREE textures\n * @param  {Number} numUv     Number of UV channels used by this shader\n * @param  {Number} alphaTest Texture see-trough alpha treshold\n * @param  {any} lightMap  TODO\n * @returns {string}\n */\nfunction buildPS(textures, numUv, alphaTest, lightMap) {\n  let t1uv = \"vUv_\" + (textures[0].uvIdx + 1);\n\n  let discard = \"\";\n\n  if (alphaTest) {\n    discard = \"    if (c1.a < 0.5) \\n\" + \"       discard;\\n\";\n  }\n\n  /// Color from 1st text or lighted by 2nd?\n  let writeColor = \"gl_FragColor = c1;\\n\";\n\n  if (lightMap) {\n    let texIdx = 0;\n    // var t2uv = \"vUv_4\";//+(3-textures[texIdx].uvIdx+1);\n    let t2uv = \"vUv_1\"; // + (textures[texIdx].uvIdx+1);\n    // console.log(\"t2uv\",t2uv);\n\n    writeColor =\n      \"   vec4 c2 = texture2D( texture\" +\n      (texIdx + 1) +\n      \", \" +\n      t2uv +\n      \" );\\n\" +\n      \"     gl_FragColor = c2;\\n\";\n    // \"     gl_FragColor = vec4(c2.rgb * c1.r/.5, c2.a);\\n\";\n  }\n\n  let uniforms = \"\";\n  textures.forEach(function(t, idx) {\n    uniforms += \"uniform sampler2D texture\" + (idx + 1) + \";\\n\";\n  });\n  /* uniforms += \"uniform sampler2D texture1;\\n\";\n\tif(lightMap)\n\t\tuniforms += \"uniform sampler2D texture2;\\n\"; */\n\n  let varyings = \"\";\n  for (let i = 0; i < numUv; i++) {\n    varyings += \"varying vec2 vUv_\" + (i + 1) + \";\\n\";\n  }\n\n  return (\n    uniforms +\n    varyings +\n    \"void main( void ) {\\n\" +\n    \"    vec4 c1 = texture2D( texture1, \" +\n    t1uv +\n    \" );\\n\" +\n    discard +\n    writeColor +\n    \"}\"\n  );\n}\n\n/**\n * WIP, concept for generatin materials to render multi UV chanelled meshes.\n *\n * @memberof MaterialUtils\n * @param  {Array} \ttextures  THREE texture\n * @param  {Number} numUV     Number of UV channels used by this shader\n * @param  {Number} alphaTest Texture see-trough alpha treshold\n * @return {THREE.ShaderMaterial} Generated shader\n */\nfunction getUVMat(textures, numUV, alphaTest) {\n  let lightMap = false;\n  let uniforms = {};\n\n  textures.forEach(function(t, idx) {\n    uniforms[\"texture\" + idx] = {\n      type: \"t\",\n      value: t\n    };\n  });\n\n  if (textures.length > 1) {\n    lightMap = true;\n  }\n\n  let attributes = {};\n\n  for (let i = 2; i < numUV; i++) {\n    attributes[\"uv\" + (i + 1)] = {\n      type: \"v2\",\n      value: []\n    };\n  }\n\n  let vs = buildVS(numUV);\n\n  return new THREE.ShaderMaterial({\n    uniforms: uniforms,\n    vertexShader: vs,\n    fragmentShader: buildPS(textures, numUV, alphaTest, lightMap),\n    attributes: attributes,\n    side: THREE.FrontSide\n  });\n}\n\n/**\n * Builds a THREE texture from a ModelMaterialData by reading settings and\n * loading any required data from the localReader. Uses sharedTextures for\n * texture caching.\n *\n * This method is full of guesses and estimations, and could be improved on\n * a lot, allowing rendering of multi UV channeled materials, or special\n * materials like custom color chanelled gear.\n *\n * @memberof MaterialUtils\n * @param  {ModelMaterialData} material \tA value object often automaticaly\n *                                       \tgenerated by a\n *                                       \t{{#crossLink \"GW2Chunk\"}}{{/crossLink}}\n *                                       \tstructure definitions can be found in\n *                                       \tAllFormats.js, look for the latest\n *                                       \tversion of ModelMaterialData\n *\n * @param  {GW2File} materialFile   A GW2File instance, must be of type AMAT\n * @param  {LocalReader} localReader The LocalReader to load the file contents from.\n * @param  {Object} sharedTextures  Value Object for keeping the texture cache\n * @return {THREE.Material}         A THREE Material with the generated contents and settings.\n */\nfunction getMaterial(material, materialFile, localReader, sharedTextures) {\n  if (!materialFile) return;\n\n  const dxChunk = materialFile.getChunk(\"dx9s\");\n  const grChunk = materialFile.getChunk(\"grmt\");\n\n  /// Append all textures to the custom material\n  let finalTextures = [];\n\n  // Some materials don't use textures..\n  if (\n    material &&\n    material.textures.length /* && material.textures[texIndex] */\n  ) {\n    /// TODO: check for flags!\n    //\n    /// techinques[] -> passes[] -> effects[] -> samplerIndex[]\n    //\n    // console.log(\"num effects\",dxChunk.data.techniques[0].passes[0].effects.length);\n\n    // if(grChunk.data.flags!=76)\n    //\treturn;\n\n    /// 3 teqs : high medium low\t\t\t\t\t\t\t\tGRAPHICS LEVEL SETTINGS\n    /// 1 passes\t\t\t\t\t\t\t\t\t\t\t\tDON'T CARE\n    /// 15 effects\t\t\tEach effect has a pixel shader \t\tHOW??\n    /// 1 or 2 sampler indices \t\t\t\t\t\t\t\t\tUSE ALL! (Multi material)\n\n    let effects = dxChunk.data.techniques[0].passes[0].effects;\n    // var effect = effects[10];\n    let effect = effects[0];\n\n    // let shader = dxChunk.data.shaders[effect.pixelShader];\n\n    /* effects.forEach(function (eff) {\n\t\t\tif(eff.samplerIndex.length > effect.samplerIndex.length)\n\t\t\t\teffect = eff;\n\t\t}); */\n    // var samplerIdx = effect.samplerIndex[0];\n\n    let samplerTextures = [];\n    for (let i = 0; i < effect.samplerIndex.length; i++) {\n      let samplerIdx = effect.samplerIndex[i];\n      let sampler = dxChunk.data.samplers[samplerIdx];\n\n      /// SHOULD NEVER HAPPEN, hide mesh!\n      if (!sampler) continue; // return;\n\n      let textureToken =\n        sampler && grChunk.data.texTokens[sampler.textureIndex];\n      if (!textureToken) textureToken = \"0-0\";\n      /* else\n\t\t\t\ttextureToken =textureToken.val */\n\n      /// Find the texture reffered by this sampler\n      let samplerTex = null;\n\n      material.textures.forEach(function(tex, index) {\n        /// Seems like only 1st part of token is used...\n        if (\n          !samplerTex &&\n          tex.token.split(\"-\")[0] === textureToken.split(\"-\")[0]\n        ) {\n          // console.log(\"TEX match\",tex.token, textureToken)\n          samplerTex = tex;\n        }\n      });\n\n      /// Add this sampler's texture to the collection of all textures\n      if (samplerTex) {\n        samplerTextures.push(samplerTex);\n      } else {\n        /// FALLBACK, just guess what texture we should use\n        if (sampler)\n          samplerTextures.push(material.textures[sampler.textureIndex]);\n        else if (material.textures.length > 0)\n          samplerTextures.push(material.textures[0]);\n        else return;\n      }\n    } /// END for each sampler index in effect\n\n    /// We now have all textures\n    // console.log(\"textures from sampler\", samplerTextures);\n\n    /// Fallback to using whatever texture there is.\n    if (samplerTextures.length <= 0) {\n      return;\n      // mainTex =  material.textures[0];\n    }\n\n    // console.log(\"num samplers \",samplerTextures.length);\n    samplerTextures.forEach(function(texture, idx) {\n      if (!texture) return;\n\n      /// Set texture \"URL\"\n      let texURL = texture && texture.filename;\n\n      /// Load texture from RAM or local reader:\n      finalTextures[idx] = getTexture(texURL, localReader, sharedTextures);\n      if (finalTextures[idx]) {\n        finalTextures[idx].uvIdx = texture.uvPSInputIndex;\n      }\n    });\n  } /// End if material and texture\n\n  let finalMaterial;\n\n  /// Create custom shader material if there are textures\n  if (finalTextures) {\n    // TODO: make this work!\n    if (false && finalTextures.length > 0) {\n      finalMaterial = getUVMat(\n        finalTextures,\n        material.texCoordCount,\n        grChunk.data.flags != 16460\n      );\n    } else {\n      let ft = false;\n      let nt = false;\n      material.textures.forEach(function(t) {\n        // Flag for diffuse map\n        if (!ft && t.token.split(\"-\")[0] == \"1733499172\") ft = t;\n\n        // Flag for normal map\n        if (!nt && t.token.split(\"-\")[0] == \"404146670\") nt = t;\n      });\n\n      if (!ft || ft.filename <= 0) return;\n\n      finalMaterial = new THREE.MeshPhongMaterial({\n        side: THREE.FrontSide,\n        map: getTexture(ft.filename, localReader, sharedTextures)\n      });\n      if (nt) {\n        let normalMap = getTexture(nt.filename, localReader, sharedTextures);\n        normalMap.flipY = true;\n        finalMaterial.normalMap = normalMap;\n      }\n\n      finalMaterial.textureFilename = ft.filename;\n      if (grChunk.data.flags != 16460) {\n        // console.log(\"Setting alpha flag for \",grChunk.data.flags)\n        finalMaterial.alphaTest = 0.05;\n      }\n    }\n  }\n\n  /// Fallback material is monocolored red\n  else {\n    finalMaterial = new THREE.MeshBasicMaterial({\n      side: THREE.FrontSide,\n      color: 0xff0000,\n      shading: THREE.FlatShading\n    });\n  }\n\n  finalMaterial.needsUpdate = true;\n\n  /// Set material props\n  /// disable for now in order for custom shaders not to fuck up\n\n  if (material) {\n    let alphaMask0 = 0x0001; // + 0x0100 + 0x0200;\n    let alphaMask1 = 0x0010;\n    let alphaMask2 = 0x0100 + 0x0200;\n\n    const grChunk = materialFile.getChunk(\"grmt\");\n\n    // Enable alpha test for transparent flags\n    if (\n      material.materialFlags & alphaMask0 ||\n      material.materialFlags & alphaMask1 ||\n      material.materialFlags & alphaMask2 // && solidColor != null\n    ) {\n      // return;\n      // mesh.material.transparent = true;\n      // mesh.material.opacity = 2.0;\n      // var clr = solidColor;\n      // var propAlpha = 0;\n      /// Backgroud color adds to alpha\n      // if( mesh.materialFlags == 2569  ){\n      /// This is rly just guesswork\n      /// Check material flag  2568 (as int) and compare material filename 27353 to 20041\n      /// Same flags but some have alpha and some don't\n      // if( mesh.materialFlags & alphaMask2b  ){\n      //\tpropAlpha =  (clr[3] - 128)/128;\n      //\t//propAlpha = Math.max(0,propAlpha);\n      // }\n      // mesh.material.alphaTest = Math.max(0, 0.1 );//- propAlpha*2);\n    }\n\n    /// GRCHUNK -> DATA -> FLAGS\n\n    /// HAS LIGHT - TEX - ? - EMISSIVE16460\n    ///\n\n    /// 56533 LOD FOR TOMBSTONE?\n\n    //\t16460\t\t\t0100 0000 0100 1100\t\t\t\"standard\" stuff rendering OK in SAB (no alpha test)\n\n    //\n    //\t16452(SAB)\t\t0100 0000 0100 0100\t\t\tyellow numbers in sab signs\n    //\t16448(SAB)\t\t0100 0000 0100 0000\t\t\tfaces on rocks, cloudmen, skybox portal images, holes in walls, floor plates...\n    //\t\t\t\t\t\t\t\t\t\t\t\tno lighting??\n    //\n    //\t 8268\t\t\t0010 0000 0100 1100\n    //\t 3392\t\t\t0000 1101 0100 0000\t\t\tMoto machine light bulbs\n    //\t 2380\t\t\t0000 1001 0100 1100\n    //\t 2368\t\t\t0000 1001 0100 0000\t\t\tFountain water with rings, portal border and circular \"light\"\n    //\t  332\t\t\t0000 0001 0100 1100\n    //\t  324\t\t\t0000 0001 0100 0100\t\t\tMoto face sprites\n    //\n    //\t  320(SAB)\t\t0000 0001 0100 0000\t\t\tportal textures (normal maps ish)\n    //\n    //\t   76\t\t\t0000 0000 0100 1100\t\t\tLOTS OF STUFF\n    //\t   \t\t\t\t\t\t\t\t\t\t\tTree leaves, ground, hills, some roofs, flags, street lights\n    //\t   \t\t\t\t\t\t\t\t\t\t\tsheild textures, some fences, water tops, waterfall\n    //\n    //\t   \t\t\t\t\t\t\t\t\t\t\tIN KHYLO \"everything with alpha\"\n    //\n    //\n    //\t   68\t\t\t0000 0000 0100 0100\t\t\tSome flowers (lo res?) fountain edges foam\n    //\n    //\t   64(SAB)\t\t0000 0000 0100 0000\t\t\tclouds, sun iamge\n\n    let lightMask = 8;\n\n    let knownFileFlags = [\n      16460,\n      16452,\n      16448,\n      8268,\n      3392,\n      2380,\n      2368,\n      332,\n      324,\n      320,\n      76,\n      68,\n      64\n    ];\n\n    if (knownFileFlags.indexOf(grChunk.data.flags) < 0) {\n      T3D.Logger.log(\n        T3D.Logger.TYPE_WARNING,\n        \"unknown GR flag\",\n        grChunk.data.flags\n      );\n    }\n\n    if (!(grChunk.data.flags & lightMask)) {\n      // debugger;\n      // console.log(\"no light\");\n      finalMaterial = new THREE.MeshBasicMaterial({\n        side: THREE.FrontSide,\n        map: finalMaterial.map\n      });\n    }\n\n    if (grChunk.data.flags != 16460) {\n      finalMaterial.alphaTest = 0.05;\n    }\n  } /// End if material\n\n  return finalMaterial;\n}\n\n/**\n * Load image data into a THREE.Texture from a texture file in the .dat file, using a LocalReader.\n * Any loaded tetures are added to sharedTextures, allowing for texture caching and fewer reads.\n *\n * @memberof MaterialUtils\n * @param  {Number} texURL         The fileId or baseId of the file to load image data from.\n * @param  {LocalReader} localReader    The LocalReader to load the file contents from.\n * @param  {Object} sharedTextures Value Object for keeping the texture cache\n * @return {THREE.Texture} A texture that will be populated by the file data when it is loaded.\n */\nfunction getTexture(texURL, localReader, sharedTextures) {\n  let finalTexture;\n\n  /// Read texture from shared array of loaded textures\n  /// or read it from URL and add to shared ones!\n  if (texURL && sharedTextures[texURL]) {\n    /// Just read from already loaded textures.\n    finalTexture = sharedTextures[texURL];\n  } else if (texURL) {\n    /// Load and add to shared array.\n    finalTexture = loadLocalTexture(localReader, texURL);\n\n    /// Set standard texture functionality.\n    finalTexture.wrapT = THREE.RepeatWrapping;\n    finalTexture.wrapS = THREE.RepeatWrapping;\n    finalTexture.flipY = false;\n\n    sharedTextures[texURL] = finalTexture;\n  }\n\n  return finalTexture;\n}\n\n/**\n * Load image data into a THREE.Texture from a texture file in the .dat file, using a LocalReader.\n * If you're loading multiple textures, make sure to use\n * {{#crossLink \"MaterialUtils/getTexture\"}}{{/crossLink}} that allows you to cache textures.\n * \n * @memberof MaterialUtils\n * @param {LocalReader} localReader - The LocalReader to load the file contents from.\n * @param {Number} fileId - The fileId or baseId of the file to load image data from.\n * @param {Number} mapping - What THREE mapping the returned texture will use, not implemented.\n \n * @return {THREE.Texture} A texture that will be populated by the file data when it is loaded.\n */\nfunction loadLocalTexture(localReader, fileId, mapping, defaultColor, onerror) {\n  if (defaultColor === undefined) {\n    defaultColor = Math.floor(0xffffff * Math.random());\n  }\n\n  /// Temporary texture that will be returned by the function.\n  /// Color is randomized in order to differentiate different textures during loading.\n  let texture = generateDataTexture(\n    1, // Width\n    1, // Height\n    new THREE.Color(defaultColor) // Color\n  );\n\n  // Threejs r71 is using these settings by default, r72+ changed it\n  texture.minFilter = THREE.LinearMipMapLinearFilter;\n  texture.magFilter = THREE.LinearFilter;\n  texture.generateMipmaps = true;\n  texture.flipY = true;\n\n  /// Only allow non-zero fileId, otherwise jsut return static texture\n  if (parseInt(fileId) <= 0) {\n    if (onerror) onerror();\n    return texture;\n  }\n\n  /// Load file using LocalReader.\n  localReader\n    .readFile(fileId, true, false, undefined, undefined, true)\n    .then(result => {\n      /// Require infalted data to be returned.\n      if (!result.buffer) {\n        if (onerror) onerror();\n        return;\n      }\n\n      /// Create image using returned data.\n      let image = {\n        data: new Uint8Array(result.buffer),\n        width: result.imageWidth,\n        height: result.imageHeight\n      };\n\n      /// Use RGBA for all textures for now...\n      /// TODO: don't use alpha for some formats!\n      texture.format =\n        result.dxtType == 3 || result.dxtType == 5 || true\n          ? THREE.RGBAFormat\n          : THREE.RGBFormat;\n\n      /// Update texture with the loaded image.\n      texture.image = image;\n      texture.needsUpdate = true;\n    });\n\n  /// Return texture with temporary content.\n  return texture;\n}\n\nmodule.exports = {\n  buildVS,\n  generateDataTexture,\n  buildPS,\n  getUVMat,\n  getMaterial,\n  loadLocalTexture\n};\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst base32Max = Math.pow(2, 32);\n\n/**\n * Collection Math and sorting methods\n * @namespace MathUtils\n */\n\n/**\n * Takes an integer and calculates what the 16 bit float\n * representation of the binary data used to read the integer is.\n *\n * @memberof MathUtils\n * @param  {Number} h Integer value\n * @return {Number} Float value\n */\nfunction f16(h) {\n  let s = (h & 0x8000) >> 15;\n  let e = (h & 0x7c00) >> 10;\n  let f = h & 0x03ff;\n\n  if (e === 0) {\n    return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));\n  } else if (e === 0x1f) {\n    return f ? NaN : (s ? -1 : 1) * Infinity;\n  }\n\n  return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + f / Math.pow(2, 10));\n}\n\n/**\n * Calculates the number of binary ones present in the data used to\n * generate the input integer.\n *\n * @memberof MathUtils\n * @param  {Number} bits Integer\n * @return {Number}      Number of binary ones in the data\n */\nfunction popcount(bits) {\n  const SK5 = 0x55555555;\n  const SK3 = 0x33333333;\n  const SKF0 = 0x0f0f0f0f;\n\n  bits -= (bits >> 1) & SK5;\n  bits = (bits & SK3) + ((bits >> 2) & SK3);\n  bits = (bits & SKF0) + ((bits >> 4) & SKF0);\n  bits += bits >> 8;\n\n  return (bits + (bits >> 15)) & 63;\n}\n\n/**\n * Calculates the 64 bit integer value of two 32 bit integers. Only works up to\n * the limit of the javascript Number maximum value.\n *\n * @memberof MathUtils\n * @param  {Number[]} arr     Input integers, length should be 2.\n * @return {Number}      64 bit representation of the two integers.\n */\nfunction arr32To64(arr) {\n  /// Re-read as uint64 (still little endian)\n  /// Warn: this will not work for ~50+ bit longs cus all JS numbers are 64 bit floats...\n  return base32Max * arr[1] + arr[0];\n}\n\n/**\n * Sorts an array and returns unique values only.\n *\n * @memberof MathUtils\n * @param  {Array} arr_in     Input array\n * @param  {Function} comparator A comparator function between the objects in arr_in\n * @return {Array}            Sorted and unique value.\n */\nfunction sort_unique(arr_in, comparator) {\n  let arr = Array.prototype.sort.call(arr_in, comparator);\n\n  let u = {};\n\n  const a = [];\n  for (let i = 0, l = arr.length; i < l; ++i) {\n    if (u.hasOwnProperty(arr[i])) {\n      continue;\n    }\n    a.push(arr[i]);\n    u[arr[i]] = 1;\n  }\n\n  return a;\n}\n\nmodule.exports = {\n  f16: f16,\n  popcount: popcount,\n  arr32To64: arr32To64,\n  sort_unique: sort_unique\n};\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst GW2File = require(\"../format/file/GW2File\");\nconst MaterialUtils = require(\"./MaterialUtils\");\nconst MathUtils = require(\"./MathUtils\");\n\n// TODO: Remove this local cache!!\nlet matFiles = {};\n\nconst fvfFormat = require(\"./Constants\").fvfFormat;\n\n/**\n * Returns a THREE representation of the data contained by a GW2 model file.\n * The data is read using a LocalReader reference into the GW2 .dat.\n *\n * @memberof ModelUtils\n * @param {LocalReader} localReader The LocalReader to load the file contents from.\n * @param {Object} chunk Model GEOM chunk.\n * @param {Object} modelDataChunk Model MODL chunk.\n * @param {Object} sharedTextures  Value Object for keeping the texture cache.\n * @param {boolean} showUnmaterialed If false does not render any models with missing materials.\n *\n * @return {Array} Each geometry in the model file represented by a textured THREE.Mesh object\n */\nfunction renderGeomChunk(\n  localReader,\n  chunk,\n  modelDataChunk,\n  sharedTextures,\n  showUnmaterialed\n) {\n  let rawMeshes = chunk.data.meshes;\n  let meshes = [];\n  let mats = modelDataChunk.data.permutations[0].materials;\n\n  for (let rawMesh of rawMeshes) {\n    let rawGeom = rawMesh.geometry;\n    let fvf = rawGeom.verts.mesh.fvf; // rawGeom.fvf;\n\n    let numVerts = rawGeom.verts.vertexCount; // rawGeom.vertexCount;\n\n    let rawVerts = rawGeom.verts.mesh.vertices; // rawGeom.vertices\n\n    let indices = rawGeom.indices.indices;\n\n    let geom = new THREE.BufferGeometry();\n\n    let vertDS = new DataStream(rawVerts.buffer);\n\n    // Dirty step length for now:\n    let stride = rawVerts.length / numVerts;\n\n    // Each vertex\n    // DO UV as well\n    let vertices = new Float32Array(numVerts * 3);\n    let uvs = [];\n\n    /// Calculate the distance to the first pair of UV data from the\n    /// start of the vertex entry\n    let distToNormals =\n      !!(fvf & fvfFormat.Position) * 12 +\n      !!(fvf & fvfFormat.Weights) * 4 +\n      !!(fvf & fvfFormat.Group) * 4;\n\n    let distToTangent =\n      distToNormals +\n      !!(fvf & fvfFormat.Normal) * 12 +\n      !!(fvf & fvfFormat.Color) * 4;\n\n    let distToBittangent = distToTangent + !!(fvf & fvfFormat.Tangent) * 12;\n\n    let distToTangentFrame =\n      distToBittangent + !!(fvf & fvfFormat.Bitangent) * 12;\n\n    let distToUV = distToTangentFrame + !!(fvf & fvfFormat.TangentFrame) * 12;\n\n    /// Check if the UV is 32 bit float or 16 bit float.\n    let uv32Flag = (fvf & fvfFormat.UV32Mask) >> 8;\n    let uv16Flag = (fvf & fvfFormat.UV16Mask) >> 16;\n    let isUV32 = !!uv32Flag;\n    let hasUV = !!uv16Flag || !!uv32Flag;\n\n    /// Popcount (count the number of binary 1's) in the UV flag\n    /// to get the number of UV pairs used in this vertex format.\n    let masked = isUV32 ? uv32Flag : uv16Flag;\n    let numUV = MathUtils.popcount(masked);\n\n    numUV = Math.min(numUV, 1.0);\n\n    /// Create typed UV arrays\n    if (hasUV) {\n      for (let i = 0; i < numUV; i++) {\n        uvs[i] = new Float32Array(numVerts * 2);\n      }\n    }\n\n    // if (!!(fvf & fvfFormat.Normal)) {\n    // \tconsole.log(\"HAS Normal\");\n    // }\n    // if (!!(fvf & fvfFormat.Tangent)) {\n    // \tconsole.log(\"HAS Tangent\");\n    // }\n    // if (!!(fvf & fvfFormat.Bitangent)) {\n    // \tconsole.log(\"HAS Bitangent\");\n    // }\n    // if (!!(fvf & fvfFormat.TangentFrame)) {\n    // \tconsole.log(\"HAS TangentFrame\");\n    // }\n\n    /// Read data from each vertex data entry\n    for (let i = 0; i < numVerts; i++) {\n      /// Go to vertex memory position\n      vertDS.seek(i * stride);\n\n      /// Read position data\n      /// (we just hope all meshes has 32 bit position...)\n      let x = vertDS.readFloat32();\n      let z = vertDS.readFloat32();\n      let y = vertDS.readFloat32();\n\n      /// Write position data, transformed to Tyria3D coordinate system.\n      vertices[i * 3 + 0] = x; // - c.x;\n      vertices[i * 3 + 1] = -y; // + c.y;\n      vertices[i * 3 + 2] = -z; // + c.z;\n\n      /// Read data at UV position\n      if (hasUV) {\n        for (let uvIdx = 0; uvIdx < numUV; uvIdx++) {\n          vertDS.seek(i * stride + distToUV + uvIdx * (isUV32 ? 8 : 4));\n\n          /// Add one UV pair:\n\n          let u, v;\n          if (isUV32) {\n            u = vertDS.readUint32();\n            v = vertDS.readUint32();\n          } else {\n            u = MathUtils.f16(vertDS.readUint16());\n            v = MathUtils.f16(vertDS.readUint16());\n          }\n\n          /// Push to correct UV array\n          uvs[uvIdx][i * 2 + 0] = u;\n          uvs[uvIdx][i * 2 + 1] = v;\n        }\n      } /// End if has UV\n    } /// End each vertex\n\n    /// Each face descripbed in indices\n    let faces = new Uint16Array(indices.length);\n    for (let i = 0; i < indices.length; i += 3) {\n      // This is ONE face\n      faces[i + 0] = indices[i + 2];\n      faces[i + 1] = indices[i + 1];\n      faces[i + 2] = indices[i + 0];\n    } // End each index aka \"face\"\n\n    /// Add position, index and uv props to buffered geometry\n    geom.addAttribute(\"position\", new THREE.BufferAttribute(vertices, 3));\n    // geom.addAttribute( 'index', new THREE.BufferAttribute( faces, 1) );\n    geom.setIndex(new THREE.BufferAttribute(faces, 1));\n\n    /// Calculate normals\n    /// Not all models have normals included, so we ask THREE to do the math at runtime.\n    geom.computeVertexNormals();\n\n    if (hasUV) {\n      for (let uvIdx = 0; uvIdx < numUV; uvIdx++) {\n        /// Names are \"uv\", \"uv2\", \"uv3\", ... , \"uvN\"\n        let uvName = \"uv\" + (uvIdx > 0 ? uvIdx + 1 : \"\");\n\n        /// Set \"custom\" attribute uvN\n        geom.addAttribute(uvName, new THREE.BufferAttribute(uvs[uvIdx], 2));\n\n        /// Flag for update\n        geom.attributes[uvName].needsUpdate = true;\n      }\n\n      /// Not needed anymore?\n      geom.uvsNeedUpdate = true;\n    }\n\n    /// Tell geometry to update its UVs and buffers\n    geom.buffersNeedUpdate = true;\n\n    /// DONE READING VERTEX DATA\n\n    /// Get material used for this mesh\n    let matIdx = rawMesh.materialIndex;\n    let mat = mats[matIdx];\n    let materialFile = null;\n\n    if (mat && matFiles[mat.filename]) {\n      materialFile = matFiles[mat.filename];\n    }\n\n    let finalMaterial = MaterialUtils.getMaterial(\n      mat,\n      materialFile,\n      localReader,\n      sharedTextures\n    );\n\n    /// IF we could not find a material abort OR use a wireframe placeholder.\n    if (!finalMaterial) {\n      if (showUnmaterialed) {\n        finalMaterial = new THREE.MeshLambertMaterial({\n          color: 0x5bb1e8,\n          wireframe: false,\n          side: THREE.DoubleSide\n        });\n      } else {\n        return [];\n      }\n    }\n\n    /// Create the final mesh from the BufferedGeometry and MeshBasicMaterial\n    let finalMesh = new THREE.Mesh(geom, finalMaterial);\n\n    /// Set material info on the returned mesh\n    if (mat) {\n      finalMesh.materialFlags = mat.materialFlags;\n      finalMesh.materialFilename = mat.filename;\n    }\n\n    finalMesh.materialName = rawMesh.materialName;\n\n    /// Use materialFilename, materialName, and material.textureFilename in order to build export\n\n    /// Set lod info on the returned mesh\n    finalMesh.numLods = rawMesh.geometry.lods.length;\n    finalMesh.lodOverride = modelDataChunk.data.lodOverride;\n\n    /// Set flag and UV info on the returned mehs\n    finalMesh.flags = rawMesh.flags;\n    finalMesh.numUV = numUV;\n\n    /// Add mesh to returned Array\n    meshes.push(finalMesh);\n  } /// End rawMeshes forEach\n\n  return meshes;\n}\n\n/**\n * Loads mesh array from Model file and sends as argument to callback.\n * \n * @memberof ModelUtils\n * @async\n * @param  {Number} filename Name of the model file to load data from.\n * @param  {Array} solidColor RGBA array of 4 integers\n * @param {LocalReader} localReader The LocalReader to load the file contents from.\n * @param {Object} sharedTextures  Value Object for keeping the texture cache.\n * @param {boolean} showUnmaterialed If false does not render any models with missing materials.\n \n * @param  {Function} callback Fired once all meshes have been loaded.\n * two arguments are passed to the callback function.\n * \n * The first argument is an Array with each textured THREE.Mesh objects.\n * \n * The second argument is the bounding spehere of this model file.\n * \n */\n\nfunction loadMeshFromModelFile(\n  filename,\n  solidColor,\n  localReader,\n  sharedTextures,\n  showUnmaterialed,\n  hideLOD,\n  callback\n) {\n  // Short handles prop attributes\n  let finalMeshes = [];\n\n  /// Load file\n  localReader\n    .readFile(filename, false, false, undefined, undefined, true)\n    .then(result => {\n      let inflatedData = result.buffer;\n\n      try {\n        if (!inflatedData) {\n          throw new Error(\"Could not find MFT entry for \" + filename);\n        }\n\n        let ds = new DataStream(inflatedData);\n\n        let modelFile = new GW2File(ds, 0);\n\n        // MODL for materials -> textures\n        let modelDataChunk = modelFile.getChunk(\"modl\");\n\n        // GEOM for geometry\n        let geometryDataChunk = modelFile.getChunk(\"geom\");\n\n        /// Hacky fix for not being able to adjust for position\n        let boundingSphere = modelDataChunk.data.boundingSphere;\n        let bsc = boundingSphere.center;\n        boundingSphere.radius += Math.sqrt(\n          bsc[0] * bsc[0] + Math.sqrt(bsc[1] * bsc[1] + bsc[2] * bsc[2])\n        );\n\n        /// Load all material files\n        let allMats = modelDataChunk.data.permutations[0].materials;\n\n        const loadMaterialIndex = function(mIdx, matCallback) {\n          if (mIdx >= allMats.length) {\n            matCallback();\n            return;\n          }\n\n          let mat = allMats[mIdx];\n\n          /// Skip if file is loaded\n          if (matFiles[mat.filename]) {\n            loadMaterialIndex(mIdx + 1, matCallback);\n            return;\n          }\n\n          localReader\n            .readFile(mat.filename, false, false, undefined, undefined, true)\n            .then(result => {\n              let inflatedData = result.buffer;\n              if (inflatedData) {\n                let ds = new DataStream(inflatedData);\n                let materialFile = new GW2File(ds, 0);\n                matFiles[mat.filename] = materialFile;\n              }\n\n              loadMaterialIndex(mIdx + 1, matCallback);\n            });\n        };\n\n        loadMaterialIndex(0, function() {\n          /// Create meshes\n          let meshes = renderGeomChunk(\n            localReader,\n            geometryDataChunk,\n            modelDataChunk,\n            sharedTextures,\n            showUnmaterialed\n          );\n\n          // Build mesh group\n          for (let mesh of meshes) {\n            let texMask = 0x8 + 0x0800;\n\n            // Must have texture\n            if (!showUnmaterialed && !(mesh.materialFlags & texMask)) {\n              return;\n            }\n\n            // Hide LOD meshes if hideLOD is true\n            if (hideLOD && (mesh.flags === 4 || mesh.flags === 1)) {\n              continue;\n            }\n\n            // Add to final colection\n            finalMeshes.push(mesh);\n          } /// END FOR EACH meshes\n\n          callback(finalMeshes, boundingSphere);\n        }); /// END LOAD MATERIALS CALLBACK\n      } catch (e) {\n        console.warn(\"Failed rendering model \" + filename, e);\n        let mesh = new THREE.Mesh(\n          new THREE.BoxGeometry(200, 2000, 200),\n          new THREE.MeshNormalMaterial()\n        );\n        mesh.flags = 4;\n        mesh.materialFlags = 2056;\n        mesh.lodOverride = [1000000, 1000000];\n        finalMeshes.push(mesh);\n\n        /// Send the final meshes to callback function\n        callback(finalMeshes);\n      }\n    }); /// END FILE LOADED CALLBACK FUNCTION\n}\n\n/**\n * Gets a mesh array from Model file and sends as argument to callback. Uses a cache of meshes in order\n * to never read the same model file twice.\n *\n * @memberof ModelUtils\n * @async\n * @param  {Number} filename The fileId or baseId of the Model file to load\n * @param  {Array} color RGBA array of 4 integers\n * @param  {LocalReader} localReader The LocalReader object used to read data from the GW2 .dat file.\n * @param {Object} sharedMeshes  Value Object for keeping the texture cache.\n * @param {Object} sharedTextures  Value Object for keeping the texture cache.\n * @param {boolean} showUnmaterialed If false does not render any models with missing materials.\n * @param  {Function} callback Fired once all meshes have been loaded.\n * three arguments are passed to the callback function.\n *\n * The first argument is an Array with each textured THREE.Mesh objects.\n *\n * The second argument is a boolean, true indicates that these meshes were not\n * loaded from the dat file, but retrieved from the run time cache.\n *\n * The third argument is the bounding spehere of this model file.\n */\nfunction getMeshesForFilename(\n  filename,\n  color,\n  localReader,\n  sharedMeshes,\n  sharedTextures,\n  showUnmaterialed,\n  hideLOD,\n  callback\n) {\n  /// If this file has already been loaded, just return a reference to the meshes.\n  /// isCached will be set to true to inform the caller the meshes will probably\n  /// have to be cloned in some way.\n  if (sharedMeshes[filename]) {\n    callback(\n      sharedMeshes[filename].meshes,\n      true,\n      sharedMeshes[filename].boundingSphere\n    );\n  }\n\n  /// If this file has never been loaded, load it using loadMeshFromModelFile\n  /// the resulting mesh array will be cached within this model's scope.\n  else {\n    loadMeshFromModelFile(\n      filename,\n      color,\n      localReader,\n      sharedTextures,\n      showUnmaterialed,\n      hideLOD,\n      function(meshes, boundingSphere) {\n        /// Cache result if any.\n        if (meshes) {\n          sharedMeshes[filename] = {\n            meshes: meshes,\n            boundingSphere: boundingSphere\n          };\n        }\n\n        /// Allways fire callback.\n        callback(meshes, false, boundingSphere);\n      }\n    );\n  }\n}\n\n/**\n * WIP, Tries to find all fileIds refered by a model file.\n *\n * @memberof ModelUtils\n * @async\n * @param  {Number}   filename    Model file Id\n * @param  {LocalReader}   localReader LocalReader instance to read from\n * @param  {Function} callback   First argument is list of used file IDs\n */\nfunction getFilesUsedByModel(filename, localReader, callback) {\n  let fileIds = [filename];\n\n  /// Load model file\n  localReader\n    .readFile(filename, false, false, undefined, undefined, true)\n    .then(result => {\n      let inflatedData = result.buffer;\n\n      try {\n        if (!inflatedData) {\n          throw new Error(\"Could not find MFT entry for \" + filename);\n        }\n\n        let ds = new DataStream(inflatedData);\n        let modelFile = new GW2File(ds, 0);\n\n        // MODL for materials -> textures\n        let modelDataChunk = modelFile.getChunk(\"modl\");\n\n        /// Get materials used by model\n        let mats = modelDataChunk.data.permutations[0].materials;\n\n        /// Add each material file AND referenced TEXTURES\n        for (let mat of mats) {\n          /// Add material file id\n          let matFileName = mat.filename;\n          fileIds.push(matFileName);\n\n          /// Add each texture file id\n          mat.textures.forEach(function(tex) {\n            fileIds.push(tex.filename);\n          });\n        }\n      } catch (e) {\n        console.warn(\"Could not export any data\", e);\n      }\n\n      callback(fileIds);\n    });\n}\n\nmodule.exports = {\n  renderGeomChunk: renderGeomChunk,\n  getMeshesForFilename: getMeshesForFilename,\n  getFilesUsedByModel: getFilesUsedByModel\n};\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * Collection of methods used for generating THREE meshes from Guild Wars 2 data formats.\n * @namespace RenderUtils\n */\n\n/**\n * Creates a mesh representing a single plane.\n *\n * @memberof RenderUtils\n * @param  {Object} rect     An object with x1,x2,y1 and y2 properties.\n * @param  {Number} yPos     Vertical position of the rectangle.\n * @param  {THREE.Material} material \tMesh material to apply.\n * @param  {Number} dy       Mesh height.\n * @return {THREE.Mesh}      The generated mesh.\n */\nfunction renderRect(rect, yPos, material, dy) {\n  let dx = rect.x1 - rect.x2;\n  let dz = rect.y1 - rect.y2;\n  if (!dy) dy = 1;\n\n  let cx = (rect.x1 + rect.x2) / 2;\n  let cz = (rect.y1 + rect.y2) / 2;\n  let cy = yPos;\n\n  let geometry = new THREE.BoxGeometry(dx, dy, dz);\n\n  material =\n    material ||\n    new THREE.MeshBasicMaterial({\n      color: 0xff0000,\n      wireframe: true\n    });\n  let plane = new THREE.Mesh(geometry, material);\n  plane.overdraw = true;\n\n  plane.position.x = cx;\n  plane.position.y = cy;\n  plane.position.z = cz;\n\n  return plane;\n}\n\nmodule.exports = {\n  renderRect: renderRect\n};\n","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nmodule.exports = {\n  /// TODO: port fog from in-engine\n\n  getFragmentShader: function() {\n    return [\n      \"uniform vec2 uvScale;\",\n      \"uniform vec2 offset;\",\n      \"uniform sampler2D texturePicker;\",\n      \"uniform sampler2D texturePicker2;\",\n      \"uniform sampler2D texture1;\",\n      \"uniform sampler2D texture2;\",\n      \"uniform sampler2D texture3;\",\n      \"uniform sampler2D texture4;\",\n\n      THREE.ShaderChunk[\"logdepthbuf_pars_fragment\"],\n\n      \"varying vec2 vUv;\",\n      \"varying vec3 vecNormal;\",\n\n      \"vec3 blend(\",\n      \"vec4 texture1, float a1, vec4 texture2, float a2,\",\n      \"vec4 texture3, float a3, vec4 texture4, float a4)\",\n      \"{\",\n      \"float depth = 2.0;\",\n      \"float alphaMult = 1.0;\",\n      \"float alphaAdd  = 0.0;\",\n      \"a1 *= 4.0;\",\n      \"a2 *= 4.0;\",\n      \"a3 *= 4.0;\",\n      \"a4 *= 4.0;\",\n      \"a1 =  a1+(1.5+texture1.a);\",\n      \"a2 =  a2+(1.5+texture2.a);\",\n      \"a3 =  a3+(1.5+texture3.a);\",\n      \"a4 =  a4+(1.5+texture4.a);\",\n      \"float ma = max(a1,a2);\",\n      \"ma = max(ma,a3);\",\n      \"ma = max(ma,a4);\",\n      \"ma -= depth;\",\n      \"float b1 = max(a1 - ma, 0.0);\",\n      \"float b2 = max(a2 - ma, 0.0);\",\n      \"float b3 = max(a3 - ma, 0.0);\",\n      \"float b4 = max(a4 - ma, 0.0);\",\n      \"return (\",\n      \"texture1.rgb * b1 + texture2.rgb * b2 +\",\n      \"texture3.rgb * b3 + texture4.rgb * b4 \",\n      \") / (b1 + b2 + b3 + b4);\",\n      \"}\",\n\n      \"void main( void ) {\",\n      \"vec2 position = vUv*uvScale;\",\n      \"float edge = 1.0/1024.0;\",\n      \"vec2 compPos = edge + (vUv*0.25 + offset) * (1.0-edge*2.0);\",\n      \"vec4 tp1 = texture2D( texturePicker, compPos);\",\n      \"vec4 tp2 = texture2D( texturePicker2, compPos);\",\n      \"vec4 composite = tp1;\",\n      \"vec4 t1 = texture2D( texture1, position );\",\n      \"vec4 t2 = texture2D( texture2, position );\",\n      \"vec4 t3 = texture2D( texture3, position );\",\n      \"vec4 t4 = texture2D( texture4, position );\",\n      \"vec3 color = blend(\",\n      \"t1, tp1.a,\",\n      \"t2, tp1.b,\",\n      \"t3, tp1.g,\",\n      \"t4, tp1.r\",\n      \");\",\n      \"color *= 0.5+tp2.r;\",\n      \"gl_FragColor = vec4(color,1.0);\",\n      THREE.ShaderChunk[\"logdepthbuf_fragment\"],\n      \"}\"\n    ].join(\"\\n\");\n  },\n  getVertexShader: function() {\n    return [\n      \"varying vec2 vUv;\",\n      \"varying vec3 vecNormal;\",\n      THREE.ShaderChunk[\"logdepthbuf_pars_vertex\"],\n      \"void main()\",\n      \"{\",\n\n      \"vUv =  uv;\",\n      \"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n      \"vecNormal = (modelMatrix * vec4(normal, 0.0)).xyz;\",\n      \"gl_Position = projectionMatrix * mvPosition;\",\n      THREE.ShaderChunk[\"logdepthbuf_vertex\"],\n      \"}\"\n    ].join(\"\\n\");\n  }\n};\n"]}