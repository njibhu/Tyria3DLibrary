{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/LocalReader/ArchiveParser.js","src/LocalReader/DataReader.js","src/LocalReader/FileTypes.js","src/LocalReader/LocalReader.js","src/LocalReader/PersistantStore.js","src/Logger.js","src/MapFileList.js","src/T3DLib.js","src/dataRenderer/DataRenderer.js","src/dataRenderer/EnvironmentRenderer.js","src/dataRenderer/HavokRenderer.js","src/dataRenderer/PropertiesRenderer.js","src/dataRenderer/SingleModelRenderer.js","src/dataRenderer/StringRenderer.js","src/dataRenderer/TerrainRenderer.js","src/dataRenderer/ZoneRenderer.js","src/format/file/GW2Chunk.js","src/format/file/GW2File.js","src/util/Constants.js","src/util/MapEnvUtils.js","src/util/MapTerrainUtils.js","src/util/MaterialUtils.js","src/util/MathUtils.js","src/util/ModelUtils.js","src/util/ParserUtils.js","src/util/RenderUtils.js","src/util/TerrainShader.js"],"names":["f","exports","module","define","amd","window","global","self","this","T3D","r","e","n","t","o","i","c","require","u","a","Error","code","p","call","length","1","MathUtils","parseANDatHeader","ds","header","version","readUint8","magic","readString","headerSize","readUint32","seek","position","chunkSize","crc","mftOffset","arr32To64","mftSize","flags","Logger","log","TYPE_DEBUG","TYPE_ERROR","parseMFTTable","nbOfEntries","fullTable","item","readUint16","table","mftIndexOffset","offset","mftIndexSize","size","parseMFTIndex","indexTable","id","mftIndex","getFilePart","file","Promise","resolve","reject","reader","FileReader","onerror","onload","fileEvent","buffer","target","result","DataStream","endianness","LITTLE_ENDIAN","len","readAsArrayBuffer","slice","readArchive","async","archiveHeader","mftData","metaTable","DataReader","[object Object]","settings","_settings","_workerPool","_workerLoad","_handleCounter","_workQueue","_handleRegister","workersNb","_startWorker","workerPath","mftId","isImage","capLength","arrayBuffer","byteLength","TYPE_WARNING","push","freeWorkerIndex","_getFreeWorkerIndex","_workNext","workerId","workData","shift","handle","_getNewHandle","postMessage","path","_id","selfWorkerId","worker","Worker","onmessage","message_event","answer","data","handleID","split","handleData","dxtType","imageWidth","imageHeight","error","terminate","indexOf","GW2File","FileTypes","getFileType","first4","readCString","type","ArchiveParser","PersistantStore","MapFileList","LocalReader","_dataReader","_persistantStore","_file","undefined","_indexTable","_fileMetaTable","noIndexedDB","baseId","raw","fileLength","extractLength","isBaseId","getFileIndex","meta","getFileMeta","compressed","inflate","then","catch","oldFileList","persistantId","persistantList","lastListing","getLastListing","name","array","complete","key","iterateList","Object","keys","map","Number","index","taskArray","task","persistantNeedsUpdate","_needsScan","scan","taskId","race","readFileType","scanResult","fileType","change","Math","floor","TYPE_PROGRESS","putListing","res","all","_persistantData","getFileList","mapArray","reversedIndex","getReverseIndex","maps","filter","found","category","fileMap","find","fileName","toString","mapEntry","typeList","reverseBaseIdList","fileList","baseIds","baseIdList","reduce","reversed","searchAll","callback","restoreOuput","returnArray","elt","findIndex","sort","j","readFileList","getMapList","returnObj","fileEntry","readFile","persistantData","metaData","_fileTypeCache","fileBuffer","min","DB_VERSION","_dbConnection","_getConnection","request","indexedDB","open","onblocked","event","onupgradeneeded","db","currentVersion","oldVersion","createObjectStore","autoIncrement","currentTarget","transaction","objectStore","createIndex","unique","onsuccess","isReady","listing","isComplete","store","put","filename","openCursor","IDBKeyRange","only","cursor","value","primaryKey","TYPE_MESSAGE","logFunctions","Array","arguments","argArr","argsToArr","unshift","severity","max","apply","args","console","warn","debug","t3dtoolsWorker","concurrentTasks","navigator","hardwareConcurrency","numErrors","GW2Chunk","DataRenderer","EnvironmentRenderer","HavokRenderer","PropertiesRenderer","SingleModelRenderer","TerrainRenderer","ZoneRenderer","StringRenderer","MaterialUtils","ParserUtils","RenderUtils","getLocalReader","lrInstance","openArchive","getFileListAsync","localReader","getMapListAsync","renderMapContentsAsync","renderers","logger","context","parseInt","mapFile","runAllRenderers","runRenderer","renderClass","assign","bind","cb","renderAsync","getContextValue","clazz","propName","defaultValue","output","hasWebGL","return_context","WebGLRenderingContext","canvas","document","createElement","names","getContext","getParameter","gl","THREE","constructor","otherClass","inflatedData","getOutput","fileId","rawData","uarr","Uint8Array","textDecoder","TextDecoder","rawString","decode","image","width","height","MapEnvUtils","super","environmentChunkData","getChunk","parameterChunkData","hazeColor","getHazeColor","hazeColorAsInt","lightData","parseLights","hasLight","lights","skyElements","parseSkybox","lastP","seed","meshes","renderModels","models","title","mat","visible","MeshNormalMaterial","side","DoubleSide","MeshBasicMaterial","parseAllModels","getCollisionsForAnimation","animation","collisions","ret","collisionIndices","collision","round","animationFromGeomIndex","geometryIndex","geometries","animations","havokChunkData","renderMesh","setTimeout","propGeomIndex","l","model","pos","translate","rot","rotate","scale","mesh","parseHavokMesh","set","rotation","order","seedRandom","x","sin","clone","geom","Geometry","vertices","v","Vector3","indices","f1","f2","f3","faces","Face3","computeFaceNormals","Mesh","boundingBox","boundsMax","propModels","zoneModels","obsModels","forEach","mdl","renderZoneModelsCB","ModelUtils","propertiesChunkData","props","propArray","animProps","propAnimArray","instanceProps","propInstanceArray","metaProps","propMetaArray","concat","meshCache","textureCache","lastPct","renderIndex","idx","pct","pctStr","prop","addMeshToLOD","groups","lod","needsClone","lodDist","lod2","lodOverride","geometry","material","updateMatrix","matrixAutoUpdate","add","group","Group","addLevel","getMeshesForFilename","color","isCached","boundingSphere","meshArray","LOD","maxDist","boundingSphereRadius","radius","transforms","transform","update","addMeshesToScene","renderCallback","fileIds","getIdsForProp","Utils","getFilesUsedByModel","propFileIds","strings","end","entryHeaderDef","entryIndex","entry","readStruct","decryptionOffset","bitsPerSymbol","readUCS2String","recid","language","MapTerrainUtils","pagedImageId","materials","pagedImage","loadPagedImageCallback","anisotropy","terrainResult","terrainTiles","water","bounds","mapRect","getTerrainFilesId","renderZone","zone","zoneDefs","renderZoneCallback","zoneDef","zd","token","defToken","modelGroups","getModelGroups","groupKeys","stepModels","meshGroups","instanceIdx","meshIdx","materialFlags","move","y","z","mg","readVerts","getAttribute","verts","Float32Array","readIndices","getIndex","Uint32Array","readUVs","uvs","readNormals","normals","writeVerts","stride","writeIndices","strideIndices","writeUvs","uvStride","writeNormals","normalStride","meshGroup","mergedGeom","BufferGeometry","addAttribute","BufferAttribute","setIndex","buffersNeedUpdate","zPos","mapX","mapY","zoneRect","vertRect","encodeData","zdx","linearPos","flag","zoneDefLayer","layer","layerDefArray","modelX","modelY","modelZ","raycaster","Raycaster","chunk","intersections","intersectObject","distance","modelArray","modelFilename","rotRangeX","zOffsets","layerFlags","rotRangeY","rotRangeZ","scaleRange","fadeRange","zoneChunkData","rect","zones","zoneArray","zoneDefArray","stepZone","HEAD_STRUCT","DUPLICATE_SETTINGS","PACKTOCHUNK","pack","root","addr","setting","regex","RegExp","chunkDef","formats","defsIdx","defs","versions","getRootName","pop","match","definition","__root","genDuplicateSettings","headerLength","NaN","loadHead","useNthIndex","fileTypes","defsFound","chunkVersion","def","getDefinition","chunkDataSize","Chunk","noChunks","chunks","readHead","readChunks","ch","loadData","next","toLowerCase","fvfFormat","Position","Weights","Normal","Color","Tangent","Bitangent","TangentFrame","UV32Mask","UV16Mask","Unknown1","Unknown2","Unknown3","Unknown4","PositionCompressed","Unknown5","getMat","tex","BackSide","fog","depthWrite","loadTextureWithFallback","targetMatIndices","materialArray","fallbackFilename","writeMat","loadFallback","TextureLoader","load","loadLocalTexture","hazes","dataGlobal","haze","farColor","ambientLight","lightOutput","lighting","backlightIntensity","backlightColor","light","sumDirLightIntensity","dirLightData","directionalLight","DirectionalLight","getHex","intensity","direction","normalize","directions","lightDir","AmbientLight","ambientTotal","g","b","skyboxFallbackArray","skyModeTex","texPathNE","texPathSW","texPathT","mapW","abs","x1","x2","mapD","y1","y2","skyGeometry","BoxGeometry","boxSize","faceVertexUvs","vecs","face","vec2","uvsNeedUpdate","skyBox","translateY","TerrainShader","inflatedBuffer","envOutput","pimgDS","pimgTableDataChunk","pimgData","terrainData","parameterData","maxAnisotropy","numChunksD_1","sqrt","dims","chunkArray","numChunksD_2","parseNumChunks","xChunks","yChunks","allMaterials","allTextures","texFileArray","dx","dy","cdx","cdy","allMats","customMaterial","MeshLambertMaterial","flatShading","chunkTextures","strippedPages","page","coord","solidColor","matName","chunkTex","wrapS","RepeatWrapping","wrapT","renderChunk","cx","cy","chunkIndex","pageX","pageY","chunkTextureIndices","hiResMaterial","texIndexArray","pageOffetX","materialFile","pageOffetY","fileNames","gi","textureFileName","pageTexName","pageTexName2","near","far","uniforms","UniformsUtils","merge","UniformsLib","uvScale","Vector2","texturePicker","texturePicker2","texture1","texture2","texture3","texture4","ShaderMaterial","fragmentShader","getFragmentShader","vertexShader","getVertexShader","chunkGeo","PlaneBufferGeometry","chunkW","cn","heightMapArray","mS","Matrix4","identity","elements","applyMatrix","SceneUtils","createMultiMaterialObject","PI","globalOffsetX","chunkOffsetX","globalOffsetY","chunkOffsetY","px","py","updateMatrixWorld","wireframe","opacity","transparent","renderRect","terrainChunk","texture","buildVS","numUv","vdefs","adefs","reads","generateDataTexture","DataTexture","RGBAFormat","buildPS","textures","alphaTest","lightMap","t1uv","uvIdx","discard","writeColor","varyings","getUVMat","numUV","attributes","vs","FrontSide","getTexture","texURL","sharedTextures","finalTexture","flipY","mapping","defaultColor","random","minFilter","LinearMipMapLinearFilter","magFilter","LinearFilter","generateMipmaps","format","needsUpdate","getMaterial","finalMaterial","dxChunk","grChunk","finalTextures","effect","techniques","passes","effects","samplerTextures","shaders","pixelShader","samplerIndex","samplerIdx","sampler","samplers","textureToken","texTokens","textureIndex","samplerTex","uvPSInputIndex","ft","nt","MeshPhongMaterial","normalMap","textureFilename","shading","FlatShading","base32Max","pow","f16","h","s","Infinity","popcount","bits","arr","sort_unique","arr_in","comparator","prototype","hasOwnProperty","matFiles","renderGeomChunk","modelDataChunk","showUnmaterialed","rawMeshes","mats","permutations","rawMesh","rawGeom","fvf","numVerts","vertexCount","rawVerts","vertDS","distToUV","uv32Flag","uv16Flag","isUV32","hasUV","masked","readFloat32","Uint16Array","computeVertexNormals","uvName","materialIndex","finalMesh","materialFilename","materialName","numLods","lods","sharedMeshes","hideLOD","finalMeshes","modelFile","geometryDataChunk","bsc","center","loadMaterialIndex","mIdx","matCallback","loadMeshFromModelFile","matFileName","getArrayReader","structDef","maxCount","struct","arr_len","arr_ptr","readType","getRefArrayReader","ret_arr","orgPos","offsets","readInt32Array","pointer","getQWordReader","getStringReader","ptr","getString16Reader","stringOffset","num","String","fromCharCode","getPointerReader","getFileNameReader","fileRef","m_highPart","m_lowPart","yPos","dz","cz","plane","overdraw","ShaderChunk","join"],"mappings":"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","file":"T3D-latest.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst MathUtils = require('../util/MathUtils');\n\n/**\n * @file The ArchiveParser module is a set of helper tools to correctly read the Archive.\n * @namespace ArchiveParser\n */\n\n/**\n *    All in one function to read a GW2.dat file and parse all the needed informations to work with it\n *\n * @memberof ArchiveParser\n * @param {File} file\n * @returns {Promise<{archiveHeader: ArchiveHeader, metaTable: MetaTable, indexTable: IndexTable}>}\n */\nasync function readArchive(file) {\n    let archiveHeader = parseANDatHeader((await getFilePart(file, 0, 40)).ds);\n    let mftData = parseMFTTable((await getFilePart(file, archiveHeader.mftOffset, archiveHeader.mftSize)).ds);\n    let {\n        ds,\n        len\n    } = await getFilePart(file, mftData.mftIndexOffset, mftData.mftIndexSize);\n    let indexTable = parseMFTIndex(ds, len);\n\n    return {\n        archiveHeader: archiveHeader,\n        metaTable: mftData.table,\n        indexTable: indexTable\n    };\n}\n\n\n/**\n * The header of the archive.\n * @typedef {Object} ArchiveHeader\n * @property {number} version\n * @property {number} magic\n * @property {number} headerSize\n * @property {number} chunkSize\n * @property {number} crc\n * @property {number} mftOffset\n * @property {number} mftSize\n * @property {number} flags\n */\n\n/**\n *   Parse the main information about the archive like format version, positions of information tables, crc etc...\n * \n * @memberof ArchiveParser\n * @param {DataStream} ds\n * @returns {ArchiveIndex} Returns undefined if the header couldn't be parsed\n */\nfunction parseANDatHeader(ds) {\n    var header = {};\n\n    // Header parsing\n    header.version = ds.readUint8();\n    header.magic = ds.readString(3);\n    header.headerSize = ds.readUint32();\n    ds.seek(ds.position + 4); //Skip uint32\n    header.chunkSize = ds.readUint32();\n    header.crc = ds.readUint32();\n    ds.seek(ds.position + 4); //Skip uint32\n    header.mftOffset = MathUtils.arr32To64([ds.readUint32(), ds.readUint32()]);\n    header.mftSize = ds.readUint32();\n    header.flags = ds.readUint32();\n    // End header parsing\n\n    //Check MAGIC\n    if (header.magic != \"AN\\u001A\") {\n        T3D.Logger.log(\n            T3D.Logger.TYPE_ERROR, \"ANDat header is not valid\", header.magic);\n        return undefined;\n    }\n\n    T3D.Logger.log(\n        T3D.Logger.TYPE_DEBUG,\n        \"Loaded Main .dat header\"\n    );\n\n    return header;\n}\n\n/**\n * The array containing all the meta information concerning the contained files\n * @typedef {Array<{offset: number, size: number, compressed: number, crc: number}>} MetaTable\n */\n\n/**\n *   Parse the main information table that contains the offset, size, compression flags and crc\n * \n * @memberof ArchiveParser\n * @param {Datastream}  ds\n * @returns {{header: {magic: String, nbOfEntries: number}, table: MetaTable, mftIndexOffset: number, mftIndexSize: number}|undefined}\n *   Returns undefined if it couldn't parse the table\n */\nfunction parseMFTTable(ds) {\n    // Parse the table header\n    var header = {};\n    header.magic = ds.readString(4);\n    ds.seek(ds.position + 8) //Skip uint64\n    header.nbOfEntries = ds.readUint32();\n    ds.seek(ds.position + 4 + 4); //Skip uint32 * 2\n\n    //check MAGIC\n    if (header.magic != \"Mft\\u001A\") {\n        T3D.Logger.log(\n            T3D.Logger.TYPE_ERROR, \"MFTTable header is not valid\", header.magic);\n        return undefined;\n    }\n\n    //Where we put all the parsed data\n    //We don't pre-alloc anymore since not having the data aligned together procs too many\n    //cache misses during a fullscan\n    let fullTable = [];\n\n    // Go through the table\n    for (let i = 1; i < header.nbOfEntries; i++) {\n        let item = {};\n        item['offset'] = MathUtils.arr32To64([ds.readUint32(), ds.readUint32()]);\n        item['size'] = ds.readUint32();\n        item['compressed'] = ds.readUint16();\n        ds.seek(ds.position + 4 + 2); //Skip uint16 + uint32\n        item['crc'] = ds.readUint32();\n        fullTable[i] = item;\n    }\n\n    T3D.Logger.log(\n        T3D.Logger.TYPE_DEBUG,\n        \"Loaded MFTTable\"\n    );\n\n    return {\n        header: header,\n        table: fullTable,\n        //Register the MFTIndex table position and size\n        mftIndexOffset: fullTable[2].offset,\n        mftIndexSize: fullTable[2].size\n    };\n}\n\n\n/**\n * The array linking all the file indexes to their respective files\n * @typedef {Array<number>} IndexTable\n */\n\n/**\n *   This function used to be much more complex with the use of\n *   a \"fileId\" which in the end was just the equivalent of \n *   MFTbaseIds[mftId].sort().reverse()[0] (aka the bigger baseId found)\n * \n * @memberof ArchiveParser\n * @param {DataStream} ds \n * @param {number} size\n * @returns {IndexTable}\n */\nfunction parseMFTIndex(ds, size) {\n    let length = size / 8;\n\n    let indexTable = [];\n\n    for (let i = 0; i < length; i++) {\n        //Parse table\n        let id = ds.readUint32();\n        let mftIndex = ds.readUint32();\n        //Store the values\n        indexTable[id] = mftIndex;\n    }\n\n    T3D.Logger.log(\n        T3D.Logger.TYPE_DEBUG,\n        \"Finished indexing MFT\"\n    );\n\n    return indexTable;\n}\n\n\n/**\n *   Get a chunk of the specified file. Used mainly to take parts of the Archive before parsing.\n * \n * @memberof ArchiveParser\n * @param {File} file \n * @param {number} offset \n * @param {number} length \n * @returns {Promise<{ds: DataStream, len: number}>}\n */\nfunction getFilePart(file, offset, length) {\n    return new Promise((resolve, reject) => {\n        let reader = new FileReader();\n\n        reader.onerror = reject;\n\n        reader.onload = (fileEvent) => {\n            var buffer = fileEvent.target.result;\n            var ds = new DataStream(buffer);\n            ds.endianness = DataStream.LITTLE_ENDIAN;\n            // Pass data stream and data length to callback function\n            resolve({\n                ds: ds,\n                len: length\n            });\n        }\n\n        // Slicing a File is just reducing the scope of the ArrayBuffer, but doesn't load anything in memory.\n        reader.readAsArrayBuffer(file.slice(offset, offset + length));\n    })\n}\n\nmodule.exports = {\n    readArchive: readArchive,\n    parseANDatHeader: parseANDatHeader,\n    parseMFTTable: parseMFTTable,\n    parseMFTIndex: parseMFTIndex,\n    getFilePart: getFilePart\n};","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * Organized thread pool of extractors\n * @class DataReader\n */\nclass DataReader {\n    /**\n     * @constructor\n     * @param {Object} settings\n     * @param {number} settings.workersNb Amount of concurrent spawned workers\n     * @param {string} settings.workerPath Path to the worker script\n     */\n    constructor(settings) {\n        this._settings = settings;\n        this._workerPool = [];\n        this._workerLoad = [];\n\n        //Makes individual ids for file extraction\n        this._handleCounter = 0;\n\n        /** \n         * Work to be processed\n         * @private \n         * @type {[{buffer: ArrayBuffer, size: number, mftId: number, isImage: boolean, capLength: number, resolve: function, reject: function}]} \n         */\n        this._workQueue = [];\n\n        /**\n         * Work currently processed\n         * @private\n         * Entries : {mftId: number, workerId: number, resolve: resolve, reject: reject}\n         */\n        this._handleRegister = {};\n\n        for (let i = 0; i < settings.workersNb; i++) {\n            this._startWorker(settings.workerPath);\n        }\n    }\n\n    /**\n     * @param {DataStream} ds \n     * @param {number} size \n     * @param {number} mftId\n     * @param {boolean} [isImage] Parses the output as a dxt texture\n     * @param {number} [capLength] Output size\n     * @returns {Promise<{buffer: ArrayBuffer, dxtType: number, imageWidth: number, imageHeight: number}>} \n     */\n    inflate(ds, size, mftId, isImage, capLength) {\n        return new Promise((resolve, reject) => {\n            let arrayBuffer = ds.buffer;\n\n            //If no capLength then inflate the whole file\n            if (!capLength || capLength < 0) {\n                capLength = 0;\n            }\n\n            //Buffer length size check\n            if (arrayBuffer.byteLength < 12) {\n                T3D.Logger.log(\n                    T3D.Logger.TYPE_WARNING,\n                    `not inflating, length is too short (${arrayBuffer.byteLength})`, mftId\n                );\n                reject(new Error(\"Couldn't inflate \" + mftId + \" (mftId)\"));\n                return;\n            }\n\n            //Register the data to work with\n            this._workQueue.push({\n                buffer: arrayBuffer,\n                size: size,\n                mftId: mftId,\n                isImage: isImage,\n                capLength: capLength,\n                resolve: resolve,\n                reject: reject\n            });\n\n            // Check if there is a free worker and ask it to start\n            const freeWorkerIndex = this._getFreeWorkerIndex();\n            if (freeWorkerIndex >= 0) {\n                this._workNext(freeWorkerIndex);\n            }\n\n        });\n    }\n\n    /**\n     * Function used to give work to a worker\n     * @private\n     * @param {number} workerId\n     **/\n    _workNext(workerId) {\n        const workData = this._workQueue.shift();\n\n        if (workData) {\n            //Get a handleID\n            const handle = this._getNewHandle();\n\n            this._handleRegister[handle] = {\n                mftId: workData.mftId,\n                workerId: workerId,\n                resolve: workData.resolve,\n                reject: workData.reject\n            };\n\n            this._workerLoad[workerId] += 1;\n            this._workerPool[workerId].postMessage(\n                [handle, workData.buffer, workData.isImage === true, workData.capLength]\n            );\n        }\n\n    }\n\n    _getNewHandle() {\n        return this._handleCounter++;\n    }\n\n    // Initialization function for creating a new worker (thread)\n    // _id should only be used to restart a worker !\n    _startWorker(path, _id) {\n        let worker = new Worker(path);\n        let selfWorkerId;\n        if (_id) {\n            selfWorkerId = _id;\n            this._workerPool[selfWorkerId] = worker;\n            this._workerLoad[selfWorkerId] = 0;\n\n        } else {\n            selfWorkerId = this._workerPool.push(worker) - 1;\n            if (this._workerLoad.push(0) != selfWorkerId + 1)\n                throw new Error(\"WorkerLoad and WorkerPool don't have the same length\");\n        }\n\n        //This\n        worker.onmessage = (message_event) => {\n            const answer = message_event.data;\n            let handleID;\n\n            // Remove load\n            this._workerLoad[selfWorkerId] -= 1;\n\n            // If error\n            if (typeof answer === 'string') {\n                T3D.Logger.log(\n                    T3D.Logger.TYPE_WARNING,\n                    \"Inflater threw an error\", answer\n                );\n\n                //Parse the handle\n                handleID = answer.split(':')[0];\n\n                //Get handle owner informations and reject then cleanup\n                const handleData = this._handleRegister[handleID];\n                if (handleData) {\n                    handleData.reject(`Error: ${answer}`);\n                    delete this._handleRegister[handleID];\n                }\n            } else {\n                //Parse handle\n                handleID = answer[0];\n\n                const handleData = this._handleRegister[handleID];\n                // If handle is recognized: success\n                if (handleData) {\n                    // Array buffer, dxtType, imageWidth, imageHeight\t\t\t\n                    handleData.resolve({\n                        buffer: answer[1],\n                        dxtType: answer[2],\n                        imageWidth: answer[3],\n                        imageHeight: answer[4]\n                    });\n\n                    //Cleanup\n                    delete this._handleRegister[handleID];\n                }\n\n                // Unknown error\n                else {\n                    T3D.Logger.log(\n                        T3D.Logger.TYPE_ERROR,\n                        \"Inflater threw an error\", answer\n                    );\n                }\n            }\n\n            this._workNext(selfWorkerId);\n\n        };\n\n        //Handle errors, we assume worse case: it crashed and corrupted its memory\n        worker.onerror = (error) => {\n            //Get all handles sent to this worker and reject them\n            for (let handle in this._handleRegister) {\n                if (this._handleRegister[handle].workerId === selfWorkerId) {\n                    this._handleRegister[handle].reject(`Error: Worker crashed while processing ${handleData.mftId}`);\n                    delete this._handleRegister[handle];\n                }\n            }\n\n            //Clean and restart the worker\n            this._workerPool[selfWorkerId].terminate();\n            this._startWorker(this._settings.workerPath, selfWorkerId);\n\n        }\n\n    }\n\n    //Returns -1 if there are no free worker, or the index of a free worker\n    _getFreeWorkerIndex() {\n        return this._workerLoad.indexOf(0);\n    }\n\n}\n\nmodule.exports = DataReader;","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst GW2File = require('../format/file/GW2File.js');\n\n/**\n * @namespace FileTypes\n */\n\nlet FileTypes = {\n\n    /**\n     * Parse the beginning of a file to find its type\n     * \n     * @memberof FileTypes\n     * @param {DataStream} ds \n     * @return {number}\n     */\n    getFileType : (ds) => {\n        let first4 = ds.readCString(4);\n\n        //Parse textures\n        switch (first4) {\n            case 'ATEC':\n                return 'TEXTURE_ATEC';\n            case 'ATEP':\n                return 'TEXTURE_ATEP';\n            case 'ATET':\n                return 'TEXTURE_ATET';\n            case 'ATEU':\n                return 'TEXTURE_ATEU';\n            case 'ATEX':\n                return 'TEXTURE_ATEX';\n            case 'ATTX':\n                return 'TEXTURE_ATTX';\n        };\n\n        if (first4.indexOf(\"DDS\") === 0)\n            return 'TEXTURE_DDS';\n\n        if (first4.indexOf(\"PNG\") === 1)\n            return 'TEXTURE_PNG';\n\n        if (first4.indexOf(\"RIFF\") === 0)\n            return 'TEXTURE_RIFF';\n\n        if (first4.indexOf(\"YUI\") === 0)\n            return 'TEXT_YUI';\n\n        // PackFiles\n        if (first4.indexOf(\"PF\") === 0) {\n            let file = new GW2File(ds, 0, true); /// true for \"plz no load chunkz\"\n            return 'PF_' + file.header.type;\n        }\n\n        // Binaries\n        if (first4.indexOf(\"MZ\") === 0)\n            return 'BINARIES';\n\n        // Strings\n        if (first4.indexOf(\"strs\") === 0)\n            return 'STRINGS';\n\n        //Raw asnd chunk (without pack file)\n        if (first4.indexOf(\"asnd\") === 0)\n            return 'CHUNK_ASND';\n\n        // TODO: parse all datastream and if all bytes are valid unicode symbols then\n        // return TEXT_UNKNOWN;\n\n        // Unknown\n        return 'UNKNOWN';\n    }\n}\n\nmodule.exports = FileTypes;","/*\r\nCopyright  Tyria3DLibrary project contributors\r\n\r\nThis file is part of the Tyria 3D Library.\r\n\r\nTyria 3D Library is free software: you can redistribute it and/or modify\r\nit under the terms of the GNU General Public License as published by\r\nthe Free Software Foundation, either version 3 of the License, or\r\n(at your option) any later version.\r\n\r\nTyria 3D Library is distributed in the hope that it will be useful,\r\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\r\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\nGNU General Public License for more details.\r\n\r\nYou should have received a copy of the GNU General Public License\r\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\r\n*/\r\n\r\nconst ArchiveParser = require('./ArchiveParser');\r\nconst PersistantStore = require('./PersistantStore');\r\nconst DataReader = require('./DataReader');\r\nconst MapFileList = require('../MapFileList');\r\nconst FileTypes = require('./FileTypes');\r\n\r\n/**\r\n * A statefull class that handles reading and inflating data from a local GW2 dat file.\r\n * LocalReader have been completely rewritten from scratch, \r\n * the API changed quite a lot between 1.0.4 and 1.1.0.\r\n * \r\n * API CHANGES: LocalReader (1.1.0 from 1.0.4)\r\n * - The constructor have __changed__.\r\n * - parseHeaderAsync have been __removed__.\r\n * - connectInflated have been __removed__.\r\n * - NaClListener have been __removed__.\r\n * - readANDatHeader have been __removed__.\r\n * - readMFTHeader have been __removed__.\r\n * - readMFTIndexFile have been __removed__.\r\n * - loadFileList is now __deprecated__.\r\n * - loadMapList is now __deprecated__.\r\n * - storeFileList have been __removed__.\r\n * - storeMapList have been __removed__.\r\n * - readFileListAsync is now __deprecated__.\r\n * - readMapListAsync is now __deprecated__.\r\n * - listFiles have been __removed__.\r\n * - getFileIndex have been slightly __changed__.\r\n * - loadTextureFile is now __deprecated__.\r\n * - loadFile have been __deprecated__.\r\n * - inflate have been __removed__.\r\n * - loadFilePart have been __removed__.\r\n * \r\n * @param {{workerPath: String, workersNb: number, noIndexedDB: boolean}} settings\r\n *   * workerPath: the path to the t3dtools worker script file.\r\n *   * workersNb: amount of threads spawned for decompression.\r\n *   * noIndexedDB: Do not use indexedDB (persistant storage, default is true)\r\n */\r\nclass LocalReader {\r\n    constructor(settings) {\r\n        this._settings = settings;\r\n\r\n        /** \r\n         * @private\r\n         * @type {DataReader} \r\n         */\r\n        this._dataReader = new DataReader(settings);\r\n\r\n        /**\r\n         * @private\r\n         * @type {PersistantStore}\r\n         */\r\n        this._persistantStore;\r\n\r\n        /**\r\n         * @private\r\n         * @type {File} \r\n         */\r\n        this._file = undefined;\r\n\r\n        /** \r\n         * @private\r\n         * @type {Array<number>} \r\n         */\r\n        this._indexTable = [];\r\n\r\n        /** \r\n         * @private\r\n         * @type {Array<{offset: number, size: number, compressed: number, crc: number}>} \r\n         */\r\n        this._fileMetaTable = [];\r\n\r\n        if (settings.noIndexedDB !== false)\r\n            this._persistantStore = new PersistantStore();\r\n\r\n    }\r\n\r\n\r\n    /**\r\n     *   Asynchronously loads the archive by parsing its file index and header.\r\n     *   \r\n     * @param {File} file \r\n     * @returns {Promise}\r\n     */\r\n    async openArchive(file) {\r\n        let {\r\n            archiveHeader,\r\n            metaTable,\r\n            indexTable\r\n        } = await ArchiveParser.readArchive(file);\r\n        this._fileMetaTable = metaTable;\r\n        this._indexTable = indexTable;\r\n        this._file = file;\r\n\r\n        return;\r\n    }\r\n\r\n    /**\r\n     *   Gets MFT index by baseId\r\n     * \r\n     * @param  {Number} baseId   A base Id\r\n     * @return {Number}          MFT index\r\n     */\r\n    getFileIndex(baseId) {\r\n        return this._indexTable[baseId];\r\n    }\r\n\r\n\r\n    /**\r\n     *   \"Meta\" informations to deal with files in the archive.\r\n     * @typedef     {Object}    FileMetaData\r\n     * @property    {number}    offset\r\n     * @property    {number}    size\r\n     * @property    {number}    compressed\r\n     * @property    {number}    crc\r\n     */\r\n\r\n    /**\r\n     *   Returns the metadata of a file stored in the archive\r\n     * \r\n     * @param {number} mftId Mft index of the file\r\n     * @returns {FileMetaData} Metadata informations\r\n     */\r\n    getFileMeta(mftId) {\r\n        return this._fileMetaTable[mftId];\r\n    }\r\n\r\n\r\n    /**\r\n     *   Fetch a file and uncompress it if needed / required.\r\n     * \r\n     * @param {number} mftId File's archive ID\r\n     * @param {boolean} [isImage] Try to read the data as a Dxt texture.\r\n     * @param {boolean} [raw] Force no decompression.\r\n     * @param {number} [fileLength] Slice the uncompressed file.\r\n     * @param {number} [extractLength] Slice the decompression.\r\n     * @param {boolean} [isBaseId] If true, the first parameter mftId becomes a baseId\r\n     * @returns {Promise<{buffer: ArrayBuffer, dxtType: number|undefined, imageWidth: number|undefined, imageHeight: number|undefined}>}\r\n     */\r\n    async readFile(mftId, isImage, raw, fileLength, extractLength, isBaseId) {\r\n        if(isBaseId){\r\n            const baseId = mftId;\r\n            mftId = this.getFileIndex(baseId);\r\n            if(!(mftId > 0))\r\n                throw new Error(`Unexistant file: ${baseId} (baseId)`);\r\n        }\r\n\r\n        let buffer, dxtType, imageWidth, imageHeight;\r\n        let meta = this.getFileMeta(mftId);\r\n        if (!meta)\r\n            throw new Error(`Unexistant file: ${mftId} (mftId)`);\r\n\r\n        //Slice up the data\r\n        let {\r\n            ds,\r\n            len\r\n        } = await ArchiveParser.getFilePart(this._file, meta.offset, (fileLength) ? fileLength : meta.size);\r\n\r\n        //If needed we decompress, if not we keep raw\r\n        if (meta.compressed || (raw != false)) {\r\n            let data;\r\n            await this._dataReader.inflate(ds, len, mftId, isImage, (extractLength) ? extractLength : 0)\r\n                .then((result) => {\r\n                    data = result\r\n                })\r\n                .catch((error) => {\r\n                    data = {\r\n                        buffer: undefined,\r\n                        dxtType: undefined,\r\n                        imageWidth: undefined,\r\n                        imageHeight: undefined\r\n                    }\r\n                })\r\n            return data;\r\n        } else\r\n            return {\r\n                buffer: ds.buffer\r\n            };\r\n    }\r\n\r\n    /**\r\n     *   Scans asynchronously the types of all the files listed in the archive. \r\n     *   Uses persistant store to cache and speed up a rescan.\r\n     * \r\n     * @param {Array<{baseId: number, size: number, crc: number, fileType: string}>|undefined} oldFileList \r\n     *   Way for platform not supporting indexDB to provide their own persistant storage.\r\n     * @returns {Promise<Array<FileItem>>}\r\n     */\r\n    async readFileList(oldFileList) {\r\n        let persistantList = (oldFileList) ? oldFileList : [];\r\n        let persistantId;\r\n\r\n        //Load previously saved data\r\n        if (this._persistantStore) {\r\n            let lastListing = (await this._persistantStore.getLastListing(this._file.name));\r\n            persistantList = lastListing.array;\r\n            //If the last scan was not completed then we will just update it..\r\n            if (!lastListing.complete) {\r\n                persistantId = lastListing.key;\r\n            }\r\n        }\r\n\r\n        // Create a list of all the baseIds we need to inspect\r\n        let iterateList = Object.keys(this._indexTable).map(i => Number(i));\r\n        for (let index in persistantList) {\r\n            if (!(index in this._indexTable))\r\n                iterateList.push(index);\r\n        }\r\n\r\n        // Helps us to know when we need to update the persistant store\r\n        let updatePersistant = false;\r\n\r\n        //Spawn the decompression tasks\r\n        let taskArray = [];\r\n        for (let i = 0; i < 1; i++) {\r\n            taskArray[i] = Promise.resolve({\r\n                task: i\r\n            });\r\n        }\r\n\r\n        let persistantNeedsUpdate = false;\r\n\r\n        //Iterate through the array\r\n        for (let index in iterateList) {\r\n            let baseId = iterateList[index];\r\n\r\n            //First use a synchronous function to know if we need to scan the file\r\n            let result = this._needsScan(baseId, persistantList);\r\n            if (result.scan == true) {\r\n                let taskId = (await Promise.race(taskArray)).task;\r\n                taskArray[taskId] = this.readFileType(baseId).then((scanResult) => {\r\n                    //Put the result into our persistant storage\r\n                    persistantList[baseId] = {\r\n                        baseId: baseId,\r\n                        size: scanResult.size,\r\n                        crc: scanResult.crc,\r\n                        fileType: scanResult.fileType\r\n                    };\r\n                    return {\r\n                        task: taskId\r\n                    };\r\n                });\r\n            }\r\n            if (result.change == 'removed') {\r\n                //Update the persistant storage\r\n                delete persistantList[baseId];\r\n            }\r\n\r\n            //Handle persistant storage update\r\n            if (result.change !== 'none')\r\n                persistantNeedsUpdate = true;\r\n\r\n            //Tasks to do only every %\r\n            if (index % Math.floor(iterateList.length / 100) == 0) {\r\n                //Print progress\r\n                T3D.Logger.log(T3D.Logger.TYPE_PROGRESS,\r\n                    \"Finding types\", index / Math.floor(iterateList.length / 100));\r\n\r\n                //Update the persistant storage if needed\r\n                if (this._persistantStore && persistantNeedsUpdate) {\r\n                    persistantNeedsUpdate = false;\r\n                    this._persistantStore.putListing(persistantId, persistantList, this._file.name, false).then(res => persistantId = res);\r\n                }\r\n            }\r\n        }\r\n\r\n        await Promise.all(taskArray).then(() => {\r\n            //Finally update the listing as complete\r\n            if (this._persistantStore)\r\n                this._persistantStore.putListing(persistantId, persistantList, this._file.name, true);\r\n        });\r\n        this._persistantData = persistantList;\r\n        return this.getFileList();\r\n    }\r\n\r\n    /**\r\n     * @typedef {Object} MapItem\r\n     * @property {string} name\r\n     * @property {string} category\r\n     * @property {number} baseId\r\n     */\r\n\r\n    /**\r\n     *   Returns a list of all the maps with their name and category.\r\n     *   Uncategorized maps are available only if readFileList have been used before.\r\n     * \r\n     * @returns {Array<MapItem>}\r\n     */\r\n    getMapList() {\r\n        let mapArray = [];\r\n        //If the archive have been scanned for all its file we iterate through the results\r\n        if (this._persistantData) {\r\n            //Filter the maps out of all our files\r\n            let reversedIndex = this.getReverseIndex();\r\n            let maps = this._persistantData.filter(file => file.fileType === 'PF_mapc')\r\n                .filter(id => id.baseId == reversedIndex[this.getFileIndex(id.baseId)][0]);\r\n\r\n\r\n            for (let map of maps) {\r\n                let found = false;\r\n                //Try to see if we already have some informations on this map\r\n                for (let category of MapFileList.maps) {\r\n                    let fileMap = category.maps.find(\r\n                        item => Number(item.fileName.split('.data')[0]) == map.baseId);\r\n                    if (fileMap) {\r\n                        mapArray.push({\r\n                            name: fileMap.name,\r\n                            category: category.name,\r\n                            baseId: map.baseId\r\n                        });\r\n                        found = true;\r\n                        break;\r\n                    }\r\n                }\r\n                //If not we register it as Uncategorized\r\n                if (!found)\r\n                    mapArray.push({\r\n                        name: map.baseId.toString(),\r\n                        category: 'Uncategorized',\r\n                        baseId: map.baseId\r\n                    });\r\n            }\r\n        }\r\n        //If not then we check only known maps\r\n        else {\r\n            for (let category of MapFileList.maps) {\r\n                for (let mapEntry of category.maps) {\r\n                    if (Number(mapEntry.fileName.split('.data')[0]) in this._indexTable)\r\n                        mapArray.push({\r\n                            name: mapEntry.name,\r\n                            category: category.name,\r\n                            baseId: Number(mapEntry.fileName.split('.data')[0])\r\n                        });\r\n                }\r\n            }\r\n        }\r\n        return mapArray;\r\n    }\r\n\r\n\r\n    /**\r\n     * @typedef {Object} FileItem\r\n     * @property {number} mftId\r\n     * @property {Array<number>} baseIdList\r\n     * @property {number} size\r\n     * @property {number} crc\r\n     * @property {string} fileType\r\n     **/\r\n\r\n    /**\r\n     *   Return the meta table with extra information such as an array of baseIds and the file types.\r\n     *   The filetype is available only if readFileList have been used before of course.\r\n     * \r\n     * @returns {Array<FileItem>}\r\n     */\r\n    getFileList() {\r\n        let typeList = (this._persistantData) ? this._persistantData.map(i => i.fileType) : [];\r\n        let reverseBaseIdList = this.getReverseIndex();\r\n\r\n        let fileList = this._fileMetaTable.map((meta, mftId) => {\r\n            let baseIds = (reverseBaseIdList[mftId]) ? reverseBaseIdList[mftId] : [];\r\n            let type = (reverseBaseIdList[mftId]) ? typeList[baseIds[0]] : 'Non-Registered';\r\n            return {\r\n                mftId: mftId,\r\n                baseIdList: baseIds,\r\n                size: meta.size,\r\n                crc: meta.crc,\r\n                fileType: type\r\n            }\r\n        });\r\n        fileList[0] = {\r\n            mftId: 0,\r\n            baseIdList: [],\r\n            size: 0,\r\n            crc: 0,\r\n            fileType: 'Non-Registered'\r\n        };\r\n        return fileList;\r\n    }\r\n\r\n    /**\r\n     * @returns {Array<Array<number>>}\r\n     */\r\n    getReverseIndex() {\r\n        return this._indexTable.reduce((reversed, mftId, baseId) => {\r\n            if (mftId in reversed)\r\n                reversed[mftId].push(baseId);\r\n            else\r\n                reversed[mftId] = [baseId];\r\n            return reversed;\r\n        }, []);\r\n    }\r\n\r\n    //API Compatibility\r\n\r\n    /**\r\n     * Looks up mft indices for all mapc pack files in the dat. Either looks trough all files or\r\n     * only the list defined in {@link MapFileList}\r\n     *\r\n     * @deprecated Use now the getFileList method.\r\n     * @param  {boolean}   searchAll if true forces re-indexing of entire dat.\r\n     * If false only reads indices specified in \"T3D/MapFileList\".\r\n     * @param  {Function} callback Fired when the list is generated\r\n     *\r\n     * First argument is the a list of mft indices grouped by file type. For exmample:\r\n     * \r\n     * \t\t{\t\r\n     * \t\t\tmaps:[\r\n     * \t\t\t\t{\r\n     * \t\t\t\t\tname: 'Heart of Maguuma',\r\n     * \t\t\t\t\tmaps: [\r\n     * \t\t\t\t\t\t{fileName:1151420, name:'HoT BWE3 Raid'},\r\n     * \t\t\t\t\t\t{fileName:969663, name:'Verdant Brink}\r\n     * \t\t\t\t\t]\r\n     * \t\t\t\t},\r\n     * \t\t\t\t{\r\n     * \t\t\t\t\tname: 'Unknown maps',\r\n     * \t\t\t\t\tmaps: [\r\n     * \t\t\t\t\t\t{fileName:12345678, name:'Unknown map 12345678'}\r\n     * \t\t\t\t\t]\r\n     * \t\t\t\t}\r\n     * \t\t\t]\r\n     \r\n    *\t    };\r\n    */\r\n    readMapListAsync(searchAll, callback) {\r\n        T3D.Logger.log(T3D.Logger.TYPE_WARNING, \"LocalReader.readMapListAsync is deprecated !\");\r\n\r\n        //Let's preserve the old output way\r\n        function restoreOuput(array) {\r\n            let returnArray = [];\r\n            for (let elt of array) {\r\n                let category = returnArray.findIndex(i => i.name == elt.category)\r\n                if (category == -1)\r\n                    category = returnArray.push({\r\n                        name: elt.category,\r\n                        maps: []\r\n                    }) - 1;\r\n                returnArray[category].maps.push({\r\n                    fileName: elt.baseId,\r\n                    name: elt.name\r\n                });\r\n            }\r\n            //And resort it in order\r\n            returnArray.sort((i, j) => {\r\n                if (i.name < j.name) return -1;\r\n                if (i.name > j.name) return 1;\r\n                return 0;\r\n            })\r\n            return {\r\n                maps: returnArray\r\n            };\r\n        }\r\n\r\n        /// If seachAll flag is true, force a deep search\r\n        if (searchAll) {\r\n            this.readFileList().then(() => {\r\n                callback(restoreOuput(this.getMapList()));\r\n            })\r\n        } else {\r\n            callback(restoreOuput(this.getMapList()));\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Reads the file type of each file in the dat and stores the resulting list in \r\n     * the browser's local storage.\r\n     * \r\n     * @deprecated Use now the readFileList or getFileList methods.\r\n     * @param  {Function} callback Fired when the list is generated and stores\r\n     *\r\n     * First argument is the a list of mft indices grouped by file type.\r\n     */\r\n    readFileListAsync(callback) {\r\n        T3D.Logger.log(T3D.Logger.TYPE_WARNING, \"LocalReader.readFileListAsync is deprecated !\");\r\n\r\n        //Because the API changed we reform the data as wanted previously\r\n        this.readFileList().then((result) => {\r\n            let returnObj = {};\r\n            for (let fileEntry of result) {\r\n                if (returnObj[fileEntry.fileType] === undefined)\r\n                    returnObj[fileEntry.fileType] = [];\r\n                returnObj[fileEntry.fileType].push(fileEntry.mftId);\r\n            }\r\n            callback(returnObj);\r\n        });\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * Reads data from a file in the dat.\r\n     * \r\n     * @deprecated Use now the Promise-based method readFile.\r\n     * @param  {Number}   baseId   Base or File id of the texture to load\r\n     * @param  {Function} callback Fires when the inflater has read the data.\r\n     *\r\n     * The passed arguments are \r\n     * -ArrayBuffer raw data\r\n     * -Number DXT Type if applicable\r\n     * -Number image width if applicable\r\n     * -Number image height if applicable\r\n     *\r\n     * \r\n     * @param  {boolean}  isImage  \r\n     * @param  {boolean}   raw      If true, any infation is skipped and raw data is returned.\r\n     */\r\n    loadFile(baseId, callback, isImage, raw) {\r\n        T3D.Logger.log(T3D.Logger.TYPE_WARNING, \"LocalReader.loadFile is deprecated !\");\r\n        this.readFile(baseId, isImage, raw, undefined, undefined, true).then((result) => {\r\n            if (result.buffer == undefined)\r\n                return callback(null);\r\n            callback(result.buffer, result.dxtType, result.imageWidth, result.imageHeight);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Reads a bitmap from a texture file in the dat.\r\n     * \r\n     * @deprecated\r\n     * @param  {Number}   baseId   Base or File id of the texture to load\r\n     * @param  {Function} callback Fires when the inflater has read the texture data.\r\n     * \r\n     * The passed arguments are \r\n     * -ArrayBuffer Bitmap\r\n     * -Number DXT Type\r\n     * -Number image width\r\n     * -Number image height\r\n     *\r\n     */\r\n    loadTextureFile(baseId, callback) {\r\n        T3D.Logger.log(T3D.Logger.TYPE_WARNING, \"LocalReader.loadTextureFile is deprecated !\");\r\n\r\n        /// Old way:\r\n        //this.loadFile(baseId, callback, true);\r\n\r\n        /// New way:\r\n        this.readFile(baseId, isImage, raw, undefined, undefined, true).then((result) => {\r\n            if (result.buffer == undefined)\r\n                return callback(null);\r\n            callback(result.buffer, result.dxtType, result.imageWidth, result.imageHeight);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Used to read the cached list of files corresponding to the reader's .dat from the localStorage.\r\n     * Now kept only for backward compatibility, but doesn't do anything.\r\n     * Please use getFileList now.\r\n     * \r\n     * @deprecated\r\n     */\r\n    loadFileList() {\r\n        T3D.Logger.log(T3D.Logger.TYPE_WARNING, \"LocalReader.loadFileList is deprecated !\");\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Used to read the cached list of maps corresponding to the reader's .dat from the localStorage.\r\n     * Now kept only for backward compatibility, but doesn't do anything.\r\n     * Please use getMapList now.\r\n     *\r\n     * @deprecated\r\n     */\r\n    loadMapList() {\r\n        T3D.Logger.log(T3D.Logger.TYPE_WARNING, \"LocalReader.loadMapList is deprecated !\");\r\n        return undefined;\r\n    }\r\n\r\n\r\n    // Private \r\n\r\n\r\n    /**\r\n     * @private\r\n     * @param {number} baseId \r\n     * @param {Array<{baseId: number, crc: number, size: number, fileType: string}>} persistantData \r\n     * @returns {{scan: boolean, change: string }}\r\n     */\r\n    _needsScan(baseId, persistantData) {\r\n        if (baseId <= 0)\r\n            return {\r\n                change: 'none',\r\n                scan: false\r\n            };\r\n\r\n        let mftId = this.getFileIndex(baseId);\r\n        let metaData = this.getFileMeta(mftId);\r\n\r\n        //Nothing interesting\r\n        if (metaData === undefined && !(baseId in persistantData)) {\r\n            return {\r\n                change: 'none',\r\n                scan: false\r\n            };\r\n        }\r\n        //If the file have been deleted\r\n        else if (metaData === undefined) {\r\n            return {\r\n                change: 'removed',\r\n                scan: false\r\n            };\r\n        }\r\n        //If the file is new\r\n        else if (!(baseId in persistantData)) {\r\n            return {\r\n                change: 'added',\r\n                scan: true\r\n            };\r\n        }\r\n        //If the size or crc don't match\r\n        else if (metaData.size !== persistantData[baseId].size || metaData.crc !== persistantData[baseId].crc) {\r\n            return {\r\n                change: 'modified',\r\n                scan: true\r\n            };\r\n        }\r\n        //If everything is the same\r\n        else {\r\n            return {\r\n                change: 'none',\r\n                scan: false\r\n            };\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reads the file type and gives back an object with fileType, crc and size informations\r\n     * @param {number} baseId \r\n     * @param {Array<{baseId: number, crc: number, size: number, fileType: string}>} persistantData \r\n     * @returns {Promise<{fileType: string, crc: number, size: number}>}\r\n     */\r\n    async readFileType(baseId) {\r\n        if (!this._fileTypeCache)\r\n            this._fileTypeCache = [];\r\n\r\n        let mftId = this.getFileIndex(baseId);\r\n        let metaData = this.getFileMeta(mftId);\r\n\r\n        let fileType;\r\n        if (this._fileTypeCache[baseId] != undefined) {\r\n            fileType = this._fileTypeCache[baseId];\r\n        } else {\r\n            let fileBuffer = (await this.readFile(mftId, false, false, Math.min(metaData.size, 1000), 32)).buffer;\r\n            if (fileBuffer == undefined)\r\n                return undefined;\r\n            fileType = FileTypes.getFileType(new DataStream(fileBuffer));\r\n        }\r\n        return {\r\n            fileType: fileType,\r\n            crc: metaData.crc,\r\n            size: metaData.size\r\n        };\r\n    }\r\n}\r\n\r\nmodule.exports = LocalReader;","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/// T3DLib version\nconst version = require('../T3DLib').version;\n\n/// Indexed DB versioning\nconst DB_VERSION = 4;\n\n/**\n * This class handles offline storage of the .dat indexes and files metadata\n * @class PersistantStore\n */\nclass PersistantStore {\n\n    constructor() {\n        //They may be multiple connection request issued at the same time, but it's actually okay since\n        //as soon as they are registered, the not-used ones will get garbage collected\n        this._dbConnection = undefined;\n        this._getConnection(() => {});\n    }\n\n    /**\n     *   Initialize the IndexedDB connection and manages version changes.\n     * \n     * @async\n     * @private\n     * @returns {Promise<IDBDatabase>} Promise to the Database connection\n     */\n    _getConnection() {\n        return new Promise((resolve, reject) => {\n            if (this._dbConnection)\n                resolve(this._dbConnection);\n\n            // Let us open our database\n            let request = window.indexedDB.open(\"Tyria3DLibrary\", DB_VERSION);\n\n            /// onblocked is fired when the db needs an upgrade but an older version is opened in another tab\n            request.onblocked = (event) => {\n                T3D.Logger.log(\n                    T3D.Logger.TYPE_ERROR,\n                    \"The T3D persistant database cannot be upgraded while the app is opened somewhere else.\"\n                );\n            }\n\n            /// fired when the database needs to be upgraded (or the first time)\n            request.onupgradeneeded = (event) => {\n                /** @type {IDBDatabase} */\n                let db = event.target.result;\n                let currentVersion = event.oldVersion;\n\n                if (currentVersion < 2) {\n                    let newstore = db.createObjectStore(\"listings\", {\n                        autoIncrement: true\n                    });\n                }\n\n                if (currentVersion < 3) {\n                    let storeListing = event.currentTarget.transaction.objectStore(\"listings\");\n                    storeListing.createIndex('filename', 'filename', {\n                        unique: false\n                    });\n                }\n\n            }\n\n            request.onsuccess = (event) => {\n                this._dbConnection = event.target.result;\n                this.isReady = true;\n                resolve(this._dbConnection);\n            }\n\n            request.onerror = (event) => {\n                T3D.Logger.log(\n                    T3D.Logger.TYPE_ERROR,\n                    \"The T3D persistant database could not be opened.\"\n                );\n                reject();\n            }\n        });\n    }\n\n    /**\n     *   Add or update a listing into the database\n     * \n     * @async\n     * @param {number|undefined} id This ID doesn't really matter, it's just the index of the object in the database, can be undefined\n     * @param {Array} listing \n     * @param {string} fileName .dat file name, allows to have multiple listings for different .dat files.\n     * @param {boolean} isComplete Keep back the information if that was the last update on the current scan or not.\n     * @returns {Promise<number>} On success, the number is the object key in the database\n     */\n    putListing(id, listing, fileName, isComplete) {\n        return new Promise((resolve, reject) => {\n            this._getConnection().then((db) => {\n                let store = db.transaction([\"listings\"], \"readwrite\").objectStore(\"listings\");\n\n                let request = (id) ? store.put({\n                    array: listing,\n                    filename: fileName,\n                    complete: isComplete\n                }, id) : store.put({\n                    array: listing,\n                    name: fileName\n                });\n\n                request.onsuccess = (event) => {\n                    resolve(request.result);\n                }\n                request.onerror = (event) => {\n                    reject();\n                }\n            })\n        });\n    }\n\n    /**\n     * Returns the last valid listing in the database\n     * \n     * @async\n     * @param {string} fileName .dat file name, allows to have multiple listings for different .dat files.\n     * @returns {Promise<{array: Array, key: number, complete: boolean}>}\n     *      array: the last listing\n     *      key: the index of the last listing in the database\n     */\n    getLastListing(fileName) {\n        return new Promise((resolve, reject) => {\n            this._getConnection().then((db) => {\n                let listingsStore = db.transaction([\"listings\"], \"readonly\")\n                    .objectStore(\"listings\").index(\"filename\");\n\n                listingsStore.openCursor(IDBKeyRange.only(fileName), \"prev\").onsuccess = (event) => {\n                    let cursor = event.target.result;\n                    if (!cursor)\n                        resolve({\n                            array: [],\n                            key: undefined,\n                            complete: true\n                        });\n                    else {\n                        resolve({\n                            array: cursor.value.array,\n                            key: cursor.primaryKey,\n                            complete: cursor.value.complete\n                        });\n                    }\n\n                }\n            });\n        });\n    }\n}\n\nmodule.exports = PersistantStore;","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * A Logger class for T3D\n *\n * This satic class defines severity levels of messages and provides\n * basic logging functionality. Replacing the reference to\n * \n * @namespace\n * @static \n */\nvar Logger = {};\n\n/**\n * @readonly\n * @property {number} TYPE_ERROR\n */\nLogger.TYPE_ERROR = 4;\n\n/**\n * @readonly\n * @property {number} TYPE_WARNING\n */\nLogger.TYPE_WARNING = 3;\n\n/**\n * @readonly\n * @property {number} TYPE_MESSAGE\n */\nLogger.TYPE_MESSAGE = 2;\n\n/**\n * @readonly\n * @property {number} TYPE_PROGRESS\n */\nLogger.TYPE_PROGRESS = 1;\n\n/**\n * @readonly\n * @property {number} TYPE_DEBUG\n */\nLogger.TYPE_DEBUG = 0;\n\n\n\n/**\n * The logging functions, indexed by severity/type.\n *\n * @property logFunctions\n * @type Function[]\n */\nLogger.logFunctions = new Array(5);\n\n/**\n * Main logging method. Takes 1 to N arguments. If there are more than 1 arguments\n * the first argument is interpreted as severity. If there is only one argument\n * severity defaults to\n * {{#crossLink \"Logger/TYPE_MESSAGE:property\"}}{{/crossLink}}.\n *  \n * The following arguments are passed to a logging function matching the\n * severity.\n * \n \n * \n */\nLogger.log = function () {\n\n\t/// Require at least 1 argument\n\tif (arguments.length == 0) {\n\t\treturn;\n\t}\n\n\t/// Parse arguments to an actual array\n\tvar argArr = Logger.argsToArr(arguments);\n\n\t/// Default to message if just one argument was passed\n\tif (argArr.length == 1) {\n\t\targArr.unshift(Logger.TYPE_MESSAGE);\n\t}\n\n\t/// Otherwise 1st arg is severity, log/warn/error\n\tvar severity = Math.max(0, Math.min(Logger.logFunctions.length, argArr.shift()));\n\tvar logFunc = Logger.logFunctions[severity];\n\n\t/// Ouput the rest of the arguments\n\tlogFunc.apply(this, argArr);\n}\n\nLogger.argsToArr = function (args) {\n\tvar argArr = new Array(args.length);\n\tfor (var i = 0; i < argArr.length; ++i) {\n\t\targArr[i] = args[i];\n\t}\n\treturn argArr;\n}\n\nLogger.logFunctions[Logger.TYPE_ERROR] = function () {\n\tconsole.error.apply(console, arguments);\n}\n\nLogger.logFunctions[Logger.TYPE_WARNING] = function () {\n\tconsole.warn.apply(console, arguments);\n}\n\nLogger.logFunctions[Logger.TYPE_MESSAGE] = function () {\n\tconsole.log.apply(console, arguments);\n}\n\nLogger.logFunctions[Logger.TYPE_PROGRESS] = function () {\n\tvar argArr = Logger.argsToArr(arguments);\n\targArr.unshift(\"Progress: \");\n\tconsole.log.apply(console, argArr);\n}\n\nLogger.logFunctions[Logger.TYPE_DEBUG] = function () {\n\tvar argArr = Logger.argsToArr(arguments);\n\tconsole.debug.apply(console, argArr);\n}\n\n\nmodule.exports = Logger;","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nmodule.exports = {\n    /**\n     * @property maps\n     * @type {Array.<{name: String, maps: Array.<{fileName: String, name: String}>}>}\n     */\n    maps: [{\n            name: \"01. Shiverpeaks\",\n            maps: [{\n                    fileName: \"125199.data\",\n                    name: \"Wayfarer Foothills (0)\"\n                },\n                {\n                    fileName: \"187611.data\",\n                    name: \"Wayfarer Foothills (1)\"\n                },\n                {\n                    fileName: \"568778.data\",\n                    name: \"Cragstead\"\n                },\n                {\n                    fileName: \"132434.data\",\n                    name: \"Hoelbrak (0)\"\n                },\n                {\n                    fileName: \"197122.data\",\n                    name: \"Hoelbrak (1)\"\n                },\n                {\n                    fileName: \"1966018.data\",\n                    name: \"Hoelbrak (2)\"\n                },\n                {\n                    fileName: \"124093.data\",\n                    name: \"Snowden Drifts (0)\"\n                },\n                {\n                    fileName: \"186397.data\",\n                    name: \"Snowden Drifts (1)\"\n                },\n                {\n                    fileName: \"275155.data\",\n                    name: \"Dredgehaunt Cliffs\"\n                },\n                {\n                    fileName: \"276252.data\",\n                    name: \"Frostgorge Sound\"\n                },\n                {\n                    fileName: \"277587.data\",\n                    name: \"Lornar's Pass\"\n                },\n                {\n                    fileName: \"278717.data\",\n                    name: \"Timberline Falls (0)\"\n                },\n                {\n                    fileName: \"846866.data\",\n                    name: \"Timberline Falls (1)\"\n                },\n                {\n                    fileName: \"1018612.data\",\n                    name: \"Timberline Falls (2)\"\n                },\n                {\n                    fileName: \"295282.data\",\n                    name: \"Eye of the North\"\n                },\n            ]\n        },\n        {\n            name: \"02. Ascalon\",\n            maps: [{\n                    fileName: \"126118.data\",\n                    name: \"Plains of Ashford (0)\"\n                },\n                {\n                    fileName: \"188591.data\",\n                    name: \"Plains of Ashford (1)\"\n                },\n                {\n                    fileName: \"127888.data\",\n                    name: \"Diessa Plateau (0)\"\n                },\n                {\n                    fileName: \"190490.data\",\n                    name: \"Diessa Plateau (1)\"\n                },\n                {\n                    fileName: \"131944.data\",\n                    name: \"Black Citadel (0)\"\n                },\n                {\n                    fileName: \"196585.data\",\n                    name: \"Black Citadel (1)\"\n                },\n                {\n                    fileName: \"1968107.data\",\n                    name: \"Black Citadel (2)\"\n                },\n                {\n                    fileName: \"280025.data\",\n                    name: \"Blazeridge Steppes\"\n                },\n                {\n                    fileName: \"281313.data\",\n                    name: \"Fireheart Rise\"\n                },\n                {\n                    fileName: \"282668.data\",\n                    name: \"Iron Marches\"\n                },\n                {\n                    fileName: \"283574.data\",\n                    name: \"Fields of Ruin\"\n                },\n            ]\n        },\n        {\n            name: \"03. Kryta\",\n            maps: [{\n                    fileName: \"191000.data\",\n                    name: \"Lion's Arch (0)\"\n                },\n                {\n                    fileName: \"814803.data\",\n                    name: \"Lion's Arch (1)\"\n                },\n                {\n                    fileName: \"1019669.data\",\n                    name: \"Lion's Arch (Legacy)\"\n                },\n                {\n                    fileName: \"1796999.data\",\n                    name: \"Lion's Arch (2)\"\n                },\n                {\n                    fileName: \"1869665.data\",\n                    name: \"Lion's Arch (3)\"\n                },\n                {\n                    fileName: \"1968576.data\",\n                    name: \"Lion's Arch (4)\"\n                },\n                {\n                    fileName: \"128151.data\",\n                    name: \"Divinity's Reach (0)\"\n                },\n                {\n                    fileName: \"191265.data\",\n                    name: \"Divinity's Reach (1)\"\n                },\n                {\n                    fileName: \"705746.data\",\n                    name: \"Divinity's Reach (2)\"\n                },\n                {\n                    fileName: \"1968748.data\",\n                    name: \"Divinity's Reach (3)\"\n                },\n                {\n                    fileName: \"129834.data\",\n                    name: \"North of Divinity's Reach (0)\"\n                },\n                {\n                    fileName: \"193081.data\",\n                    name: \"North of Divinity's Reach (1)\"\n                },\n                {\n                    fileName: \"129524.data\",\n                    name: \"Queensdale (0)\"\n                },\n                {\n                    fileName: \"192711.data\",\n                    name: \"Queensdale (1)\"\n                },\n                {\n                    fileName: \"130970.data\",\n                    name: \"Kessex Hills (0)\"\n                },\n                {\n                    fileName: \"194288.data\",\n                    name: \"Kessex Hills (1)\"\n                },\n                {\n                    fileName: \"672138.data\",\n                    name: \"Kessex Hills (2)\"\n                },\n                {\n                    fileName: \"861815.data\",\n                    name: \"Kessex Hills (3)\"\n                },\n                {\n                    fileName: \"286945.data\",\n                    name: \"Bloodtide Coast\"\n                },\n                {\n                    fileName: \"287870.data\",\n                    name: \"Harathi Hinterlands\"\n                },\n                {\n                    fileName: \"289176.data\",\n                    name: \"Gendarran Fields\"\n                },\n                {\n                    fileName: \"295005.data\",\n                    name: \"Chantry of Secrets\"\n                },\n                {\n                    fileName: \"294938.data\",\n                    name: \"Claw Island\"\n                },\n            ]\n        },\n        {\n            name: \"04. Maguuma Jungle\",\n            maps: [{\n                    fileName: \"195149.data\",\n                    name: \"Caledon Forest\"\n                },\n                {\n                    fileName: \"195493.data\",\n                    name: \"Metrica Province\"\n                },\n                {\n                    fileName: \"922320.data\",\n                    name: \"Metrica Province Instance\"\n                },\n                {\n                    fileName: \"198076.data\",\n                    name: \"The Grove (0)\"\n                },\n                {\n                    fileName: \"1969341.data\",\n                    name: \"The Grove (1)\"\n                },\n                {\n                    fileName: \"198272.data\",\n                    name: \"Rata Sum (0)\"\n                },\n                {\n                    fileName: \"1968896.data\",\n                    name: \"Rata Sum (1)\"\n                },\n                {\n                    fileName: \"291064.data\",\n                    name: \"Mount Maelstrom\"\n                },\n                {\n                    fileName: \"292254.data\",\n                    name: \"Sparkfly Fen\"\n                },\n                {\n                    fileName: \"293307.data\",\n                    name: \"Brisban Wildlands\"\n                },\n            ]\n        },\n        {\n            name: \"05. Ruins of Orr\",\n            maps: [{\n                    fileName: \"284829.data\",\n                    name: \"Straits of Devastation\"\n                },\n                {\n                    fileName: \"285089.data\",\n                    name: \"Malchor's Leap\"\n                },\n                {\n                    fileName: \"285634.data\",\n                    name: \"Cursed Shore\"\n                },\n                {\n                    fileName: \"295179.data\",\n                    name: \"Cathedral of Hidden Depths\"\n                },\n                {\n                    fileName: \"295962.data\",\n                    name: \"A Light in the Darkness\"\n                },\n            ]\n        },\n        {\n            name: \"06. Living World S1\",\n            maps: [{\n                    fileName: \"520479.data\",\n                    name: \"Southsun Cove\"\n                },\n                {\n                    fileName: \"679089.data\",\n                    name: \"Tower of Nightmares\"\n                },\n            ]\n        },\n        {\n            name: \"07. Living World S2\",\n            maps: [{\n                    fileName: \"836211.data\",\n                    name: \"Dry top (0)\"\n                },\n                {\n                    fileName: \"861770.data\",\n                    name: \"Dry top (1)\"\n                },\n                {\n                    fileName: \"909361.data\",\n                    name: \"The Silverwastes (0)\"\n                },\n                {\n                    fileName: \"996202.data\",\n                    name: \"The Silverwastes (1)\"\n                },\n                {\n                    fileName: \"908730.data\",\n                    name: \"Glint's Lair\"\n                },\n            ]\n        },\n        {\n            name: \"08. Heart of Maguuma\",\n            maps: [{\n                    fileName: \"969663.data\",\n                    name: \"Verdant Brink\"\n                },\n                {\n                    fileName: \"1262460.data\",\n                    name: \"Hearts and Minds\"\n                },\n                {\n                    fileName: \"969964.data\",\n                    name: \"Unknown Airship in tree\"\n                },\n                {\n                    fileName: \"1262310.data\",\n                    name: \"Dragon Stand\"\n                },\n                {\n                    fileName: \"1263739.data\",\n                    name: \"Tarir\"\n                },\n                {\n                    fileName: \"1264291.data\",\n                    name: \"Tangled Depths\"\n                },\n            ]\n        },\n        {\n            name: \"09. Living World S3\",\n            maps: [{\n                    fileName: \"1472635.data\",\n                    name: \"(E1) Bloodstone Fen\"\n                },\n                {\n                    fileName: \"1498071.data\",\n                    name: \"(E2) Taimi Simulator\"\n                },\n                {\n                    fileName: \"1498578.data\",\n                    name: \"(E2) Ring of Fire\"\n                },\n                {\n                    fileName: \"1605211.data\",\n                    name: \"(E3) Bitterfrost Frontier\"\n                },\n                {\n                    fileName: \"1645474.data\",\n                    name: \"(E4) Caudecus Manor\"\n                },\n                {\n                    fileName: \"1646520.data\",\n                    name: \"(E4) Lake Doric\"\n                },\n                {\n                    fileName: \"1682493.data\",\n                    name: \"(E5) Draconis Mons\"\n                },\n                {\n                    fileName: \"1682763.data\",\n                    name: \"(E5) Titan's Throat\"\n                },\n                {\n                    fileName: \"1734839.data\",\n                    name: \"(E6) White Mantle Fortress\"\n                },\n                {\n                    fileName: \"1735346.data\",\n                    name: \"(E6) Siren's Landing\"\n                },\n                {\n                    fileName: \"1735440.data\",\n                    name: \"(E6) Shining Blade Headquarters\"\n                },\n            ]\n        },\n        {\n            name: \"10. Crystal Desert\",\n            maps: [{\n                    fileName: \"1794574.data\",\n                    name: \"Crystal Oasis\"\n                },\n                {\n                    fileName: \"1833034.data\",\n                    name: \"Desert Highlands\"\n                },\n                {\n                    fileName: \"1833726.data\",\n                    name: \"PoF story instances\"\n                },\n                {\n                    fileName: \"1839188.data\",\n                    name: \"Domain of Vabbi\"\n                },\n                {\n                    fileName: \"1840103.data\",\n                    name: \"Elon Riverlands\"\n                },\n                {\n                    fileName: \"1840368.data\",\n                    name: \"Kormir Sanctuary\"\n                },\n                {\n                    fileName: \"1842533.data\",\n                    name: \"The Desolation\"\n                },\n            ]\n        },\n        {\n            name: \"11. Living World S4\",\n            maps: [{\n                    fileName: \"1901428.data\",\n                    name: \"(E1) Fahranur\"\n                },\n                {\n                    fileName: \"1902235.data\",\n                    name: \"(E1) Istan\"\n                },\n                {\n                    fileName: \"1903523.data\",\n                    name: \"(E1) Crystal Oasis\"\n                },\n                {\n                    fileName: \"1954984.data\",\n                    name: \"(E2) Desert Highlands\"\n                },\n                {\n                    fileName: \"1955224.data\",\n                    name: \"(E2) Inquest Lab Tower\"\n                },\n                {\n                    fileName: \"1955471.data\",\n                    name: \"(E2) Rata Primus\"\n                },\n                {\n                    fileName: \"1955642.data\",\n                    name: \"(E2) Divinity's Reach\"\n                },\n                {\n                    fileName: \"1955915.data\",\n                    name: \"(E2) Mount Maelstrom\"\n                },\n                {\n                    fileName: \"1956140.data\",\n                    name: \"(E2) Frostgorge Sound\"\n                },\n                {\n                    fileName: \"1956245.data\",\n                    name: \"(E2) Void\"\n                },\n                {\n                    fileName: \"1956299.data\",\n                    name: \"(E2) Hided Inquest Lab\"\n                },\n                {\n                    fileName: \"1957526.data\",\n                    name: \"(E2) Sandswept Isles\"\n                }\n            ]\n        },\n        {\n            name: \"12. Seasonal Activities\",\n            maps: [{\n                    fileName: \"506592.data\",\n                    name: \"Ascent to Madness\"\n                },\n                {\n                    fileName: \"506670.data\",\n                    name: \"Mad King's Labyrinth (Past)\"\n                },\n                {\n                    fileName: \"662436.data\",\n                    name: \"Mad King's Labyrinth (Present)\"\n                },\n                {\n                    fileName: \"506739.data\",\n                    name: \"Mad King's Clock Tower\"\n                },\n                {\n                    fileName: \"622681.data\",\n                    name: \"The Crown Pavilion\"\n                },\n                {\n                    fileName: \"569756.data\",\n                    name: \"SAB Hub (0)\"\n                },\n                {\n                    fileName: \"636133.data\",\n                    name: \"SAB Hub (1)\"\n                },\n                {\n                    fileName: \"635555.data\",\n                    name: \"SAB World 1\"\n                },\n                {\n                    fileName: \"635960.data\",\n                    name: \"SAB World 2\"\n                },\n                {\n                    fileName: \"606255.data\",\n                    name: \"Zephyr Sanctum\"\n                },\n                {\n                    fileName: \"529896.data\",\n                    name: \"Tixx's Infinirarium\"\n                },\n                {\n                    fileName: \"529945.data\",\n                    name: \"Winter Wonderland\"\n                },\n            ]\n        },\n        {\n            name: \"13. Activites\",\n            maps: [{\n                    fileName: \"605983.data\",\n                    name: \"Sanctum Sprint\"\n                },\n                {\n                    fileName: \"606030.data\",\n                    name: \"Basket Brawl\"\n                },\n            ]\n        },\n        {\n            name: \"14. Dungeons\",\n            maps: [{\n                    fileName: \"126840.data\",\n                    name: \"Ascalonian Catacombs (0)\"\n                },\n                {\n                    fileName: \"189364.data\",\n                    name: \"Ascalonian Catacombs (1)\"\n                },\n                {\n                    fileName: \"275474.data\",\n                    name: \"Sorrow's Embrace\"\n                },\n                {\n                    fileName: \"276520.data\",\n                    name: \"Honor of the Waves\"\n                },\n                {\n                    fileName: \"284039.data\",\n                    name: \"Citadel of Flame\"\n                },\n                {\n                    fileName: \"287214.data\",\n                    name: \"Caudecus's Manor\"\n                },\n                {\n                    fileName: \"291284.data\",\n                    name: \"Twilight Arbor (0)\"\n                },\n                {\n                    fileName: \"645968.data\",\n                    name: \"Twilight Arbor (1)\"\n                },\n                {\n                    fileName: \"293606.data\",\n                    name: \"Crucible of Eternity\"\n                },\n                {\n                    fileName: \"473930.data\",\n                    name: \"The Ruined City of Arah\"\n                },\n                {\n                    fileName: \"473765.data\",\n                    name: \"Arah - Story\"\n                },\n                {\n                    fileName: \"580061.data\",\n                    name: \"Molten Facility\"\n                },\n                {\n                    fileName: \"595722.data\",\n                    name: \"Aetherblade Retreat\"\n                },\n            ]\n        },\n        {\n            name: \"15. Fractals\",\n            maps: [{\n                    fileName: \"519839.data\",\n                    name: \"Fractals of the Mists\"\n                },\n                {\n                    fileName: \"697450.data\",\n                    name: \"Thaumanova Reactor\"\n                },\n                {\n                    fileName: \"1426653.data\",\n                    name: \"Cliffside Fractal\"\n                },\n                {\n                    fileName: \"1472361.data\",\n                    name: \"Chaos Isle Fractal\"\n                },\n                {\n                    fileName: \"1472382.data\",\n                    name: \"Snowblind Fractal\"\n                },\n                {\n                    fileName: \"1472406.data\",\n                    name: \"Swampland Fractal\"\n                },\n                {\n                    fileName: \"1498016.data\",\n                    name: \"Mistlock Observatory\"\n                },\n                {\n                    fileName: \"1498798.data\",\n                    name: \"Aetherblade/Mai Trin Fractal\"\n                },\n                {\n                    fileName: \"1605344.data\",\n                    name: \"Nightmare Fractal\"\n                },\n                {\n                    fileName: \"1733857.data\",\n                    name: \"Shattered Observatory Fractal\"\n                },\n                {\n                    fileName: \"1733961.data\",\n                    name: \"Mistlock Sanctuary\"\n                },\n                {\n                    fileName: \"1905739.data\",\n                    name: \"Molten Boss Fractal\"\n                },\n                {\n                    fileName: \"1905889.data\",\n                    name: \"Twilight Oasis Fractal\"\n                },\n            ]\n        },\n        {\n            name: \"16. Raid\",\n            maps: [{\n                    fileName: \"1151420.data\",\n                    name: \"(W1) Spirit Vale\"\n                },\n                {\n                    fileName: \"1383309.data\",\n                    name: \"(W2) Salvation Pass\"\n                },\n                {\n                    fileName: \"1427048.data\",\n                    name: \"Special Forces Training Area\"\n                },\n                {\n                    fileName: \"1454070.data\",\n                    name: \"(W3) Stronghold of the Faithful\"\n                },\n                {\n                    fileName: \"1645215.data\",\n                    name: \"(W4) Bastion of the Penitent\"\n                },\n                {\n                    fileName: \"1906329.data\",\n                    name: \"(W5) Hall of Chains\"\n                },\n            ]\n        },\n        {\n            name: \"17. Structured PvP\",\n            maps: [{\n                    fileName: \"871093.data\",\n                    name: \"Original Stronghold\"\n                },\n                {\n                    fileName: \"870987.data\",\n                    name: \"Battle of Champion's Dusk (0)\"\n                },\n                {\n                    fileName: \"1666233.data\",\n                    name: \"Battle of Champion's Dusk (1)\"\n                },\n                {\n                    fileName: \"132570.data\",\n                    name: \"Heart of the Mists (0)\"\n                },\n                {\n                    fileName: \"197249.data\",\n                    name: \"Heart of the Mists (1)\"\n                },\n                {\n                    fileName: \"1734729.data\",\n                    name: \"Heart of the Mists (2)\"\n                },\n                {\n                    fileName: \"1712986.data\",\n                    name: \"Hall of the Mists\"\n                },\n                {\n                    fileName: \"132710.data\",\n                    name: \"The Battle of Khylo (0)\"\n                },\n                {\n                    fileName: \"197402.data\",\n                    name: \"The Battle of Khylo (1)\"\n                },\n                {\n                    fileName: \"132837.data\",\n                    name: \"Forest of Niflhel (0)\"\n                },\n                {\n                    fileName: \"197545.data\",\n                    name: \"Forest of Niflhel (1)\"\n                },\n                {\n                    fileName: \"376916.data\",\n                    name: \"Legacy of the Foefire\"\n                },\n                {\n                    fileName: \"467374.data\",\n                    name: \"Raid on the Capricorn\"\n                },\n                {\n                    fileName: \"520609.data\",\n                    name: \"Temple of the Silent Storm\"\n                },\n                {\n                    fileName: \"579383.data\",\n                    name: \"Skyhammer (0)\"\n                },\n                {\n                    fileName: \"677968.data\",\n                    name: \"Skyhammer (1)\"\n                },\n                {\n                    fileName: \"1934470.data\",\n                    name: \"Skyhammer (2)\"\n                },\n                {\n                    fileName: \"791564.data\",\n                    name: \"Courtyard (0)\"\n                },\n                {\n                    fileName: \"1713054.data\",\n                    name: \"Courtyard (1)\"\n                },\n                {\n                    fileName: \"556199.data\",\n                    name: \"Spirit Watch (0)\"\n                },\n                {\n                    fileName: \"1473061.data\",\n                    name: \"Spirit Watch (1)\"\n                },\n                {\n                    fileName: \"506539.data\",\n                    name: \"Reaper's Rumble\"\n                },\n                {\n                    fileName: \"529718.data\",\n                    name: \"Snowball Mayhem\"\n                },\n                {\n                    fileName: \"595582.data\",\n                    name: \"Dragon Ball Arena\"\n                },\n                {\n                    fileName: \"617120.data\",\n                    name: \"Aspect Arena\"\n                },\n                {\n                    fileName: \"1644624.data\",\n                    name: \"Revenge of the Capricorn\"\n                },\n                {\n                    fileName: \"1704155.data\",\n                    name: \"Eternal Coliseum\"\n                },\n            ]\n        },\n        {\n            name: \"18. World vs World\",\n            maps: [{\n                    fileName: \"131235.data\",\n                    name: \"Eternal Battlegrounds (0)\"\n                },\n                {\n                    fileName: \"195806.data\",\n                    name: \"Eternal Battlegrounds (1)\"\n                },\n                {\n                    fileName: \"1885693.data\",\n                    name: \"Eternal Battlegrounds (2)\"\n                },\n                {\n                    fileName: \"1918037.data\",\n                    name: \"Eternal Battlegrounds (3)\"\n                },\n                {\n                    fileName: \"131574.data\",\n                    name: \"Alpine Borderlands (0)\"\n                },\n                {\n                    fileName: \"641501.data\",\n                    name: \"Alpine Borderlands (1)\"\n                },\n                {\n                    fileName: \"1799855.data\",\n                    name: \"Alpine Borderlands (2)\"\n                },\n                {\n                    fileName: \"1647236.data\",\n                    name: \"Desert Borderlands (0)\"\n                },\n                {\n                    fileName: \"1799442.data\",\n                    name: \"Desert Borderlands (1)\"\n                },\n                {\n                    fileName: \"736241.data\",\n                    name: \"Edge of the Mists\"\n                },\n            ]\n        },\n        {\n            name: \"19. Guild Halls\",\n            maps: [{\n                    fileName: \"1255378.data\",\n                    name: \"Gilded Hollow\"\n                },\n                {\n                    fileName: \"1256064.data\",\n                    name: \"Lost Precipice\"\n                },\n                {\n                    fileName: \"1843274.data\",\n                    name: \"Windswept Haven\"\n                },\n            ]\n        },\n        {\n            name: \"20. Concept and not released\",\n            maps: [{\n                    fileName: \"122695.data\",\n                    name: \"Empty Plane\"\n                },\n                {\n                    fileName: \"184799.data\",\n                    name: \"Empty Plane v1\"\n                },\n                {\n                    fileName: \"197562.data\",\n                    name: \"Empty Plane v2\"\n                },\n                {\n                    fileName: \"875614.data\",\n                    name: \"Unknown Mists Platforms\"\n                },\n                {\n                    fileName: \"132853.data\",\n                    name: \"Empty Box\"\n                },\n                {\n                    fileName: \"1255516.data\",\n                    name: \"Guild Coliseum\"\n                },\n                {\n                    fileName: \"1498193.data\",\n                    name: \"Concept sPVP Map 1\"\n                },\n                {\n                    fileName: \"1513556.data\",\n                    name: \"Concept sPVP Map 2\"\n                },\n                {\n                    fileName: \"1513607.data\",\n                    name: \"Concept sPVP Map 3\"\n                },\n                {\n                    fileName: \"1513620.data\",\n                    name: \"Concept sPVP Map 4\"\n                },\n                {\n                    fileName: \"1513675.data\",\n                    name: \"Concept sPVP Map 5\"\n                },\n                {\n                    fileName: \"1712945.data\",\n                    name: \"Concept sPVP Map 6\"\n                },\n            ]\n        },\n\n    ]\n}","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/* INCLUDES */\nvar LocalReader = require('./LocalReader/LocalReader');\n\n/* PRIVATE VARS */\nvar _version = \"1.2.0\";\nvar _settings = {\n\tt3dtoolsWorker: \"modules/t3dtools/t3dworker.js\",\n\tconcurrentTasks: (typeof navigator != 'undefined') ? navigator.hardwareConcurrency : 1,\n};\n\n\nlet T3D;\n\n/* PUBLIC PROPERTIES */\n\n\n/**\n * Tyria 3D Library main module.\n * \n * Use this static class to access file parsers- and data renderer classes.\n * \n * This class also works as a factory for creating\n * LocalReader instances that looks up and inflates files from the Guild Wars 2 .dat.\n * @module T3D\n */\nT3D = module.exports = {\n\n\t/**\n\t * The current library version. Used to make sure local storage caches are not\n\t * shared between different releases.\n\t *\n\t * @property version\n\t * @type String\n\t */\n\tversion: _version,\n\n\n\t/* FILES */\n\n\t/**\n\t * A static reference to the GW2File class, the preferred way of\n\t * accessing this class.\n\t *\n\t * @memberof T3D\n\t * @property GW2File\n\t * @type Class\n\t */\n\tGW2File: require(\"./format/file/GW2File\"),\n\n\t/**\n\t * A static reference to the GW2Chunk class, the preferred way of\n\t * accessing this class.\n\t *\n\t * @memberOf T3D\n\t * @property GW2Chunk\n\t * @type Class\n\t */\n\tGW2Chunk: require(\"./format/file/GW2Chunk\"),\n\n\n\t/* RENDERERS */\n\n\t/**\n\t * A static reference to the DataRenderer class, the preferred way of\n\t * accessing this class.\n\t * \n\t * @readonly\n\t * @property DataRenderer\n\t * @type Class\n\t */\n\tDataRenderer: require(\"./dataRenderer/DataRenderer\"),\n\n\t/**\n\t * A static reference to the EnvironmentRenderer class, the preferred way of\n\t * accessing this class.\n\t *\n\t * @readonly\n\t * @property EnvironmentRenderer\n\t * @type Class\n\t */\n\tEnvironmentRenderer: require(\"./dataRenderer/EnvironmentRenderer\"),\n\n\t/**\n\t * A static reference to the HavokRenderer class, the preferred way of\n\t * accessing this class.\n\t * \n\t * @readonly\n\t * @property HavokRenderer\n\t * @type Class\n\t */\n\tHavokRenderer: require(\"./dataRenderer/HavokRenderer\"),\n\n\t/**\n\t * A static reference to the PropertiesRenderer class, the preferred way of\n\t * accessing this class.\n\t *\n\t * @readonly\n\t * @property PropertiesRenderer\n\t * @type Class\n\t */\n\tPropertiesRenderer: require(\"./dataRenderer/PropertiesRenderer\"),\n\n\t/**\n\t * A static reference to the SingleModelRenderer class, the preferred way of\n\t * accessing this class.\n\t *\n\t * @readonly\n\t * @property SingleModelRenderer\n\t * @type Class\n\t */\n\tSingleModelRenderer: require(\"./dataRenderer/SingleModelRenderer\"),\n\n\t/**\n\t * A static reference to the TerrainRenderer class, the preferred way of\n\t * accessing this class.\n\t *\n\t * @readonly\n\t * @property TerrainRenderer\n\t * @type Class\n\t */\n\tTerrainRenderer: require(\"./dataRenderer/TerrainRenderer\"),\n\n\t/**\n\t * A static reference to the ZoneRenderer class, the preferred way of\n\t * accessing this class.\n\t *\n\t * @readonly\n\t * @property ZoneRenderer\n\t * @type Class\n\t */\n\tZoneRenderer: require(\"./dataRenderer/ZoneRenderer\"),\n\n\t/**\n\t * A static reference to the StringRenderer class, the preferred way of\n\t * accessing this class.\n\t *\n\t * @readonly\n\t * @property StringRenderer\n\t * @type Class\n\t */\n\tStringRenderer: require(\"./dataRenderer/StringRenderer\"),\n\n\n\n\n\t/* LOGGING */\n\n\t/**\n\t * A static reference to the static Logger object, the preferred way of\n\t * accessing this object. A simple way of providing your own logging methods\n\t * is to simply overwrite any or all of the logging methods specified in \n\t * {{#crossLink \"Logger/logFunctions:property\"}}{{/crossLink}}\n\t *\n\t * @property Logger\n\t * @type Object\n\t */\n\tLogger: require(\"./Logger\"),\n\n\n\t/* SETTINGS */\n\n\t/**\n\t * Contains a list of known map fileID:s and their names. Used in order to quickly\n\t * look up what maps are in a .dat file. Note that this property is hard coded and\n\t * has high probablity of being outdated. Also note that the names are just guesses\n\t * by RequestTimeout.\n\t *\n\t * The format of this list objects is\n\t *\n\t * \n\t * \t{ \n\t *  \tmaps : [\n\t *\t  \t\t{\n\t *     \t\t\tname:\"World Area Name\",\n\t *\t       \t\tmaps:[\n\t *\t         \t\t{ fileName :\"[numeric fileId].data\", name:\"Map Name One\" },\n\t *\t           \t\t{ fileName :\"[numeric fileId].data\", name:\"Map Name Two\" },\t\t\n\t *\t             \t{ fileName :\"[numeric fileId].data\", name:\"Map Name Three\" }\n\t *\t              ]\n\t *           },\n\t *\t         {\n\t *\t\t\t    name:\"Another World Area Name\",\n\t *\t\t \t   \tmaps:[\n\t *\t\t \t\t   \t{ fileName :\"[numeric fileId].data\", name:\"Map Name 408\" }\n\t *\t\t\t    ]\n\t *\t\t     }\n\t * \t\t]\n\t *   }\n\t *\n\t * @readonly\n\t * @property MapFileList\n\t * @type Object\n\t */\n\tMapFileList: require(\"./MapFileList\"),\n\n\t/* UTILS */\n\n\t/**\n\t * A static reference to the MaterialUtils class.\n\t *\n\t * @readonly\n\t * @property MaterialUtils\n\t * @type Object\n\t */\n\tMaterialUtils: require('./util/MaterialUtils.js'),\n\n\t/**\n\t * A static reference to the MathUtils class.\n\t *\n\t * @readonly\n\t * @property MathUtils\n\t * @type Object\n\t */\n\tMathUtils: require('./util/MathUtils.js'),\n\n\t/**\n\t * A static reference to the ParserUtils class.\n\t *\n\t * @readonly\n\t * @property ParserUtils\n\t * @type Object\n\t */\n\tParserUtils: require('./util/ParserUtils.js'),\n\n\n\t/**\n\t * A static reference to the RenderUtils class.\n\t *\n\t * @readonly\n\t * @property RenderUtils\n\t * @type Object\n\t */\n\tRenderUtils: require('./util/RenderUtils.js'),\n\n\t/**\n\t * A static reference to the PersistantStore class.\n\t * \n\t * @readonly\n\t * @property PersistantStore\n\t * @type Class\n\t */\n\tPersistantStore: require('./LocalReader/PersistantStore'),\n\n\t/**\n\t * A static reference to the FileTypes tools and list.\n\t * \n\t * @readonly\n\t * @property FileTypes\n\t * @type Object\n\t */\n\tFileTypes: require('./LocalReader/FileTypes'),\n\n\t/* PUBLIC METHODS */\n\n\n\t/**\n\t * Creates a new instance of LocalReader with an pNaCl inflater connected to it.\n\t * \n\t * @async\n\t * @param  {File}   \tfile\t\tCore JS File instance, must refer to a GW2 .dat file\n\t * @param  {Function}\tcallback\tCallback function, fired when the file index is fully\n\t *                             \t\tconstructed. Takes no arguments.\n\t *                             \t\t\n\t * @param  {String} \tt3dtoolsWorker URL to the inflater file. If omitted\n\t *                               \t_settings.t3dtoolsWorker will be used instead.\n\t * \n\t * @return {LocalReader}\t\t\tThe contructed LocalReader, note that this object\n\t *                             \t\twill not be fully initialized until the callback\n\t *                             \t\tis fired.\n\t */\n\tgetLocalReader: function (file, callback, t3dtoolsWorker) {\n\n\t\tlet path = (t3dtoolsWorker) ? t3dtoolsWorker : _settings.t3dtoolsWorker;\n\n\t\t//Create the instance and init the threads\n\t\tvar lrInstance = new LocalReader({\n\t\t\tworkerPath: path,\n\t\t\tworkersNb: _settings.concurrentTasks\n\t\t});\n\n\t\t/// Callback with the lrInstance\n\t\tlrInstance.openArchive(file).then(() => {\n\t\t\tcallback(lrInstance);\n\t\t});\n\n\t\treturn lrInstance;\n\t},\n\n\t/**\n\t * Utility method for acceccing a list containing information about all files\n\t * in the .dat connected to the provided LocalReader instance. This method first\n\t * tries to read a local indexing list from the client's localstorage and\n\t * fallbacks to generating the list by scanning the MFT indices of the .dat\n\t * and peeking each file in order to find out what filetype it has.\n\t *\n\t * Note that peeking the files is the time consuming task, so if you don't want\n\t * yout application to spend time indexing the .dat and have a priori knowledge\n\t * about the required file Id's you should not use this method.\n\t * \n\t * @async\n\t * @param  {LocalReader}\tlocalReader A fully initialized LocalReader instance\n\t * @param  {Function}\t\tcallback    Fires when the index has been loaded\n\t *                                 \t\tfrom the localstorage or after it has\n\t *                                 \t\tbeen built and stored in localstorage.\n\t *                                 \t\tTakes the generated object list of\n\t *                                 \t\tfiles as an argument. This list groups\n\t *                                 \t\tarrays of MFT indices per file type,\n\t *                                 \t\tfor exmample:\n\t *\n\t * \n\t * \t{\n\t *\t  \t\"Unknown\"\t: [444, 555, 333],\n\t *\t  \t\"MODL\"\t\t: [444, 555, 333],\n\t * \t  \t\"String\"\t: [666, 777, 888]\n\t * \t}\n\t * \n\t * For more details see\n\t * {{#crossLink \"LocalReader/listFiles:method\"}}{{/crossLink}}\n\t */\n\tgetFileListAsync: function (localReader, callback) {\n\t\t//Because the localreader API changed we reform the data as wanted\n\t\tlocalReader.readFileList().then((result) => {\n\t\t\tlet returnObj = {};\n\t\t\tfor (let fileEntry of result) {\n\t\t\t\tif (returnObj[fileEntry.fileType] === undefined)\n\t\t\t\t\treturnObj[fileEntry.fileType] = [];\n\t\t\t\treturnObj[fileEntry.fileType].push(fileEntry.mftId);\n\t\t\t}\n\t\t\tcallback(returnObj);\n\t\t});\n\t},\n\n\t/**\n\t * Utility method for acceccing a list containing information about all map files\n\t * in the .dat connected to the provided LocalReader instance. This method first\n\t * tries to read a local indexing list from the client's localstorage and\n\t * fallbacks to generating the list by scanning the MFT indices of the .dat\n\t * and peeking each file in order to find out what filetype it has.\n\t *\n\t * If the searchAll flag is not set to true, this process will only scan files\n\t * from the {{#crossLink \"T3D/MapFileList:property\"}}{{/crossLink}}\n\t * \n\t * @async\n\t * @param {LocalReader}\tlocalReader\tA fully initialized LocalReader instance\n\t * @param {Function}\tcallback\tFires when the index has been loaded\n\t *                                 \tfrom the localstorage or after it has\n\t *                                 \tbeen built and stored in localstorage.\n\t *                                 \tTakes the generated object list of\n\t *                                 \tfiles as an argument. This list groups\n\t *                                 \tarrays of MFT indices per file type,\n\t *                                 \tfor exmample:\n\t * \n\t * \t\t{\t\n\t * \t\t\tmaps:[\n\t * \t\t\t\t{\n\t * \t\t\t\t\tname: 'Heart of Maguuma',\n\t * \t\t\t\t\tmaps: [\n\t * \t\t\t\t\t\t{fileName:1151420, name:'HoT BWE3 Raid'},\n\t * \t\t\t\t\t\t{fileName:969663, name:'Verdant Brink}\n\t * \t\t\t\t\t]\n\t * \t\t\t\t},\n\t * \t\t\t\t{\n\t * \t\t\t\t\tname: 'Unknown maps',\n\t * \t\t\t\t\tmaps: [\n\t * \t\t\t\t\t\t{fileName:12345678, name:'Unknown map 12345678'}\n\t * \t\t\t\t\t]\n\t * \t\t\t\t}\n\t * \t\t\t]\n\t \n\t*\t    };\n\t* @param {boolean} searchAll if true forces re-indexing of entire dat.\n\t*/\n\tgetMapListAsync: function (localReader, callback, searchAll) {\n\t\t//Define a function that transforms the localreader output to what we want\n\t\tfunction restoreOuput(array) {\n\t\t\tlet returnArray = [];\n\t\t\tfor (let elt of array) {\n\t\t\t\tlet category = returnArray.findIndex(i => i.name == elt.category)\n\t\t\t\tif (category == -1)\n\t\t\t\t\tcategory = returnArray.push({\n\t\t\t\t\t\tname: elt.category,\n\t\t\t\t\t\tmaps: []\n\t\t\t\t\t}) - 1;\n\t\t\t\treturnArray[category].maps.push({\n\t\t\t\t\tfileName: elt.baseId,\n\t\t\t\t\tname: elt.name\n\t\t\t\t});\n\t\t\t}\n\t\t\t//And resort it in order\n\t\t\treturnArray.sort((i, j) => {\n\t\t\t\tif (i.name < j.name) return -1;\n\t\t\t\tif (i.name > j.name) return 1;\n\t\t\t\treturn 0;\n\t\t\t})\n\t\t\treturn {\n\t\t\t\tmaps: returnArray\n\t\t\t};\n\t\t}\n\n\t\t/// If seachAll flag is true, force a deep search\n\t\tif (searchAll) {\n\t\t\tlocalReader.readFileList().then(() => {\n\t\t\t\tcallback(restoreOuput(localReader.getMapList()));\n\t\t\t})\n\t\t}\n\t\t/// If not, it's only looking through known maps\n\t\telse {\n\t\t\tcallback(restoreOuput(localReader.getMapList()));\n\t\t}\n\n\n\t},\n\n\t/**\n\t * Utility method used for rendering map files. Loads a map file and applies\n\t * the provided renderers to it.\n\t * \n\t * @async\n\t * @param  {LocalReader}\tlocalReader A fully initialized LocalReader instance\n\t * @param  {Number}   \t\tfileName\tThe File Id of a mapc file.\n\t * @param  {Array}   \t\trenderers\tAn array of renderer classes. Each\n\t *                               \t\tclass should extend \n\t *                               \t\t{{#crossLink \"DataRenderer\"}}{{/crossLink}}\n\t * @param  {Function}\t\tcallback    Callback function, takes the shared\n\t *                                 \t\trenderer context as an argument.\n\t * @param  {Class}\t\t\tlogger      A logger class of the same type as\n\t *                               \t\t{{#crossLink \"Logger\"}}{{/crossLink}}\n\t */\n\trenderMapContentsAsync: function (localReader, fileName, renderers, callback, logger) {\n\n\t\t/// VO for storing result from renderers\n\t\tvar context = {};\n\n\t\t/// Make sure we got an actuall ID number\t\t\n\t\tif (parseInt(fileName)) {\n\n\t\t\t/// File name is baseId, load using local reader.\n\t\t\tlocalReader.readFile(parseInt(fileName), false, false, undefined, undefined, true).then((result) => {\n\t\t\t\tlet arrayBuffer = result.buffer;\n\n\t\t\t\t/// Set up datastream\n\t\t\t\tvar ds = new DataStream(arrayBuffer, 0, DataStream.LITTLE_ENDIAN);\n\n\t\t\t\t/// Initiate Map file object. Connect callback\n\t\t\t\tvar mapFile = new T3D.GW2File(ds, 0);\n\n\t\t\t\t/// Populate VO by running the renderers\n\t\t\t\tvar runAllRenderers = function (i) {\n\n\t\t\t\t\t/// Run each renderer\n\t\t\t\t\tif (i < renderers.length) {\n\t\t\t\t\t\tT3D.runRenderer(\n\t\t\t\t\t\t\trenderers[i].renderClass,\n\t\t\t\t\t\t\tlocalReader,\n\t\t\t\t\t\t\tObject.assign(renderers[i].settings, {\n\t\t\t\t\t\t\t\tmapFile: mapFile\n\t\t\t\t\t\t\t}),\n\t\t\t\t\t\t\tcontext,\n\t\t\t\t\t\t\trunAllRenderers.bind(this, i + 1)\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\t/// Fire callback with VO when done\n\t\t\t\t\telse {\n\t\t\t\t\t\tcallback(context);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t/// Starting point for running each renderer\n\t\t\t\trunAllRenderers(0);\n\n\t\t\t});\n\t\t}\n\n\t\t/// Primitive error message...\n\t\telse {\n\t\t\tvar outputLogger = logger ? logger : T3D.Logger;\n\t\t\toutputLogger.log(\n\t\t\t\tT3D.Logger.TYPE_ERROR,\n\t\t\t\t\"Map id must be an integer!, was:\", fileName\n\t\t\t);\n\t\t}\n\t},\n\n\t/**\n\t * Utility method for applying a single renderer to a LocalReader insatnce.\n\t * \n\t * @async\n\t * \n\t * @param  {Class}\t\trenderClass\tA class extending \n\t *                                \t{{#crossLink \"DataRenderer\"}}{{/crossLink}}\n\t * @param  {LocalReader}localReader A fully initialized LocalReader instance\n\t * @param  {Object}\t\tsettings    Settings passed to the renderer. Often\n\t *                               \tspecifies thinks like what file ID should\n\t *                               \tbe loaded.\n\t * @param  {Object}\t\tcontext     The shared renderer context value object.\n\t * @param  {Function} \tcb          Callback method passed to the renderAsync\n\t *                                 \tmethod of the renderer.\n\t */\n\trunRenderer: function (renderClass, localReader, settings, context, cb) {\n\t\tvar r = new renderClass(\n\t\t\tlocalReader,\n\t\t\tsettings,\n\t\t\tcontext\n\t\t);\n\n\t\tr.renderAsync(cb);\n\t},\n\n\n\t/**\n\t * @param  {Object} context      \tA shared renderer context value object.\n\t * @param  {Class} \tclazz        \tA class extending\n\t *                                \t{{#crossLink \"DataRenderer\"}}{{/crossLink}}.\n\t *                                \tSpecifies for renderer class you want to read \n\t *                                \toutput.\n\t * @param  {String} propName     \tThe name of the property written by the\n\t *                                \trenderer that should retrtieved.\n\t * @param  {any} \tdefaultValue \tThis value is passed back if no data could\n\t *                              \tbe found.\n\t * @return {any}    \t\t\t\tThe specified value from the conext if any,\n\t *                          \t\totherwise defaultValue.\n\t */\n\tgetContextValue: function (context, clazz, propName, defaultValue) {\n\t\tvar output = context[clazz.name];\n\t\tif (output) {\n\t\t\treturn output[propName] ? output[propName] : defaultValue;\n\t\t}\n\t\treturn defaultValue;\n\t},\n\n\t/**\n\t * Check if the client web browser can render WebGL 3D content.\n\t * \n\t * @private\n\t * @param  {boolean} return_context flag making this method return the canvas object instead of true\n\t * @return {boolean} true if the client is WebGL enabled, false otherwise\n\t */\n\thasWebGL: function (return_context) {\n\t\tif (!!window.WebGLRenderingContext) {\n\t\t\tvar canvas = document.createElement(\"canvas\"),\n\t\t\t\tnames = [\"webgl\", \"experimental-webgl\", \"moz-webgl\", \"webkit-3d\"],\n\t\t\t\tcontext = false;\n\n\t\t\tfor (var i = 0; i < 4; i++) {\n\t\t\t\ttry {\n\t\t\t\t\tcontext = canvas.getContext(names[i]);\n\t\t\t\t\tif (context && typeof context.getParameter == \"function\") {\n\t\t\t\t\t\t// WebGL is enabled\n\t\t\t\t\t\tif (return_context) {\n\t\t\t\t\t\t\t// return WebGL object if the function's argument is present\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tname: names[i],\n\t\t\t\t\t\t\t\tgl: context\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// else, return just true\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t} catch (e) {}\n\t\t\t}\n\n\t\t\t// WebGL is supported, but disabled\n\t\t\treturn false;\n\t\t}\n\n\t\t// WebGL not supported\n\t\treturn false;\n\t}\n\n};\n\n/* PRIVATE METHODS */\n\n/**\n * Performs checks for required browser capabilities and required third party libraries.\n * Loggs any warnings or error messages.\n * \n * @private\n * @return {Number} The ammount of errors and warnings generated.\n */\nfunction checkRequirements() {\n\tvar numErrors = 0;\n\n\tif (!global.window || !window.indexedDB) {\n\t\tT3D.Logger.log(\n\t\t\tT3D.Logger.TYPE_ERROR,\n\t\t\t\"T3D persistant storing and loading requires indexedDB support.\"\n\t\t);\n\t\tnumErrors++;\n\t}\n\n\tif (typeof DataStream === \"undefined\") {\n\t\tT3D.Logger.log(\n\t\t\tT3D.Logger.TYPE_ERROR,\n\t\t\t\"T3D core functionality requires DataStream library.\"\n\t\t);\n\t\tnumErrors++;\n\t}\n\n\tif (typeof THREE === \"undefined\") {\n\t\tT3D.Logger.log(\n\t\t\tT3D.Logger.TYPE_WARNING,\n\t\t\t\"T3D mesh generation requires three.js library.\"\n\t\t);\n\t\tnumErrors++;\n\t}\n\n\tif (numErrors < 1) {\n\t\tT3D.Logger.log(\n\t\t\tT3D.Logger.TYPE_MESSAGE,\n\t\t\t\"Tyria 3D API v\" + T3D.version + \" initialized.\"\n\t\t);\n\t}\n\n\treturn numErrors;\n}\n\n/**\n * Performs a quick and dirty check to find what chunk name definitions \n * appear multiple times in th formats array. Note that anything that\n * appears more than 2 times wil get a too hight value due to the \n * algorithm being... incorrect.\n *\n * @private\n * @return {Object} An object mapping duplicate chunk definition names.\n * to the number of apperances.\n */\nfunction findDuplicateChunkDefs() {\n\tvar dups = {};\n\tT3D.formats.forEach(\n\t\tfunction (f1) {\n\n\t\t\tT3D.formats.forEach(\n\t\t\t\tfunction (f2) {\n\t\t\t\t\tif (f2.name == f1.name && f2 !== f1) {\n\t\t\t\t\t\tif (dups[f1.name]) {\n\t\t\t\t\t\t\tdups[f1.name]++;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdups[f1.name] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t);\n\treturn dups\n}\n\n/// Library checks requirements on startup\ncheckRequirements();","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst GW2File = require('../format/file/GW2File');\n\n/**\n * Base class for data interpretors a.k.a. 'Renderers'\n *\n * Renderers are classes that collect and interpret data from the dat file.\n * \n * A {{#crossLink \"LocalReader\"}}{{/crossLink}} instance is used for accessing data from the dat.\n * \n * A {{#crossLink \"Logger\"}}{{/crossLink}} is used for posting progress output or error messages.\n *\n * Most Renderers use one or more\n * {{#crossLink \"GW2Chunk\"}}GW2Chunks{{/crossLink}}, typed data structures that can be read from\n * {{#crossLink \"GW2File\"}}GW2Files{{/crossLink}}.\n *\n * The generated data, be it strings, numbers or meshes are put into a value object structure called\n * the 'context'. The context can store data generated by multiple renderers and makes sure each\n * renderer type, or class has it's own value object within the context. This enables one renderer\n * to read data written by another renderer wihtout having to worry about overwriting existing data\n * within the context. Keep in mind that you will have to manually pass and clean the conext object!\n *\n * A clean context object should just be the empty javasript object : {}.\n *\n * When a Renderer is done it will fire the callback and any view interrested in retrieving the generated\n * data from the context can read it using\n * {{#crossLink \"T3D/getContextValue:method\"}}{{/crossLink}}.\n * \n * \n * \n * \n * @class DataRenderer\n * @constructor\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nclass DataRenderer {\n\tconstructor(localReader, settings, context, logger) {\n\n\t\t/// Just storing parameters\n\t\tthis.localReader = localReader;\n\t\tthis.settings = settings;\n\t\tif (!settings) {\n\t\t\tsettings = {};\n\t\t}\n\t\tthis.context = context;\n\t\tthis.context[this.constructor.name] = {};\n\n\t\tif (logger)\n\t\t\tthis.logger = logger;\n\t\telse\n\t\t\tthis.logger = T3D.Logger;\n\t}\n\n\t/**\n\t * Gets the output value object for a specified class within the context.\n\t * \n\t * @param  {Class} otherClass The class to fetch the output value object for.\n\t * If not specified the class of this instance will be used.\n\t * @return {Object}            The output value object for this class within the context.\n\t */\n\tgetOutput(otherClass) {\n\t\treturn this.context[otherClass ? otherClass.name : this.constructor.name];\n\t}\n\n\t/**\n\t * Basic rendering of unknown files. Output fileds generated:\n\t *\n\t * - *fileId* The fileId passed in the settings parameter when constructing this instance.\n\t * \n\t * - *rawData* An ArrayBuffer containg the infalted binary data of the loaded file.\n\t * \n\t * - *rawString* A string representation of the rawData\n\t * \n\t * - *image* A value object witht he fields 'width', 'height' and 'data' describing a RGBA bitmap\n\t * image. Only set if the loaded file was a texture.\n\t * \n\t * - *file* A GW2File representation of the loaded file. Only set if the loaded file was a Pack File.\n\t * \n\t * @async\n\t * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n\t */\n\trenderAsync(callback) {\n\t\tthis.localReader.readFile(this.settings.id, false, false, undefined, undefined, true).then((result) => {\n\t\t\tlet inflatedData = result.buffer;\n\n\t\t\t/// Set fileId so callers can identify this VO\t\t\n\t\t\tthis.getOutput().fileId = this.settings.id;\n\n\t\t\t/// Share inflated data\n\t\t\tthis.getOutput().rawData = inflatedData;\n\n\t\t\t/// Construct raw string\n\t\t\tvar uarr = new Uint8Array(inflatedData);\n\t\t\tlet textDecoder = new TextDecoder('latin2');\n\t\t\tthis.getOutput().rawString = textDecoder.decode(uarr);\n\n\n\t\t\t/// Check if this is an PF or ATEX file\n\t\t\t// Binareis are MZ\n\t\t\tvar ds = new DataStream(inflatedData);\n\t\t\tvar first4 = ds.readCString(4);\n\n\t\t\t/// Do special stuff for different fcc signatures\n\t\t\t/// \n\t\t\t/// fourcc != fcc::ATEX && fourcc != fcc::ATEC && fourcc != fcc::ATEP &&\n\t\t\t/// fourcc != fcc::ATET && fourcc != fcc::ATEU && fourcc != fcc::ATTX)\n\t\t\t/// \n\t\t\tif (first4 == \"ATEX\" || first4 == \"ATEC\" ||\n\t\t\t\tfirst4 == \"ATEP\" || first4 == \"ATET\" ||\n\t\t\t\tfirst4 == \"ATEU\" || first4 == \"ATTX\") {\n\n\t\t\t\tthis.localReader.readFile(this.settings.id, true, false, undefined, undefined, true).then((result) => {\n\t\t\t\t\t/// Create image using returned data.\n\t\t\t\t\tvar image = {\n\t\t\t\t\t\tdata: new Uint8Array(result.buffer),\n\t\t\t\t\t\twidth: result.imageWidth,\n\t\t\t\t\t\theight: result.imageHeight\n\t\t\t\t\t};\n\n\t\t\t\t\tthis.getOutput().image = image;\n\t\t\t\t\tcallback();\n\t\t\t\t});\n\n\t\t\t} else if (first4.indexOf(\"PF\") == 0) {\n\t\t\t\tthis.getOutput().file = new GW2File(ds, 0);\n\t\t\t\tcallback();\n\t\t\t} else {\n\t\t\t\tthis.getOutput().file = null;\n\t\t\t\tcallback();\n\t\t\t}\n\n\t\t});\n\t}\n}\n\nmodule.exports = DataRenderer;","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst MapEnvUtils = require(\"../util/MapEnvUtils\");\nconst DataRenderer = require('./DataRenderer');\n\n/**\n *\n * A renderer that generates some of the environment objects of a map.\n * \n * @class EnvironmentRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"mapFile\", a GW2File.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nclass EnvironmentRenderer extends DataRenderer {\n\tconstructor(localReader, settings, context, logger) {\n\t\tsuper(localReader, settings, context, logger);\n\n\t\tthis.mapFile = this.settings.mapFile;\n\n\t}\n\n\t/**\n\t * Output fileds generated:\n\t *\n\t * - *hazeColor* Array of RGBA values describing the global haze color of the map.\n\t * - *lights* An array of THREE.DirectionalLight and  THREE.AmbientLight objects.\n\t * - *hasLight* Boolean is false if no directional lights were added to \"lights\".\n\t * - *skyElements* A textured THREE.Mesh skybox.\n\t * \n\t * @async\n\t * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n\t */\n\trenderAsync(callback) {\n\n\t\tvar environmentChunkData = this.mapFile.getChunk(\"env\").data;\n\t\tvar parameterChunkData = this.mapFile.getChunk(\"parm\").data;\n\n\t\t/// Set renderer clear color from environment haze\n\t\tvar hazeColor = MapEnvUtils.getHazeColor(environmentChunkData);\n\t\tvar hazeColorAsInt = hazeColor[2] * 256 * 256 + hazeColor[1] * 256 + hazeColor[0];\n\t\tthis.getOutput().hazeColor = hazeColor;\n\n\t\t/// Add directional lights to output. Also write hasLight flag\n\t\tlet lightData = MapEnvUtils.parseLights(environmentChunkData);\n\t\tthis.getOutput().hasLight = lightData.hasLight;\n\t\tthis.getOutput().lights = lightData.lights;\n\n\t\t/// Generate skybox\n\t\tthis.getOutput().skyElements = MapEnvUtils.parseSkybox(\n\t\t\tenvironmentChunkData, parameterChunkData, hazeColorAsInt,\n\t\t\t//TODO: Move outside of library\n\t\t\t[\"img/193068.png\", \"img/193070.png\", \"img/193072.png\"],\n\t\t\tthis.localReader\n\t\t).skyElements;\n\n\t\t/// All parsing is synchronous, just fire callback\n\t\tcallback();\n\t}\n}\n\n\nmodule.exports = EnvironmentRenderer;","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst DataRenderer = require('./DataRenderer');\n\n/**\n *\n * A renderer that generates meshes describing the collisions of a map.\n * \n * @class HavokRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"mapFile\", a GW2File. If \"visible\" is specified and true, the generated meshes will be textured\n * with a MeshNormalMaterial, otherwise they will not be visible.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\n\nclass HavokRenderer extends DataRenderer {\n\tconstructor(localReader, settings, context, logger) {\n\t\tsuper(localReader, settings, context, logger);\n\n\t\tthis.mapFile = this.settings.mapFile;\n\n\t\tthis.lastP = -1;\n\t\tthis.seed = 1;\n\t\tthis.meshes = [];\n\n\t\t/**\n\t\t * TODO\n\t\t * \n\t\t * @param  {Function} callback         [description]\n\t\t * @async\n\t\t */\n\t\tthis.renderModels = function (models, title, callback) {\n\t\t\tvar mat;\n\t\t\tif (this.settings && this.settings.visible) {\n\t\t\t\tmat = new THREE.MeshNormalMaterial({\n\t\t\t\t\tside: THREE.DoubleSide\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tmat = new THREE.MeshBasicMaterial({\n\t\t\t\t\tvisible: false\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis.parseAllModels(models, mat, title, 200, 0, callback);\n\t\t}\n\n\n\t\t/**\n\t\t * TODO\n\t\t * \n\t\t * @param  {*} animation  [description]\n\t\t * @param  {*} collisions [description]\n\t\t * @return {*}            [description]\n\t\t */\n\t\tthis.getCollisionsForAnimation = function (animation, collisions) {\n\t\t\tvar ret = [];\n\n\t\t\tfor (var i = 0; i < animation.collisionIndices.length; i++) {\n\t\t\t\tvar index = animation.collisionIndices[i];\n\t\t\t\tvar collision = collisions[index];\n\t\t\t\tcollision.index = index;\n\t\t\t\tret.push(collision);\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t};\n\n\t\t/**\n\t\t * TODO\n\t\t * \n\t\t * @param  {*} models       [description]\n\t\t * @param  {*} mat       [description]\n\t\t * @param  {*} title     [description]\n\t\t * @param  {*} chunkSize [description]\n\t\t * @param  {*} offset    [description]\n\t\t * @return {*} callback          [description]\n\t\t * @async\n\t\t */\n\t\tthis.parseAllModels = function (models, mat, title, chunkSize, offset, callback) {\n\t\t\tvar i = offset;\n\n\t\t\tfor (; i < offset + chunkSize && i < models.length; i++) {\n\n\t\t\t\tvar p = Math.round(i * 100 / models.length);\n\t\t\t\tif (p != this.lastP) {\n\n\t\t\t\t\tthis.logger.log(\n\t\t\t\t\t\tT3D.Logger.TYPE_PROGRESS,\n\t\t\t\t\t\t\"Loading Collision Models (\" + title + \")\",\n\t\t\t\t\t\tp\n\t\t\t\t\t);\n\t\t\t\t\tthis.lastP = p;\n\t\t\t\t}\n\n\t\t\t\t/// Get animation object\n\t\t\t\tvar animation = this.animationFromGeomIndex(\n\t\t\t\t\tmodels[i].geometryIndex,\n\t\t\t\t\tthis.geometries,\n\t\t\t\t\tthis.animations\n\t\t\t\t);\n\n\t\t\t\tvar collisions = this.getCollisionsForAnimation(animation, this.havokChunkData.collisions);\n\n\t\t\t\tfor (var j = 0; j < collisions.length; j++) {\n\t\t\t\t\tvar collision = collisions[j];\n\t\t\t\t\tthis.renderMesh(collision, models[i], mat);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (i < models.length) {\n\t\t\t\twindow.setTimeout(\n\t\t\t\t\tthis.parseAllModels.bind(this, models, mat, title, chunkSize, offset + chunkSize, callback),\n\t\t\t\t\t10 /*time in ms to next call*/\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tcallback();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * TODO\n\t\t * \n\t\t * @param  {*} propGeomIndex [description]\n\t\t * @param  {*} geometries    [description]\n\t\t * @param  {*} animations    [description]\n\t\t * @return {*}               [description]\n\t\t */\n\t\tthis.animationFromGeomIndex = function (propGeomIndex, geometries, animations) {\n\n\t\t\t// geometries is just list of all geometries.animations[end] for now\n\t\t\tvar l = geometries[propGeomIndex].animations.length;\n\n\t\t\treturn animations[geometries[propGeomIndex].animations[l - 1]];\n\t\t\t//return animations[ geometries[propGeomIndex].animations[0] ];\n\t\t};\n\n\t\t/**\n\t\t * TODO\n\t\t * \n\t\t * @param  {*} collision [description]\n\t\t * @param  {*} model     [description]\n\t\t * @param  {*} mat       [description]\n\t\t * @return {*}           [description]\n\t\t */\n\t\tthis.renderMesh = function (collision, model, mat) {\n\n\t\t\tvar pos = model.translate;\n\t\t\tvar rot = model.rotate;\n\t\t\tvar scale = 32 * model.scale;\n\n\t\t\t/// Generate mesh\n\t\t\tvar mesh = this.parseHavokMesh(collision, mat);\n\n\t\t\t/// Position mesh\n\t\t\t/// \"x\",\"float32\",\"z\",\"float32\",\"y\",\"float32\"\n\t\t\tmesh.position.set(pos[0], -pos[2], -pos[1]);\n\n\t\t\t/// Scale mesh\n\t\t\tif (scale)\n\t\t\t\tmesh.scale.set(scale, scale, scale);\n\n\t\t\t/// Rotate mesh\n\t\t\tif (rot) {\n\t\t\t\tmesh.rotation.order = \"ZXY\";\n\n\t\t\t\t// [\"x\",\"float32\",\"z\",\"float32\",\"y\",\"float32\"], \n\t\t\t\tmesh.rotation.set(rot[0], -rot[2], -rot[1]);\n\t\t\t}\n\n\t\t\t/// Add mesh to scene and collisions\n\t\t\tthis.getOutput().meshes.push(mesh);\n\t\t};\n\n\n\t\t/**\n\t\t * TODO\n\t\t * \n\t\t * @return {*} [description]\n\t\t */\n\t\tthis.seedRandom = function () {\n\t\t\tvar x = Math.sin(this.seed++) * 10000;\n\t\t\treturn x - Math.floor(x);\n\t\t};\n\n\t\t/**\n\t\t * TODO\n\t\t * \n\t\t * @param  {*} collision [description]\n\t\t * @param  {*} mat       [description]\n\t\t * @return {*}           [description]\n\t\t */\n\t\tthis.parseHavokMesh = function (collision, mat) {\n\n\t\t\tvar index = collision.index;\n\n\t\t\tif (!this.meshes[index]) {\n\n\t\t\t\tvar geom = new THREE.Geometry();\n\n\t\t\t\t/// Pass vertices\t    \t\t\n\t\t\t\tfor (var i = 0; i < collision.vertices.length; i++) {\n\t\t\t\t\tvar v = collision.vertices[i];\n\t\t\t\t\t//\"x\",\"float32\",\"z\",\"float32\",\"y\",\"float32\"]\n\t\t\t\t\tgeom.vertices.push(new THREE.Vector3(v[0], v[2], -v[1]));\n\t\t\t\t}\n\n\t\t\t\t/// Pass faces\n\t\t\t\tfor (var i = 0; i < collision.indices.length; i += 3) {\n\n\t\t\t\t\tvar f1 = collision.indices[i];\n\t\t\t\t\tvar f2 = collision.indices[i + 1];\n\t\t\t\t\tvar f3 = collision.indices[i + 2];\n\n\t\t\t\t\tif (f1 <= collision.vertices.length &&\n\t\t\t\t\t\tf2 <= collision.vertices.length &&\n\t\t\t\t\t\tf3 <= collision.vertices.length) {\n\t\t\t\t\t\tgeom.faces.push(new THREE.Face3(f1, f2, f3));\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.logger.log(\n\t\t\t\t\t\t\tT3D.Logger.TYPE_ERROR,\n\t\t\t\t\t\t\t\"Errorus index in havok model geometry.\"\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/// Prepare geometry and pass new mesh\n\t\t\t\tgeom.computeFaceNormals();\n\t\t\t\t//geom.computeVertexNormals();\n\n\t\t\t\tthis.meshes[index] = new THREE.Mesh(geom, mat);\n\n\t\t\t\treturn this.meshes[index];\n\t\t\t} else {\n\t\t\t\treturn this.meshes[index].clone();\n\t\t\t}\n\t\t};\n\n\t}\n\n\t/**\n\t * Output fileds generated:\n\t *\n\t * - *boundingBox* Array of values describing the bounding box of all collision.\n\t * - *meshes* An array of THREE.Mesh objects visualizing all collision in the map.\n\t * \n\t * @async\n\t * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n\t */\n\trenderAsync(callback) {\n\t\tvar self = this;\n\n\t\t// TODO:The design of this method pretty much requires one instance\n\t\t// of the class per parallel async render. Should probably fix this\n\t\t// at some point...\n\n\t\t/// Get required chunks\n\t\tthis.havokChunkData = this.mapFile.getChunk(\"havk\").data;\n\n\t\t/// Set static bounds to the bounds of the havk models\n\t\tthis.getOutput().boundingBox = this.havokChunkData.boundsMax;\n\n\t\t/// Clear old meshes\n\t\tthis.meshes = [];\n\n\t\t/// Set up output array\n\t\tthis.getOutput().meshes = [];\n\n\t\t/// Grab model raw data from the chunk.\n\t\t/// Add missing scale value to obs models.\n\t\tvar propModels = this.havokChunkData.propModels;\n\t\tvar zoneModels = this.havokChunkData.zoneModels;\n\t\tvar obsModels = this.havokChunkData.obsModels;\n\t\tobsModels.forEach(function (mdl) {\n\t\t\tmdl.scale = 1;\n\t\t});\n\n\t\t/// Store geoms and animations from the file in hte instance so we don't\n\t\t/// have to pass them arround too much. (fix this later)\n\t\tthis.geometries = this.havokChunkData.geometries;\n\t\tthis.animations = this.havokChunkData.animations;\n\n\t\t/// Render \"prop\", \"zone\" and \"obs\" models in that order.\n\t\tvar renderPropModelsCB = function () {\n\t\t\tself.renderModels(zoneModels, \"zone\", renderZoneModelsCB);\n\t\t};\n\t\tvar renderZoneModelsCB = function () {\n\t\t\tself.renderModels(obsModels, \"obs\", callback);\n\t\t};\n\t\tself.renderModels(propModels, \"prop\", renderPropModelsCB);\n\n\t}\n}\n\nmodule.exports = HavokRenderer;","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst ModelUtils = require(\"../util/ModelUtils\");\nconst DataRenderer = require('./DataRenderer');\n\n/**\n *\n * A renderer that generates property models for a map.\n * \n * @class PropertiesRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"mapFile\", a GW2File.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\n\nclass PropertiesRenderer extends DataRenderer {\n\tconstructor(localReader, settings, context, logger) {\n\t\tsuper(localReader, settings, context, logger);\n\n\t\tthis.mapFile = this.settings.mapFile;\n\t}\n\n\t/**\n\t * Renders all property meshes in a GW2 map described by the map's PROP chunk.\n\t * Output fileds generated:\n\t *\n\t * - *meshes* An array of THREE.Mesh objects visualizing all property models refered by this map.\n\t * \n\t * @async\n\t * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n\t */\n\trenderAsync(callback) {\n\t\tvar self = this;\n\n\t\tself.getOutput().meshes = [];\n\n\t\tvar propertiesChunkData = this.mapFile.getChunk(\"prp2\").data;\n\n\t\tif (!propertiesChunkData) {\n\t\t\trenderCallback();\n\t\t\treturn;\n\t\t}\n\n\t\tvar props = propertiesChunkData.propArray;\n\t\tvar animProps = propertiesChunkData.propAnimArray;\n\t\tvar instanceProps = propertiesChunkData.propInstanceArray;\n\t\tvar metaProps = propertiesChunkData.propMetaArray;\n\n\t\t/// Concat all prop types\n\t\tprops = props\n\t\t\t.concat(animProps)\n\t\t\t.concat(instanceProps)\n\t\t\t.concat(metaProps);\n\n\t\t/// Create mesh cache\n\t\tself.meshCache = {};\n\t\tself.textureCache = {};\n\n\t\t// For now, we'll do all load in serial\n\t\t// TODO: load unique meshes and textures in parallell (asynch), then render!\n\t\tvar lastPct = -1;\n\n\t\tvar renderIndex = function (idx) {\n\n\t\t\tif (idx >= props.length) {\n\n\t\t\t\t/// Empty mesh cache\n\t\t\t\tself.meshCache = {};\n\t\t\t\tself.textureCache = {};\n\t\t\t\tcallback();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar pct = Math.round(1000.0 * idx / props.length);\n\t\t\tpct /= 10.0;\n\n\t\t\t/// Log progress\n\t\t\tif (lastPct != pct) {\n\t\t\t\tvar pctStr = pct +\n\t\t\t\t\t(pct.toString().indexOf(\".\") < 0 ? \".0\" : \"\");\n\n\t\t\t\tself.logger.log(\n\t\t\t\t\tT3D.Logger.TYPE_PROGRESS,\n\t\t\t\t\t\"Loading 3D Models (Props)\", pctStr\n\t\t\t\t);\n\t\t\t\tlastPct = pct;\n\t\t\t}\n\n\t\t\t/// Read prop at index.\n\t\t\tvar prop = props[idx];\n\n\t\t\t/// Adds a single mesh to a group.\n\t\t\tvar addMeshToLOD = function (mesh, groups, lod, prop, needsClone) {\n\n\t\t\t\t/// Read lod distance before overwriting mesh variable\n\t\t\t\tvar lodDist = prop.lod2 != 0 ? prop.lod2 : mesh.lodOverride[1];\n\n\t\t\t\t/// Read flags before overwriting mesh variable\n\t\t\t\tvar flags = mesh.flags;\n\n\t\t\t\t/// Mesh flags are 0 1 4\n\t\t\t\t/// For now, use flag 0 as the default level of detail\n\t\t\t\tif (flags == 0)\n\t\t\t\t\tlodDist = 0;\n\n\t\t\t\t/// Create new empty mesh if needed\n\t\t\t\tif (needsClone) {\n\t\t\t\t\tmesh = new THREE.Mesh(mesh.geometry, mesh.material);\n\t\t\t\t}\n\n\t\t\t\tmesh.updateMatrix();\n\t\t\t\tmesh.matrixAutoUpdate = false;\n\n\t\t\t\t// Find group for this LOD distance\n\t\t\t\tif (groups[lodDist]) {\n\t\t\t\t\tgroups[lodDist].add(mesh);\n\t\t\t\t}\n\t\t\t\t// Or create LOD group and add to a level of detail\n\t\t\t\t// WIP, needs some testing!\n\t\t\t\telse {\n\t\t\t\t\tvar group = new THREE.Group();\n\t\t\t\t\tgroup.updateMatrix();\n\t\t\t\t\tgroup.matrixAutoUpdate = false;\n\t\t\t\t\tgroup.add(mesh);\n\t\t\t\t\tgroups[lodDist] = group;\n\t\t\t\t\tlod.addLevel(group, lodDist);\n\t\t\t\t}\n\n\t\t\t\treturn lodDist;\n\t\t\t}\n\n\t\t\t/// Adds array of meshes to the scene, also adds transform clones\n\t\t\tvar addMeshesToScene = function (meshArray, needsClone, boundingSphere) {\n\n\t\t\t\t///Add original \n\n\t\t\t\t/// Make LOD object and an array of groups for each LOD level\n\t\t\t\tvar groups = {};\n\t\t\t\tvar lod = new THREE.LOD();\n\n\t\t\t\t/// Each mesh is added to a group corresponding to its LOD distane\n\t\t\t\tvar maxDist = 0;\n\t\t\t\tmeshArray.forEach(function (mesh) {\n\t\t\t\t\tmaxDist = Math.max(maxDist, addMeshToLOD(mesh, groups, lod, prop, needsClone));\n\t\t\t\t});\n\n\t\t\t\t/// Add invisible level (the raycaster crashes on lod without any levels)\n\t\t\t\tlod.addLevel(new THREE.Group(), 100000);\n\n\t\t\t\t/// Set position, scale and rotation of the LOD object\n\t\t\t\tif (prop.rotation) {\n\t\t\t\t\tlod.rotation.order = \"ZXY\";\n\t\t\t\t\t//[\"x\",\"float32\",\"z\",\"float32\",\"y\",\"float32\"],\n\t\t\t\t\tlod.rotation.set(prop.rotation[0], -prop.rotation[2], -prop.rotation[1]);\n\t\t\t\t}\n\t\t\t\tlod.scale.set(prop.scale, prop.scale, prop.scale);\n\t\t\t\tlod.position.set(prop.position[0], -prop.position[2], -prop.position[1]);\n\n\n\t\t\t\tlod.boundingSphereRadius = (boundingSphere && boundingSphere.radius ? boundingSphere.radius : 1.0) * prop.scale;\n\n\t\t\t\tlod.updateMatrix();\n\t\t\t\tlod.matrixAutoUpdate = false;\n\n\t\t\t\t/// Show highest level always\n\t\t\t\t//lod.update(lod);\n\n\t\t\t\t//Add LOD containing mesh instances to scene\n\t\t\t\tself.getOutput().meshes.push(lod);\n\n\t\t\t\t// Add one copy per transform, needs to be within it's own LOD\n\t\t\t\tif (prop.transforms) {\n\n\t\t\t\t\tprop.transforms.forEach(function (transform) {\n\n\t\t\t\t\t\t/// Make LOD object and an array of groups for each LOD level\n\t\t\t\t\t\tvar groups = {};\n\t\t\t\t\t\tvar lod = new THREE.LOD();\n\n\t\t\t\t\t\t/// Each mesh is added to a group corresponding to its LOD distane\n\t\t\t\t\t\tvar maxDist = 0;\n\t\t\t\t\t\tmeshArray.forEach(function (mesh) {\n\t\t\t\t\t\t\tmaxDist = Math.max(maxDist, addMeshToLOD(mesh, groups, lod, prop, true));\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t/// Add invisible level\n\t\t\t\t\t\t//lod.addLevel(new THREE.Group(),10000);\n\n\t\t\t\t\t\t/// Set position, scale and rotation of the LOD object\n\t\t\t\t\t\tif (transform.rotation) {\n\t\t\t\t\t\t\tlod.rotation.order = \"ZXY\";\n\t\t\t\t\t\t\tlod.rotation.set(transform.rotation[0], -transform.rotation[2], -transform.rotation[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlod.scale.set(transform.scale, transform.scale, transform.scale);\n\t\t\t\t\t\tlod.position.set(transform.position[0], -transform.position[2], -transform.position[1]);\n\n\t\t\t\t\t\tlod.updateMatrix();\n\t\t\t\t\t\tlod.matrixAutoUpdate = false;\n\n\t\t\t\t\t\tlod.boundingSphereRadius = (boundingSphere && boundingSphere.radius ? boundingSphere.radius : 1.0) * prop.scale;\n\n\t\t\t\t\t\t/// Show highest level always\n\t\t\t\t\t\tlod.update(lod);\n\n\t\t\t\t\t\t/// Add LOD containing mesh instances to scenerender: function(propertiesChunkHeader, map, localReader, renderCallback){\n\t\t\t\t\t\tself.getOutput().meshes.push(lod);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/// Get meshes\n\t\t\tvar showUnmaterialed = false;\n\t\t\tModelUtils.getMeshesForFilename(prop.filename, prop.color, self.localReader, self.meshCache, self.textureCache, showUnmaterialed, false,\n\t\t\t\tfunction (meshes, isCached, boundingSphere) {\n\n\t\t\t\t\tif (meshes) {\n\t\t\t\t\t\taddMeshesToScene(meshes, isCached, boundingSphere);\n\t\t\t\t\t}\n\n\t\t\t\t\t/// Render next prop\n\t\t\t\t\trenderIndex(idx + 1);\n\t\t\t\t}\n\t\t\t);\n\n\n\n\t\t};\n\n\t\t/// Start serial loading and redering. (to allow re-using meshes and textures)\n\t\trenderIndex(0);\n\t}\n\n\n\t/**\n\t * TODO: write description. Used for export feature\n\t * @param  {Function} callback [description]\n\t * @return {*}            [description]\n\t */\n\tgetFileIdsAsync(callback) {\n\t\tvar fileIds = [];\n\n\t\tvar propertiesChunkData = this.mapFile.getChunk(\"prp2\").data;\n\n\t\tvar props = propertiesChunkData.propArray;\n\t\tvar animProps = propertiesChunkData.propAnimArray;\n\t\tvar instanceProps = propertiesChunkData.propInstanceArray;\n\t\tvar metaProps = propertiesChunkData.propMetaArray;\n\n\t\tprops = props\n\t\t\t.concat(animProps)\n\t\t\t.concat(instanceProps)\n\t\t\t.concat(metaProps);\n\n\t\tvar getIdsForProp = function (idx) {\n\n\t\t\tif (idx >= props.length) {\n\t\t\t\tcallback(fileIds);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (idx % 100 == 0) {\n\n\t\t\t\tthis.logger.log(\n\t\t\t\t\tT3D.Logger.TYPE_MESSAGE,\n\t\t\t\t\t\"getting ids for entry\", idx, \"of\", props.length\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tvar prop = props[idx];\n\t\t\tUtils.getFilesUsedByModel(\n\t\t\t\tprop.filename,\n\t\t\t\tlocalReader,\n\t\t\t\tfunction (propFileIds) {\n\t\t\t\t\tfileIds = fileIds.concat(propFileIds);\n\t\t\t\t\tgetIdsForProp(idx + 1);\n\t\t\t\t}\n\t\t\t);\n\n\t\t};\n\n\t\tgetIdsForProp(0);\n\t}\n}\n\nmodule.exports = PropertiesRenderer;","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst ModelUtils = require(\"../util/ModelUtils\");\nconst DataRenderer = require('./DataRenderer');\n\n/**\n *\n * A renderer that generates meshes for a single model file.\n * \n * @class SingleModelRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"id\" the base ID or file ID of the model to generate meshes for.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nclass SingleModelRenderer extends DataRenderer {\n\tconstructor(localReader, settings, context, logger) {\n\t\tsuper(localReader, settings, context, logger);\n\t}\n\n\t/**\n\t * Output fileds generated:\n\t *\n\t * - *meshes* An array of THREE.Mesh objects visualizing this model file.\n\t * \n\t * @async\n\t * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n\t */\n\trenderAsync(callback) {\n\t\tvar self = this;\n\n\t\t/// Get file id\n\t\tvar fileId = this.settings.id;\n\t\tvar showUnmaterialed = true;\n\n\t\t/// Load the model file\n\t\tvar meshCache = {};\n\t\tvar textureCache = {};\n\n\t\t/// Set up output array\n\t\tself.getOutput().meshes = [];\n\n\t\tModelUtils.getMeshesForFilename(fileId, 0x00ff00, self.localReader, meshCache, textureCache, showUnmaterialed, true,\n\t\t\tfunction (meshes, isCached, boundingSphere) {\n\n\t\t\t\tif (meshes) {\n\t\t\t\t\tmeshes.forEach(function (mesh) {\n\t\t\t\t\t\tmesh.boundingSphere = boundingSphere;\n\t\t\t\t\t\tself.getOutput().meshes.push(mesh);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\t/// Fire callback after all meshes have been added.\n\t\t\t\tmeshCache = {};\n\t\t\t\tcallback();\n\t\t\t}\n\t\t);\n\n\t}\n}\n\nmodule.exports = SingleModelRenderer;","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst DataRenderer = require('./DataRenderer');\n\n/**\n *\n * A renderer that generates a list of readable strings from a \"strs\" file.\n * \n * @class StringRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"id\" the base ID or file ID of the string file to read strings from.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nclass StringRenderer extends DataRenderer {\n\tconstructor(localReader, settings, context, logger) {\n\t\tsuper(localReader, settings, context, logger);\n\t}\n\n\t/**\n\t * Output fileds generated:\n\t *\n\t * - *strings* An array of objects. Each object has a \"recid\"-property specifing on what index within the file\n\t * a given string was found, and a \"value\"-property specigying the string value.\n\t *\n\t * - *language* An integer specifing the language of the loaded file.\n\t * \n\t * @async\n\t * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n\t */\n\trenderAsync(callback) {\n\t\tvar self = this;\n\n\t\t/// Get file id\n\t\tvar fileId = this.settings.id;\n\t\tvar showUnmaterialed = true;\n\n\t\t/// Load the string file\n\n\t\t/// Set up output array\n\t\tthis.getOutput().strings = [];\n\n\t\tthis.localReader.readFile(this.settings.id, false, false, undefined, undefined, true).then((result) => {\n\t\t\tlet inflatedData = result.buffer;\n\t\t\tvar ds = new DataStream(inflatedData);\n\t\t\tvar end = ds.byteLength - 2;\n\n\t\t\t/// skip past fcc\n\t\t\tds.seek(4);\n\n\t\t\tvar entryHeaderDef = [\n\t\t\t\t\"size\", \"uint16\",\n\t\t\t\t\"decryptionOffset\", \"uint16\",\n\t\t\t\t\"bitsPerSymbol\", \"uint16\"\n\t\t\t];\n\n\t\t\tvar entryIndex = 0;\n\n\t\t\twhile (end - ds.position > 6) {\n\n\t\t\t\tvar entry = ds.readStruct(entryHeaderDef);\n\t\t\t\tentry.size -= 6;\n\n\t\t\t\tif (entry.size > 0) {\n\n\n\t\t\t\t\tvar isEncrypted = entry.decryptionOffset != 0 || entry.bitsPerSymbol != 0x10;\n\n\t\t\t\t\t/// UTF-16\n\t\t\t\t\tif (!isEncrypted) {\n\t\t\t\t\t\tvar value = ds.readUCS2String(entry.size / 2);\n\t\t\t\t\t\tself.getOutput().strings.push({\n\t\t\t\t\t\t\tvalue: value,\n\t\t\t\t\t\t\trecid: entryIndex\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\t/// Other... ignored\n\t\t\t\t\telse {\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tentryIndex++;\n\t\t\t}\n\n\n\t\t\tds.seek(ds.byteLength - 2);\n\t\t\tself.getOutput().language = ds.readUint16();\n\t\t\tcallback();\n\t\t});\n\n\n\t}\n}\n\nmodule.exports = StringRenderer;","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst DataRenderer = require('./DataRenderer');\n\nconst MapTerrainUtils = require(\"../util/MapTerrainUtils\");\n\n/**\n *\n * A renderer that generates the meshes for the terrain of a map.\n *\n * \n * Requires a context previously populated by a \n * {{#crossLink \"EnvironmentRenderer\"}}{{/crossLink}}.\n * \n * @class TerrainRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"mapFile\", a GW2File.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nclass TerrainRenderer extends DataRenderer {\n\tconstructor(localReader, settings, context, logger) {\n\t\tsuper(localReader, settings, context, logger);\n\n\t\tthis.mapFile = this.settings.mapFile;\n\t}\n\n\n\t/**\n\t * Output fileds generated:\n\t * \n\t * - *terrainTiles* An array of THREE.Mesh objects visualizing terrain of the map.\n\t * \n\t * - *water* A THREE.Mesh object visualizing the bounds of the map.\n\t * \n\t * - *bounds* An object wiht x1, x2, y1, and y2 properties specifying the bounds of the map.\n\t * \n\t * @async\n\t * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n\t */\n\trenderAsync(callback) {\n\n\t\t/// Load all paged Images, requires inflation of other pack files!\n\t\tvar pagedImageId = this.mapFile.getChunk(\"trn\").data.materials.pagedImage;\n\t\tthis.localReader.readFile(pagedImageId, false, false, undefined, undefined, true).then((result) => {\n\n\t\t\treturn MapTerrainUtils.loadPagedImageCallback(\n\t\t\t\tresult.buffer,\n\t\t\t\tthis.mapFile,\n\t\t\t\tthis.settings.anisotropy,\n\t\t\t\tthis.getOutput(T3D.EnvironmentRenderer),\n\t\t\t\tthis.localReader);\n\n\t\t}).then((terrainResult) => {\n\t\t\t//Populate the output\n\t\t\tthis.getOutput().terrainTiles = terrainResult.terrainTiles;\n\t\t\tthis.getOutput().water = terrainResult.water;\n\t\t\tthis.getOutput().bounds = terrainResult.mapRect;\n\n\t\t\tcallback();\n\t\t});\n\t}\n\n\t/**\n\t * TODO: write description. Used for export feature\n\t * \n\t * @param  {Function} callback [description]\n\t * @return {*}            [description]\n\t */\n\tgetFileIdsAsync(callback) {\n\t\tcallback(MapTerrainUtils.getTerrainFilesId(this.mapFile));\n\t}\n}\n\nmodule.exports = TerrainRenderer;","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst ModelUtils = require(\"../util/ModelUtils\");\nconst DataRenderer = require('./DataRenderer');\n\n/**\n *\n * A renderer that generates zone models for a map.\n * \n * @class ZoneRenderer\n * @constructor\n * @extends DataRenderer\n * @param  {LocalReader} localReader  The LocalReader instance to read data from.\n * @param  {Object} settings     Any settings used by this renderer.\n * *Must* specify \"mapFile\", a GW2File.\n * @param  {Object} context      Shared value object between renderers.\n * @param  {Logger} logger       The logging class to use for progress, warnings, errors et cetera.\n */\nclass ZoneRenderer extends DataRenderer {\n\tconstructor(localReader, settings, context, logger) {\n\t\tsuper(localReader, settings, context, logger);\n\n\t\tthis.mapFile = this.settings.mapFile;\n\n\t\t/**\n\t\t * TODO\n\t\t * \n\t\t * @param  {*} zone               [description]\n\t\t * @param  {*} zoneDefs           [description]\n\t\t * @param  {*} mapRect            [description]\n\t\t * @param  {*} renderZoneCallback [description]\n\t\t * @return {*}                    [description]\n\t\t */\n\t\tthis.renderZone = function (zone, zoneDefs, mapRect, renderZoneCallback) {\n\t\t\tvar self = this;\n\n\t\t\t/// Get Zone Definition\n\t\t\tvar zoneDef = null;\n\t\t\tzoneDefs.forEach(function (zd) {\n\t\t\t\tif (!zoneDef && zd.token == zone.defToken)\n\t\t\t\t\tzoneDef = zd;\n\t\t\t});\n\n\t\t\t/// Create array of all models to add:\n\t\t\tvar models = [];\n\t\t\tvar modelGroups = this.getModelGroups(zone, zoneDef, mapRect);\n\n\t\t\t/// Create empty mesh cache\n\t\t\tself.meshCache = {};\n\t\t\tself.textureCache = {};\n\n\t\t\t/*\n\t\t\t * ---Keeping this out of the doc for now---\n\t\t\t * Steps trough each model and renders it to the scene, allowing for efficient caching.\n\t\t\t * @param  {Number} i - Current index within the models array\n\t\t\t */\n\t\t\t//var lastPct = -1;\n\t\t\tvar groupKeys = Object.keys(modelGroups);\n\n\t\t\tfunction stepModels(i) {\n\n\t\t\t\t/*var pct = Math.round(100.0*i / groupKeys.length);\n\t\t\t\tif(lastPct!=pct){\n\t\t\t\t\tconsole.log(\"Rendering ZONE models \"+pct);\n\t\t\t\t\tlastPct = pct;\n\t\t\t\t}*/\n\n\t\t\t\tif (i >= groupKeys.length) {\n\n\t\t\t\t\t/// Empty mesh cache\n\t\t\t\t\tself.meshCache = {};\n\t\t\t\t\tself.textureCache = {};\n\n\t\t\t\t\t/// Tell caller this zone is done loading\n\t\t\t\t\trenderZoneCallback();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t/// Read model at index\n\t\t\t\t/// var model = models[i];\n\t\t\t\tvar key = groupKeys[i]; /// key is model filename\n\t\t\t\tvar group = modelGroups[key];\n\n\t\t\t\tvar meshGroups = [];\n\n\t\t\t\t/// Get model just once for this group\n\t\t\t\tvar showUnmaterialed = false;\n\t\t\t\tModelUtils.getMeshesForFilename(key, null, self.localReader, self.meshCache, self.textureCache, showUnmaterialed, false,\n\n\t\t\t\t\tfunction (meshes, isCached) {\n\n\t\t\t\t\t\t/// If there were meshes, add them to the scene with correct scaling rotation etc.\n\t\t\t\t\t\tif (meshes /* && meshes.length == 3*/ ) {\n\n\t\t\t\t\t\t\t/// Add one copy per model instance\n\t\t\t\t\t\t\t/// TODO: add rotation!\n\t\t\t\t\t\t\t/// TODO: fine tune position?\n\t\t\t\t\t\t\t/// TODO: POTIMIZE!\n\n\n\t\t\t\t\t\t\tgroup.forEach(function (model, instanceIdx) {\n\n\t\t\t\t\t\t\t\tvar isCached = true;\n\t\t\t\t\t\t\t\tvar scale = 1.0;\n\n\t\t\t\t\t\t\t\t/// For each Mesh in the model\n\t\t\t\t\t\t\t\tmeshes.forEach(function (mesh, meshIdx) {\n\n\t\t\t\t\t\t\t\t\tif (mesh.materialFlags == 525 /* || mesh.materialFlags == 520 || mesh.materialFlags == 521*/ ) {\n\t\t\t\t\t\t\t\t\t\t//console.log(\"Skipping lod\");\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\n\n\n\t\t\t\t\t\t\t\t\tvar move = {\n\t\t\t\t\t\t\t\t\t\tx: 0,\n\t\t\t\t\t\t\t\t\t\ty: 0,\n\t\t\t\t\t\t\t\t\t\tz: 0\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\t\t/// Add to big mesh\n\t\t\t\t\t\t\t\t\tif (!meshGroups[meshIdx]) {\n\t\t\t\t\t\t\t\t\t\tvar mg = mesh.geometry.clone();\n\t\t\t\t\t\t\t\t\t\tmeshGroups[meshIdx] = {\n\t\t\t\t\t\t\t\t\t\t\treadVerts: mg.getAttribute('position').array,\n\t\t\t\t\t\t\t\t\t\t\tverts: new Float32Array(group.length * mg.getAttribute('position').array.length),\n\n\t\t\t\t\t\t\t\t\t\t\treadIndices: mg.getIndex().array,\n\t\t\t\t\t\t\t\t\t\t\tindices: new Uint32Array(group.length * mg.getIndex().array.length),\n\n\t\t\t\t\t\t\t\t\t\t\treadUVs: mg.getAttribute('uv').array,\n\t\t\t\t\t\t\t\t\t\t\tuvs: new Float32Array(group.length * mg.getAttribute('uv').array.length),\n\n\t\t\t\t\t\t\t\t\t\t\treadNormals: mg.getAttribute('normal').array,\n\t\t\t\t\t\t\t\t\t\t\tnormals: new Float32Array(group.length * mg.getAttribute('normal').array.length),\n\n\t\t\t\t\t\t\t\t\t\t\tmaterial: mesh.material,\n\t\t\t\t\t\t\t\t\t\t\t//material:new THREE.MeshBasicMaterial( {color: 0xffcccc, wireframe:true} ),\n\t\t\t\t\t\t\t\t\t\t\t/*material : new THREE.PointCloudMaterial ({\n\t\t\t\t\t\t\t\t\t\t\tcolor: 0xFF0000,\n\t\t\t\t\t\t\t\t\t\t\tsize: 20\n\t\t\t\t\t\t\t\t\t\t\t}),*/\n\t\t\t\t\t\t\t\t\t\t\tposition: {\n\t\t\t\t\t\t\t\t\t\t\t\tx: model.x,\n\t\t\t\t\t\t\t\t\t\t\t\ty: model.y,\n\t\t\t\t\t\t\t\t\t\t\t\tz: model.z\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t/// Translate\n\t\t\t\t\t\t\t\t\t\tmove.x = model.x - meshGroups[meshIdx].position.x;\n\t\t\t\t\t\t\t\t\t\tmove.y = model.z - meshGroups[meshIdx].position.z;\n\t\t\t\t\t\t\t\t\t\tmove.z = model.y - meshGroups[meshIdx].position.y;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t/// Add geom verts\n\t\t\t\t\t\t\t\t\tvar readVerts = meshGroups[meshIdx].readVerts;\n\t\t\t\t\t\t\t\t\tvar writeVerts = meshGroups[meshIdx].verts;\n\t\t\t\t\t\t\t\t\tvar stride = readVerts.length;\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, j = instanceIdx * stride; i < stride; i += 3, j += 3) {\n\t\t\t\t\t\t\t\t\t\twriteVerts[j + 0] = readVerts[i + 0] + move.x;\n\t\t\t\t\t\t\t\t\t\twriteVerts[j + 1] = readVerts[i + 1] + move.y;\n\t\t\t\t\t\t\t\t\t\twriteVerts[j + 2] = readVerts[i + 2] + move.z;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar readIndices = meshGroups[meshIdx].readIndices;\n\t\t\t\t\t\t\t\t\tvar writeIndices = meshGroups[meshIdx].indices;\n\t\t\t\t\t\t\t\t\tvar strideIndices = readIndices.length;\n\t\t\t\t\t\t\t\t\tvar shift = stride * instanceIdx / 3;\n\n\t\t\t\t\t\t\t\t\tfor (var i = 0, j = instanceIdx * strideIndices; i < strideIndices; i++, j++) {\n\t\t\t\t\t\t\t\t\t\twriteIndices[j] = readIndices[i] + shift;\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t\tvar readUVs = meshGroups[meshIdx].readUVs;\n\t\t\t\t\t\t\t\t\tvar writeUvs = meshGroups[meshIdx].uvs;\n\t\t\t\t\t\t\t\t\tvar uvStride = readUVs.length;\n\t\t\t\t\t\t\t\t\tfor (var i = 0, j = instanceIdx * uvStride; i < uvStride; i++, j++) {\n\t\t\t\t\t\t\t\t\t\twriteUvs[j] = readUVs[i];\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tvar readNormals = meshGroups[meshIdx].readNormals;\n\t\t\t\t\t\t\t\t\tvar writeNormals = meshGroups[meshIdx].normals;\n\t\t\t\t\t\t\t\t\tvar normalStride = readNormals.length;\n\t\t\t\t\t\t\t\t\tfor (var i = 0, j = instanceIdx * normalStride; i < normalStride; i++, j++) {\n\t\t\t\t\t\t\t\t\t\twriteNormals[j] = readNormals[i];\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t}); // End for each model in group\n\n\t\t\t\t\t\t} /// End if meshes\n\n\t\t\t\t\t\t/// Add each cluster of merged meshes to scene\n\t\t\t\t\t\tmeshGroups.forEach(function (meshGroup) {\n\n\t\t\t\t\t\t\tvar mergedGeom = new THREE.BufferGeometry();\n\n\t\t\t\t\t\t\tmergedGeom.addAttribute('position', new THREE.BufferAttribute(meshGroup.verts, 3));\n\t\t\t\t\t\t\t//mergedGeom.addAttribute( 'index', new THREE.BufferAttribute( meshGroup.indices, 1) );\n\t\t\t\t\t\t\tmergedGeom.setIndex(new THREE.BufferAttribute(meshGroup.indices, 1));\n\t\t\t\t\t\t\tmergedGeom.addAttribute('normal', new THREE.BufferAttribute(meshGroup.normals, 3));\n\t\t\t\t\t\t\tmergedGeom.addAttribute('uv', new THREE.BufferAttribute(meshGroup.uvs, 2));\n\n\t\t\t\t\t\t\tmergedGeom.buffersNeedUpdate = true;\n\n\t\t\t\t\t\t\tlet mesh = new THREE.Mesh(mergedGeom, meshGroup.material);\n\t\t\t\t\t\t\tmesh.position.set(meshGroup.position.x, meshGroup.position.z, meshGroup.position.y);\n\n\t\t\t\t\t\t\tself.getOutput().meshes.push(mesh);\n\n\t\t\t\t\t\t}); // End for each meshgroup\n\n\n\t\t\t\t\t\t/// Rendering is done, render next.\n\t\t\t\t\t\tstepModels(i + 1);\n\t\t\t\t\t}\n\n\t\t\t\t);\n\n\n\n\n\t\t\t} /// End function stepModels\n\n\t\t\t/// Begin stepping trough the models, rendering them.\n\t\t\tstepModels(0);\n\t\t}\n\n\n\t\t/**\n\t\t * TODO\n\t\t * \n\t\t * @param  {*} zone    [description]\n\t\t * @param  {*} zoneDef [description]\n\t\t * @param  {*} mapRect [description]\n\t\t * @return {*}         [description]\n\t\t */\n\t\tthis.getModelGroups = function (zone, zoneDef, mapRect) {\n\n\t\t\t/// Calculate rect in global coordinates\n\t\t\tvar zPos = zone.zPos;\n\n\t\t\tvar mapX = mapRect[0];\n\t\t\tvar mapY = mapRect[1];\n\t\t\tvar c = 32 + 16;\n\n\t\t\t// [\"x1\",\"uint32\",\"y1\",\"uint32\",\"x2\",\"uint32\", \"y2\", \"uint32\"]\n\t\t\tvar zoneRect = {\n\t\t\t\tx1: zone.vertRect[0] * c + mapX,\n\t\t\t\tx2: zone.vertRect[2] * c + mapX,\n\t\t\t\ty1: zone.vertRect[1] * -c - mapY,\n\t\t\t\ty2: zone.vertRect[3] * -c - mapY\n\t\t\t};\n\n\n\n\t\t\t/// Zone width and depth in local corrdinates\n\t\t\t/*var zdx = zone.vertRect.x1-zone.vertRect.x2;\n\t\t\tvar zdy = zone.vertRect.y1-zone.vertRect.y2;*/\n\n\t\t\t/// These zones seems to overflow :/\n\t\t\tif (zone.encodeData.length == 0) {\n\t\t\t\treturn {};\n\t\t\t}\n\n\t\t\tvar zdx = zone.vertRect[0] - zone.vertRect[2];\n\t\t\tvar zdy = zone.vertRect[1] - zone.vertRect[3];\n\n\t\t\t/// Zone Flags increases a linear position, used to step trough the Zone.\n\t\t\tvar linearPos = 0;\n\n\t\t\tvar modelGroups = {};\n\n\t\t\tvar terrainTiles = this.getOutput(T3D.TerrainRenderer).terrainTiles;\n\n\t\t\tfor (var i = 0; i < zone.flags.length; i += 2) {\n\n\t\t\t\t/// Step forward\n\t\t\t\tlinearPos += zone.flags[i];\n\n\t\t\t\t/// Check if a model should be placed\n\t\t\t\tvar flag = zone.flags[i + 1];\n\t\t\t\tif (flag != 0) {\n\n\t\t\t\t\t/// Extract flag data\n\t\t\t\t\t/// Layer is written in the last 4 bytes\n\t\t\t\t\tvar zoneDefLayer = flag >> 4;\n\n\t\t\t\t\t/// Get Zone Definition Layer\n\t\t\t\t\tvar layer = zoneDef.layerDefArray[zoneDefLayer - 1];\n\n\t\t\t\t\t/// TESTING Only show layers with height >= 3\n\t\t\t\t\tif (layer /* && layer.height >= 0*/ ) {\n\n\t\t\t\t\t\t/// Get X and Y from linear position\n\t\t\t\t\t\tvar modelX = (linearPos % zdx) * c + zoneRect.x1;\n\t\t\t\t\t\tvar modelY = Math.floor(linearPos / zdx) * c + zoneRect.y1;\n\n\t\t\t\t\t\t/// Get Z from intersection with terrain\n\t\t\t\t\t\tvar modelZ = null;\n\n\t\t\t\t\t\tvar startZ = 100000;\n\n\t\t\t\t\t\tvar raycaster = new THREE.Raycaster(\n\t\t\t\t\t\t\tnew THREE.Vector3(modelX, startZ, modelY),\n\t\t\t\t\t\t\tnew THREE.Vector3(0, -1, 0)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t/// TODO: OPT?\n\t\t\t\t\t\tterrainTiles.forEach(function (chunk) {\n\t\t\t\t\t\t\tif (modelZ === null) {\n\t\t\t\t\t\t\t\tvar intersections = raycaster.intersectObject(chunk);\n\t\t\t\t\t\t\t\tif (intersections.length > 0) {\n\t\t\t\t\t\t\t\t\tmodelZ = startZ - intersections[0].distance;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\t/// Get model id\n\t\t\t\t\t\t/// TODO: check with modelIdx = flag & 0xf;\n\t\t\t\t\t\tvar modelIdx = 0;\n\t\t\t\t\t\tvar model = layer.modelArray[modelIdx];\n\t\t\t\t\t\tvar modelFilename = model.filename;\n\t\t\t\t\t\tvar zOffsets = model.zOffsets;\n\n\t\t\t\t\t\tvar layerFlags = layer.layerFlags; //NOrmaly 128, 128\n\n\t\t\t\t\t\t//TODO: flip z,y?\n\t\t\t\t\t\tvar rotRangeX = layer.rotRangeX; //max min\n\t\t\t\t\t\tvar rotRangeY = layer.rotRangeY; //max min\n\t\t\t\t\t\tvar rotRangeZ = layer.rotRangeZ; //max min\n\t\t\t\t\t\tvar scaleRange = layer.scaleRange; //max min\n\t\t\t\t\t\tvar fadeRange = layer.fadeRange; //max min\n\n\t\t\t\t\t\t//Unused\n\t\t\t\t\t\t//tiling: 3\n\t\t\t\t\t\t//type: 1\n\t\t\t\t\t\t//width: 2\n\t\t\t\t\t\t//radiusGround: 2\n\n\t\t\t\t\t\t/// Create modelGroup (this zone only)\n\t\t\t\t\t\tif (!modelGroups[modelFilename]) {\n\t\t\t\t\t\t\tmodelGroups[modelFilename] = [];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/// Add entry to model group\n\t\t\t\t\t\tmodelGroups[modelFilename].push({\n\t\t\t\t\t\t\tx: modelX,\n\t\t\t\t\t\t\ty: modelY,\n\t\t\t\t\t\t\tz: modelZ,\n\t\t\t\t\t\t\trotRangeX: rotRangeX,\n\t\t\t\t\t\t\trotRangeY: rotRangeY,\n\t\t\t\t\t\t\trotRangeZ: rotRangeZ,\n\t\t\t\t\t\t\tscaleRange: scaleRange,\n\t\t\t\t\t\t\tfadeRange: fadeRange\n\n\t\t\t\t\t\t});\n\n\n\t\t\t\t\t} /// End if layer\n\n\n\t\t\t\t} /// End if flag != 0\n\n\t\t\t} /// End for each flag\n\n\t\t\treturn modelGroups;\n\t\t}\n\t}\n\n\t/**\n\t * Renders all zone meshes in a GW2 map described by the map's \"zon2\" chunk.\n\t * Output fileds generated:\n\t *\n\t * - *meshes* An array of THREE.Mesh objects visualizing all zone models refered by this map.\n\t * \n\t * @async\n\t * @param  {Function} callback Fires when renderer is finished, does not take arguments.\n\t */\n\trenderAsync(callback) {\n\t\tvar self = this;\n\n\t\t/// Set up output array\n\t\tself.getOutput().meshes = [];\n\n\t\tvar zoneChunkData = this.mapFile.getChunk(\"zon2\").data;\n\t\tvar parameterChunkData = this.mapFile.getChunk(\"parm\").data;\n\t\tvar terrainChunkData = this.mapFile.getChunk(\"trn\").data;\n\t\tvar mapRect = parameterChunkData.rect;\n\n\t\t/// Zone data\n\t\tvar zones = zoneChunkData.zoneArray;\n\t\tvar zoneDefs = zoneChunkData.zoneDefArray;\n\n\t\t/// Render each zone\n\t\tlet lastPct = -1;\n\n\t\t/// Main render loop, render each zone\n\t\tfunction stepZone(i) {\n\n\t\t\tvar pct = Math.round(100.0 * i / zones.length);\n\t\t\tif (lastPct != pct) {\n\t\t\t\tself.logger.log(\n\t\t\t\t\tT3D.Logger.TYPE_PROGRESS,\n\t\t\t\t\t\"Loading 3D Models (Zone)\", pct\n\t\t\t\t);\n\t\t\t\tlastPct = pct;\n\t\t\t}\n\n\t\t\tif (i >= zones.length) {\n\t\t\t\tcallback();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/// Main zone render function call\n\t\t\tself.renderZone(zones[i], zoneDefs, mapRect,\n\t\t\t\tstepZone.bind(self, i + 1)\n\t\t\t);\n\n\t\t}\n\n\t\tstepZone(0);\n\t}\n}\n\n/// NOT USED??\nfunction addZoneMeshesToScene(meshes, isCached, position, scale, rotation) {\n\n\t/// Called for each mesh in the zone\n\t/// TODO: Opt opt opt...\n\n\tmeshes.forEach(function (mesh) {\n\n\t\t/// Create new mesh if we got back a cached original.\n\t\tif (isCached)\n\t\t\tmesh = new THREE.Mesh(mesh.geometry, mesh.material);\n\n\t\t/// Scale, position and rotate.\n\t\tmesh.scale.set(scale, scale, scale);\n\t\tif (rotation) {\n\t\t\tmesh.rotation.order = \"ZXY\";\n\t\t\tmesh.rotation.set(rotation.x, rotation.y, rotation.z);\n\t\t}\n\t\tmesh.position.set(position.x, position.y, position.z);\n\n\t\t/// Add to export\n\t\tthis.getOutput().meshes.push(mesh);\n\t});\n\n}\n\nmodule.exports = ZoneRenderer;\n\n//// Not used: zone defintion per chunk data \"images\" 32*32 points\n/*\n//Total map dx and dy\nvar d = terrainChunkHeader.data;\nvar pd = parameterChunkHeader.data;\nvar dx = (pd.rect.x2-pd.rect.x1);\nvar dy = (pd.rect.y2-pd.rect.y1);\n\n//Each chunk dx and dy\n\nvar c =1;\nvar cdx = c*dx/d.dims.dim1;\n\nvar cdy = c*dy/d.dims.dim2;\n\nvar cdx = dx/(d.numChunksD_1*2);\nvar cdy =dy/(d.numChunksD_2*2);\n\n\nfor(var i=0; i<zoneDefs.length; i++){\n\tvar zoneDef = zoneDefs[i];\n\t\n\t//TODO: opt!\n\tzoneDef.layerDefs.forEach(function(layer){\n\n\t\tlayer.modelArray.forEach(function(model){\n\t\t\n\t\t\t\n\t\t});\n\t\t\n\n\t});\n\n\tvar chunkMat = new THREE.MeshBasicMaterial(\n\t\t{\n\t\t\tcolor: 0x00ff00,\n\t\t\twireframe:true,\n\t\t \topacity: 1.0,\n\t\t}\n\t);\n\n\t//TODO: opt!\n\t\n\tif(\n\t\tzoneDef.token == 597  ||\n\t\tzoneDef.token == 1369  ||\n\t\tzoneDef.token == 903  \n\t){\n\n\t\tzoneDef.pageTable.pageArray.forEach(function(page){\n\t\t\tvar flags = page.flags;\n\t\t\tvar coord = page.chunkCoord;\n\n\n\t\t\t//Hightlight this coord\n\t\t\tvar rect = {};\n\n\t\t\t\n\t\t\t//var globalOffsetX = pd.rect.x2 - cdx;\n\t\t\tvar globalOffsetX = pd.rect.x1 + cdx/2;\n\t\t\tvar chunkOffsetX = coord[0] * cdx;\n\n\t\t\trect.x1  = globalOffsetX + chunkOffsetX;\n\n\t\t\t///Adjust for odd / even number of chunks\n\t\t\tif(d.numChunksD_2 % 2 == 0){\n\t\t\t\t\n\t\t\t\tvar globalOffsetY = -pd.rect.y1;\n\t\t\t\tvar chunkOffsetY = -coord[1] * cdy;\n\n\t\t\t\trect.y1  =  chunkOffsetY + globalOffsetY;\n\t\t\t}\n\t\t\telse{\n\n\t\t\t\tvar globalOffsetY =  -pd.rect.y1;\n\t\t\t\tvar chunkOffsetY = -coord[1] * cdy;\n\n\t\t\t\trect.y1 = globalOffsetY +  chunkOffsetY;\t\n\t\t\t}\n\n\t\t\trect.x2 = rect.x1+cdx;\n\t\t\trect.y2 = rect.y1+cdy;\n\n\n\t\t\t\n\n\t\t\tRenderUtils.renderRect(rect, 4000,chunkMat, 4000);\n\n\t\t\t//for(var j=0; j<flags.length; j++){\n\t\t\t//\tif(flags[j]>0){\n\t\t\t//\t\tconsole.log(\"Found flag\",flags[j],\"@ zoneDef\",zoneDef.token,\"coord\",coord,\"index\",j);\n\t\t\t//\t}\n\t\t\t//}\n\t\t});\n\n\t}\n\n}*/","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst HEAD_STRUCT = [\n\t'type', 'cstring:4',\n\t'chunkDataSize', 'uint32',\n\t'chunkVersion', 'uint16',\n\t'chunkHeaderSize', 'uint16',\n\t'offsetTableOffset', 'uint32',\n];\n\n\n/**\n * Settings for resolving conflicting chunk names in different files.\n * @private \n * @property DUPLICATE_SETTINGS\n * @type {Object}\n */\nvar DUPLICATE_SETTINGS;\n\n//Replacement for DUPLICATE_SETTINGS, based on the name of the root property.\nconst PACKTOCHUNK = [{\n\t\tpack: 'MODL',\n\t\tchunk: 'ANIM',\n\t\troot: 'ModelFileAnimation'\n\t},\n\t{\n\t\tpack: 'MODL',\n\t\tchunk: 'GAME',\n\t\troot: 'ModelFileGame'\n\t},\n\t{\n\t\tpack: 'MODL',\n\t\tchunk: 'SKEL',\n\t\troot: 'ModelFileSkeleton'\n\t},\n\t{\n\t\tpack: 'MODL',\n\t\tchunk: 'TOOL',\n\t\troot: 'ModelFileTool'\n\t},\n\t{\n\t\tpack: 'cntc',\n\t\tchunk: 'Main',\n\t\troot: 'PackContent'\n\t},\n\t{\n\t\tpack: 'mMet',\n\t\tchunk: 'Main',\n\t\troot: 'PackMapMetadata'\n\t},\n\t{\n\t\tpack: 'AMAT',\n\t\tchunk: 'TOOL',\n\t\troot: 'AmatToolParams'\n\t},\n\t{\n\t\tpack: 'cmaC',\n\t\tchunk: 'main',\n\t\troot: 'CollideModelManifest'\n\t}\n];\n\n// Builds the DUPLICATE_SETTINGS based on the provided T3D.formats.\n// Required to be done dynamically since the 32 bit and 64bits have different ordering\nfunction genDuplicateSettings() {\n\t//Early return if the settings have been already generated\n\tif (DUPLICATE_SETTINGS)\n\t\treturn;\n\n\tfunction getRootName(definition) {\n\t\tlet a = new definition();\n\t\treturn Object.keys(a).filter(v => {\n\t\t\treturn a[v] === a.__root && v != '__root'\n\t\t})[0];\n\t}\n\n\tDUPLICATE_SETTINGS = {};\n\tlet duplicate_settings = {};\n\tfor (let setting of PACKTOCHUNK) {\n\n\t\tlet regex = new RegExp(`^${setting.root}(V[0-9]*)?$`);\n\t\tlet chunkDef = T3D.formats.filter(v => {\n\t\t\treturn v.name == setting.chunk\n\t\t});\n\n\t\tfor (let defsIdx in chunkDef) {\n\t\t\tlet defs = chunkDef[defsIdx].versions;\n\t\t\tlet lastVersion = defs[Object.keys(defs).pop()];\n\t\t\tlet rootName = getRootName(lastVersion);\n\t\t\tif (rootName.match(regex)) {\n\t\t\t\tif (!DUPLICATE_SETTINGS[setting.chunk])\n\t\t\t\t\tDUPLICATE_SETTINGS[setting.chunk] = [];\n\t\t\t\tDUPLICATE_SETTINGS[setting.chunk][defsIdx] = setting.pack;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\n/**\n * Basic chunk parsing functionality for Guild Wars 2 file chunks\n *\n * @constructor\n * @param {DataStream} ds A DataStream containing deflated chunk binary data.\n * @param {Number} addr Offset of chunk start within the DataStream\n */\nclass GW2Chunk {\n\n\tconstructor(ds, addr) {\n\t\t//Early returns if already called, it defines the DUPLICATE_SETTINGS variable\n\t\tgenDuplicateSettings();\n\n\t\t/**\n\t\t * @property {DataStream} ds The DataStream data source used by this chunk.\n\t\t */\n\t\tthis.ds = ds;\n\n\t\t/**\n\t\t * @property {Number} addr The address to this Chunk within ds.\n\t\t */\n\t\tthis.addr = addr;\n\n\t\t/**\n\t\t * @property {Object} data The typed data read from the body of this chunk.\n\t\t */\n\t\tthis.data = null;\n\n\n\t\t/**\n\t\t * @property {Number} headerLength The length in bytes of the chunk header.\n\t\t */\n\t\tthis.headerLength = NaN;\n\n\t\t/**\n\t\t * @property {Object} header Chunk header data.\n\t\t */\n\t\tthis.loadHead();\n\t}\n\n\t/**\n\t * Parses the chunk header data, populating the header property.\n\t */\n\tloadHead() {\n\t\tthis.ds.seek(this.addr);\n\t\tthis.header = this.ds.readStruct(HEAD_STRUCT);\n\n\t\tthis.headerLength = this.ds.position - this.addr;\n\t}\n\n\t/**\n\t * @param  {String} fileType The main type of the pack file containing this chunk.\n\t * Used for resolving chunk naming conflicts between pack file types.\n\t * @return {Array}\tDataStream formatted array describing the data\n\t * sctructures of this chunk\n\t */\n\tgetDefinition(fileType) {\n\n\t\t/// Normally we're looking for the 0th occurance\n\t\t/// But some chunk names occur multiple times and we're interrested\n\t\t/// in the N:th occurance of the definition.\n\t\t/// \n\t\t/// I've no idea how this is automated, for now just use the \n\t\t/// settings object I've put together from experience.\n\t\tvar useNthIndex = 0;\n\n\t\t/// If this chunk has multiple definitions\n\t\t/// get to know what def to use...\n\t\tvar fileTypes = DUPLICATE_SETTINGS[this.header.type];\n\t\tif (fileTypes) {\n\n\t\t\tuseNthIndex = -1;\n\n\t\t\t/// Check what file name entry matches this file name\n\t\t\tfor (var i = 0; i < fileTypes.length && useNthIndex == -1; i++) {\n\t\t\t\tvar ft = fileTypes[i];\n\n\n\t\t\t\tif (ft == fileType) {\n\t\t\t\t\tuseNthIndex = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/// We didnt find this file name!\n\t\t\t/// TODO: if you get this error, please update the DUPLICATE_SETTINGS above\n\t\t\tif (useNthIndex == -1) {\n\t\t\t\tdebugger;\n\t\t\t}\n\t\t}\n\n\t\tvar defsFound = 0;\n\t\tfor (var i = 0; i < T3D.formats.length; i++) {\n\t\t\tvar f = T3D.formats[i];\n\n\t\t\t/// Chunk name needs to match\n\t\t\tif (f.name == this.header.type) {\n\n\t\t\t\t/// There needs to be a chunk def version matching the one specifiend \n\t\t\t\t/// \n\t\t\t\t/// AND If this is the Nth occurance of the chunk definition\n\t\t\t\t/// and we're looking for the Nth occurance, return it.\n\t\t\t\t/// \n\t\t\t\t/// chunkVersion in the dat uses 0 indexing\n\t\t\t\tif (defsFound == useNthIndex && f.versions[this.header.chunkVersion]) {\n\t\t\t\t\treturn (new f.versions[this.header.chunkVersion]()).__root;\n\t\t\t\t}\n\n\t\t\t\tdefsFound++;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Parses the chunk main data, populating the data property.\n\t * \n\t * @param  {String} fileType The main type of the pack file containing this chunk.\n\t * Used for resolving chunk naming conflicts between pack file types when\n\t * looking up the structure definition for this chunk.\n\t */\n\tloadData(fileType) {\n\n\t\tvar def = this.getDefinition(fileType);\n\n\t\tif (def) {\n\t\t\tthis.ds.seek(this.addr + this.headerLength);\n\t\t\tthis.data = this.ds.readStruct(def);\n\t\t} else {\n\t\t\tT3D.Logger.log(T3D.Logger.TYPE_WARNING,\n\t\t\t\t\"Could not find a definition for chunk\",\n\t\t\t\tthis.header.type,\n\t\t\t\t\"version\", this.header.chunkVersion,\n\t\t\t\t\"file name\", fileType);\n\t\t}\n\n\t}\n\n\t/**\n\t * Retrieves the next chunk is the datastream. In practice this means the next chunk\n\t * within the same pack file.\n\t * \n\t * @return {GW2Chunk} The next chunk if any, otherwise null.\n\t */\n\tnext() {\n\t\ttry {\n\n\t\t\t// Calculate actual data size, as mChunkDataSize\n\t\t\t// does not count the size of some header variables\n\t\t\treturn new GW2Chunk(this.ds, this.addr + 8 + this.header.chunkDataSize);\n\t\t} catch (e) {\n\t\t\t/// Out of bounds probably\t\t\n\t\t}\n\t\treturn null;\n\t}\n}\n\nmodule.exports = GW2Chunk;","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst Chunk = require('./GW2Chunk');\n\nconst HEAD_STRUCT = [\n\t'identifier', 'cstring:2',\n\t'unknownField1', 'uint16',\n\t'unknownField2', 'uint16',\n\t'pkFileVersion', 'uint16',\n\t'type', 'cstring:4'\n];\n\n\n/**\n * Basic header and chunk parsing functionality for Guild Wars 2 pack files (PF)\n *\n * @constructor\n * @param {DataStream} ds A DataStream containing deflated file binary data.\n * @param {Number} addr Offset of file start within the DataStream\n * @param {boolean} noChunks If true, the file does not parse its\n * chunks on creation.\n */\nclass GW2File {\n\n\tconstructor(ds, addr, noChunks) {\n\n\t\t/**\n\t\t * @property {DataStream} ds The DataStream data source used by this file.\n\t\t */\n\t\tthis.ds = ds;\n\n\t\t/**\n\t\t * @property {Number} addr The address to this File within ds.\n\t\t */\n\t\tthis.addr = addr;\n\n\t\t/// Not used anymore I think\n\t\tthis.data = null;\n\n\t\t/**\n\t\t * @property {Number} headerLength The length in bytes of the file header.\n\t\t */\n\t\tthis.headerLength = NaN;\n\n\t\t/**\n\t\t * All {{#crossLink \"GW2Chunk\"}}chunks{{/crossLink}} contained in the file.\n\t\t *\n\t\t * @property chunks\n\t\t * @type GW2Chunk[]\n\t\t */\n\t\tthis.chunks = [];\n\n\n\t\t/**\n\t\t * @property {Object} header Chunk header data.\n\t\t */\n\t\tthis.readHead();\n\n\t\tif (!noChunks) {\n\t\t\tthis.readChunks();\n\t\t}\n\t}\n\n\n\t/**\n\t * Parses the file header data, populating the header property.\n\t */\n\treadHead() {\n\t\tthis.ds.seek(this.addr);\n\t\tthis.header = this.ds.readStruct(HEAD_STRUCT);\n\t\tthis.headerLength = this.ds.position - this.addr;\n\t}\n\n\t/**\n\t * Parses the file headers and populates the chunks property.\n\t */\n\treadChunks() {\n\n\t\t/// Reset chunks\n\t\tthis.chunks = [];\n\n\t\t//var structs = this.getChunkStructs && this.getChunkStructs();\n\n\t\t/// Load basic Chunk in order to read the chunk header.\n\t\tvar ch = new Chunk(this.ds, this.headerLength + this.addr);\n\n\t\t//while(structs && ch!=null && ch.header.type){\n\t\twhile (ch != null && ch.header.type) {\n\n\t\t\t/// Load data and pass file type if we need to determine what chunk entry to use\n\t\t\t/// (Some chunks in different files share the same chunk name)\n\t\t\tch.loadData(this.header.type);\n\t\t\tthis.chunks.push(ch);\n\n\t\t\t/// Load next basic Chunk in order to read the chunk header.\n\t\t\tch = ch.next();\n\t\t}\n\t}\n\n\n\t/**\n\t * Get a GW2Chunk from this file\n\t * \n\t * @param  {String} type The name, or type of the desired chunk.\n\t * @return {GW2Chunk} The first GW2Chunk in this file matching the type name, or null if no matching GW2Chunk was found.\n\t */\n\tgetChunk(type) {\n\t\tfor (var i = 0; i < this.chunks.length; i++) {\n\t\t\tif (this.chunks[i].header.type.toLowerCase() == type.toLowerCase())\n\t\t\t\treturn this.chunks[i];\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Provides a list of known header types and their parsing structure. Should be defined by each file type individually.\n\t * \n\t * @return {Object} An object mapping chunk identifiers to DataStream structure descriptors.\n\t */\n\tgetChunkStructs() {\n\t\treturn {}\n\t}\n\n}\n\nmodule.exports = GW2File;","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * Object describing the meaning of the bits in fvf integers.\n * @private\n * @type {Object}\n */\nlet fvfFormat = {\n    Position: 0x00000001,\n    /**< 12 bytes. Position as three 32-bit floats in the order x, y, z. */\n    Weights: 0x00000002,\n    /**< 4 bytes. Contains bone weights. */\n    Group: 0x00000004,\n    /**< 4 bytes. Related to bone weights. */\n    Normal: 0x00000008,\n    /**< 12 bytes. Normal as three 32-bit floats in the order x, y, z. */\n    Color: 0x00000010,\n    /**< 4 bytes. Vertex color. */\n    Tangent: 0x00000020,\n    /**< 12 bytes. Tangent as three 32-bit floats in the order x, y, z. */\n    Bitangent: 0x00000040,\n    /**< 12 bytes. Bitangent as three 32-bit floats in the order x, y, z. */\n    TangentFrame: 0x00000080,\n    /**< 12 bytes. */\n    UV32Mask: 0x0000ff00,\n    /**< 8 bytes for each set bit. Contains UV-coords as two 32-bit floats in the order u, v. */\n    UV16Mask: 0x00ff0000,\n    /**< 4 bytes for each set bit. Contains UV-coords as two 16-bit floats in the order u, v. */\n    Unknown1: 0x01000000,\n    /**< 48 bytes. Unknown data. */\n    Unknown2: 0x02000000,\n    /**< 4 bytes. Unknown data. */\n    Unknown3: 0x04000000,\n    /**< 4 bytes. Unknown data. */\n    Unknown4: 0x08000000,\n    /**< 16 bytes. Unknown data. */\n    PositionCompressed: 0x10000000,\n    /**< 6 bytes. Position as three 16-bit floats in the order x, y, z. */\n    Unknown5: 0x20000000,\n    /**< 12 bytes. Unknown data. **/\n};\n\n/// Known material flags, not used yet\nvar knownflags = [\n\n    0, //0 0000 0000 0000\t\tGround / Wall splashes\n    8, //0 0000 0000 1000\t\tBroken Khylo roof DDS\n    9, //0 0000 0000 1001\t\tTree leaves\n\n    520, //0 0010 0000 1000\t\tSome LOD modules, fires, smoke, inside of tents (some DSS textures)\n\n\n    2056, //0 1000 0000 1000\t\tSolid objects, also broken animations\n\n    ///Solids here are unhappy, or are they? could be animations etc\n    2057, //0 1000 0000 1001\t\tWindmill sails, bushes, trees, but also a statue and a few pieces of wall\n\n    2060, //0 1000 0000 1100\t\tA few solid objects, like wooden barricades, one(!) painting\n    2061, //0 1000 0000 1101\t\tA few bushes, two paintings\n\n\n    2312, //0 1001 0000 1000\t\tOpaque Clock tower main walls AND IVY\n    2316, //0 1001 0000 1100\t\tBushes, inner flower walkway a ramp and a box\n\n    // Number 10\n    2568, //0 1010 0000 1000\t\tLots of solids; walls, tents also some tent details WITH alpa\n\n    //Number 11\n    2569, //0 1010 0000 1001\t\tSolids like walls and roofs and appernt non solids like ropes\n\n    2572, //0 1010 0000 1100\t\tSolid wooden beems, lamp posts\n    2573, //0 1010 0000 1101\t\tLamp holders, bushes, fences, apparent non solids\n    2584, //0 1010 0001 1000\t\tFountain Well water\n\n    2824, //0 1011 0000 1000\t\tWindows, sign arrows, cloth roofs (non solids) BUT straw roofs\n    2828, //0 1011 0000 1100\t\tA few fence post (non solids)\n    2840, //0 1011 0001 1000\t\tFountain running water + pipe water\n\n    4617, //1 0010 0000 1001\t\tFound nothing\n    6664 //1 1010 0000 1000\t\tTwo groups of solid boxes\n];\n\nmodule.exports = {\n    fvfFormat: fvfFormat\n}","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst MaterialUtils = require('./MaterialUtils');\n\nfunction getMat(tex) {\n    return new THREE.MeshBasicMaterial({\n        map: tex,\n        side: THREE.BackSide,\n        fog: false,\n        depthWrite: false\n    });\n};\n\nfunction loadTextureWithFallback(targetMatIndices, materialArray, filename, fallbackFilename, hazeColorAsInt, localReader) {\n\n    function writeMat(mat) {\n        for (let i of targetMatIndices) {\n            materialArray[i] = mat;\n        }\n    }\n\n    function loadFallback() {\n        var mat = getMat(\n            new THREE.TextureLoader().load(fallbackFilename)\n        );\n\n        writeMat(mat);\n    }\n\n    function errorCallback() {\n        setTimeout(loadFallback, 1);\n    }\n\n    var mat = getMat(\n        MaterialUtils.loadLocalTexture(\n            localReader,\n            filename,\n            null, hazeColorAsInt,\n            errorCallback)\n    );\n\n    writeMat(mat);\n}\n\nfunction getHazeColor(environmentChunkData) {\n    let hazes = environmentChunkData && environmentChunkData.dataGlobal.haze;\n\n    if (!hazes || hazes.length <= 0) {\n        return [190, 160, 60];\n    } else {\n        return hazes[0].farColor;\n    }\n};\n\nfunction parseLights(environmentChunkData) {\n\n    let lightOutput = [];\n\n    let lights = environmentChunkData ? environmentChunkData.dataGlobal.lighting : [{\n        lights: [],\n        backlightIntensity: 1.0,\n        backlightColor: [255, 255, 255]\n    }];\n\n    let ambientLight;\n\n    let hasLight = false;\n\n    //Iterate on each light\n    for (let idx in lights) {\n        let light = lights[idx];\n\n        if (hasLight)\n            break;\n\n        /// Directional lights\n        let sumDirLightIntensity = 0;\n\n        for (let dirLightData of light.lights) {\n\n            hasLight = true;\n\n            let color = new THREE.Color(\n                dirLightData.color[2] / 255.0,\n                dirLightData.color[1] / 255.0,\n                dirLightData.color[0] / 255.0\n            );\n\n            let directionalLight = new THREE.DirectionalLight(color.getHex(), dirLightData.intensity);\n\n            directionalLight.position.set(-dirLightData.direction[0],\n                dirLightData.direction[2],\n                dirLightData.direction[1]\n            ).normalize();\n\n            sumDirLightIntensity += dirLightData.intensity;\n\n            lightOutput.push(directionalLight);\n\n        } // END for each directional light in light\n\n\n        /// Add some random directional lighting if there was no, in order to se SOME depth on models\n        if (!light.lights || light.lights.length == 0) {\n\n            const directions = [\n                [0, 1, 0, .3],\n                [1, 2, 1, .3],\n                [-1, -2, -1, .3]\n            ];\n\n            for (let lightDir of directions) {\n\n                const color = new THREE.Color(1, 1, 1);\n                let intensity = lightDir[3];\n                let directionalLight = new THREE.DirectionalLight(color.getHex(), intensity);\n\n                directionalLight.position.set(lightDir[0], lightDir[1], lightDir[2]).normalize();\n\n                sumDirLightIntensity += intensity;\n\n                lightOutput.push(directionalLight);\n\n            }\n\n        }\n\n        /// Ambient light\n        //light.backlightIntensity /= sumDirLightIntensity +light.backlightIntensity; \n        light.backlightIntensity = light.backlightIntensity;\n        const color = new THREE.Color(\n            light.backlightIntensity * (255.0 - light.backlightColor[2]) / 255.0,\n            light.backlightIntensity * (255.0 - light.backlightColor[1]) / 255.0,\n            light.backlightIntensity * (255.0 - light.backlightColor[0]) / 255.0\n        );\n\n        ambientLight = new THREE.AmbientLight(color);\n\n    } // END for each light in lighting\n\n    let ambientTotal = 0;\n    if (ambientLight) {\n        ambientTotal = ambientLight.color.r + ambientLight.color.g + ambientLight.color.b;\n        lightOutput.push(ambientLight);\n    }\n\n    /// Parsing done, return hasLight flag and lights\n    return {\n        lights: lightOutput,\n        hasLight: hasLight || ambientTotal > 0\n    };\n};\n\nfunction parseSkybox(environmentChunkData, parameterChunkData, hazeColorAsInt, skyboxFallbackArray, localReader) {\n\n    /// set up output array\n    let skyElements = [];\n\n    /// Grab sky texture.\n    /// index 0 and 1 day\n    /// index 2 and 3 evening\n    let skyModeTex = this.environmentChunkData && this.environmentChunkData.dataGlobal.skyModeTex[0];\n\n    /// Fallback skyboxfrom dat.\n    if (!skyModeTex) {\n        skyModeTex = {\n            texPathNE: 1930687,\n            texPathSW: 193069,\n            texPathT: 193071\n        }\n    }\n\n    /// Calculate bounds\n    const bounds = parameterChunkData.rect;\n    let mapW = Math.abs(bounds.x1 - bounds.x2);\n    let mapD = Math.abs(bounds.y1 - bounds.y2);\n    let boundSide = Math.max(mapW, mapD);\n\n    let materialArray = [];\n\n    /// Load skybox textures, fallback to hosted png files.\n    loadTextureWithFallback([1, 4], materialArray, skyModeTex.texPathNE + 1, skyboxFallbackArray[0], hazeColorAsInt, localReader);\n    loadTextureWithFallback([0, 5], materialArray, skyModeTex.texPathSW + 1, skyboxFallbackArray[1], hazeColorAsInt, localReader);\n    loadTextureWithFallback([2], materialArray, skyModeTex.texPathT + 1, skyboxFallbackArray[2], hazeColorAsInt, localReader);\n    materialArray[3] = new THREE.MeshBasicMaterial({\n        visible: false\n    });\n\n\n    /// Create skybox geometry\n    const boxSize = 1024;\n    let skyGeometry = new THREE.BoxGeometry(boxSize, boxSize / 2, boxSize); //Width Height Depth\n\n    /// Ugly way of fixing UV maps for the skybox (I think)\n    for (let idx in skyGeometry.faceVertexUvs[0]) {\n        let vecs = skyGeometry.faceVertexUvs[0][idx];\n\n        let face = Math.floor(idx / 2);\n\n        // PX NX\n        // PY NY\n        // PZ NZ\n\n        /// PX - WEST \tNX - EAST\n        if (face == 0 || face == 1) {\n            for (let vec2 of vecs) {\n                vec2.x = 1 - vec2.x;\n                vec2.y /= 2.0;\n                vec2.y += .5;\n            }\n        }\n\n        /// NZ - SOUTH \tPZ - NORTH\n        else if (face == 5 || face == 4) {\n            for (let vec2 of vecs) {\n                vec2.y /= -2.0;\n                vec2.y += .5;\n            }\n        } else {\n            for (let vec2 of vecs) {\n                vec2.x = 1 - vec2.x;\n            }\n        }\n\n    }\n\n    skyGeometry.uvsNeedUpdate = true;\n\n    /// Generate final skybox\n    var skyBox = new THREE.Mesh(skyGeometry, materialArray);\n\n    /// Put horizon in camera center\n    skyBox.translateY(boxSize / 4);\n    //skyBox.translateY( -environmentChunk.data.dataGlobal.sky.verticalOffset );\n\n    /// Write to output\n    skyElements.push(skyBox);\n\n    /// And return\n    return {\n        skyElements: skyElements\n    };\n};\n\nmodule.exports = {\n    getHazeColor: getHazeColor,\n    parseLights: parseLights,\n    parseSkybox: parseSkybox\n}","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst RenderUtils = require('./RenderUtils');\nconst MaterialUtils = require(\"./MaterialUtils\");\nconst TerrainShader = require(\"./TerrainShader\");\nconst GW2File = require(\"../format/file/GW2File\");\n\nfunction drawWater(rect) {\n\n    /// Add Water\n    var material = material || new THREE.MeshBasicMaterial({\n        color: 0x5bb1e8,\n        wireframe: false,\n        opacity: 0.35\n    });\n\n    material.transparent = true;\n    return RenderUtils.renderRect(rect, 0, material);\n}\n\nfunction parseNumChunks(terrainData) {\n    terrainData.numChunksD_1 = Math.sqrt(\n        terrainData.dims[0] *\n        terrainData.chunkArray.length /\n        terrainData.dims[1]\n    );\n    terrainData.numChunksD_2 =\n        terrainData.chunkArray.length / terrainData.numChunksD_1;\n}\n\n\n/**\n * \n * @param {*} inflatedBuffer \n * @param {*} mapFile\n * @param {*} anisotropy\n * @param {*} envOutput \n * @param {*} localReader \n * @returns {Promise<{terrainTiles: Array, water: *, mapRect: *}>}\n */\nasync function loadPagedImageCallback(inflatedBuffer, mapFile, anisotropy, envOutput, localReader) {\n\n    // Prep output variables\n    let terrainTiles = [];\n    let water = undefined;\n    let bounds = undefined;\n\n    var pimgDS = new DataStream(inflatedBuffer);\n    var pimgFile = new GW2File(pimgDS, 0);\n    var pimgTableDataChunk = pimgFile.getChunk(\"pgtb\");\n    var pimgData = pimgTableDataChunk && pimgTableDataChunk.data;\n\n    let mapRect = null;\n\n    /// Fetch chunks\n    var terrainData = mapFile.getChunk(\"trn\").data;\n    var parameterData = mapFile.getChunk(\"parm\").data;\n\n    /// Read settings\n    var maxAnisotropy = anisotropy ? anisotropy : 1;\n\n    var chunks = [];\n    var chunkW = 35;\n\n    /// Calculate numChunksD_1 and _2\n    parseNumChunks(terrainData);\n\n    var xChunks = terrainData.numChunksD_1;\n    var yChunks = terrainData.numChunksD_2;\n\n    var allMaterials = terrainData.materials.materials;\n    var allTextures = terrainData.materials.texFileArray;\n\n    //Total map dx and dy\n    var dx = parameterData.rect[2] - parameterData.rect[0];\n    var dy = parameterData.rect[3] - parameterData.rect[1];\n\n    //Each chunk dx and dy\n    var cdx = dx / terrainData.numChunksD_1 * 1; //  35/33;\n    var cdy = dy / terrainData.numChunksD_2 * 1; //35/33;\n    var n = 0;\n    var allMats = [];\n    var customMaterial = new THREE.MeshLambertMaterial({\n        side: THREE.DoubleSide,\n        color: 0x666666,\n        flatShading: true\n    });\n    var texMats = {};\n\n    /// Load textures from PIMG and inject as material maps (textures)\n    var chunkTextures = {};\n\n    /// Load textures\n    if (pimgData) {\n        var strippedPages = pimgData.strippedPages;\n\n        ///Only use layer 0\n        strippedPages.forEach(function (page) {\n\n            /// Only load layer 0 and 1\n            if (page.layer <= 1) {\n                var filename = page.filename;\n                var color = page.solidColor;\n                var coord = page.coord;\n\n                var matName = coord[0] + \",\" + coord[1];\n                if (page.layer == 1)\n                    matName += \"-2\";\n\n\n                /// Add texture to list, note that coord name is used, not actual file name\n                if (!chunkTextures[matName]) {\n\n                    /// Load local texture, here we use file name!\n                    var chunkTex = MaterialUtils.loadLocalTexture(localReader, filename);\n\n                    if (chunkTex) {\n                        /// Set repeat, antistropy and repeat Y\n                        chunkTex.anisotropy = maxAnisotropy;\n                        chunkTex.wrapS = THREE.RepeatWrapping;\n                        chunkTex.wrapT = THREE.RepeatWrapping;\n                    }\n\n                    ///...But store in coord name\n                    chunkTextures[matName] = chunkTex;\n\n                }\n            }\n\n        }); /// end for each stripped page in pimgData\n    }\n\n    /// Render Each chunk\n    /// We'll make this async in order for the screen to be able to update\n\n    var renderChunk = function (cx, cy) {\n        var chunkIndex = cy * xChunks + cx;\n\n        var pageX = Math.floor(cx / 4);\n        var pageY = Math.floor(cy / 4);\n\n        //TODO: Terrain texture LOD ?\n        //var chunkTextureIndices = allMaterials[chunkIndex].loResMaterial.texIndexArray;\n        //var matFileName = allMaterials[chunkIndex].loResMaterial.materialFile;\n\n        var chunkTextureIndices = allMaterials[chunkIndex].hiResMaterial.texIndexArray;\n        var matFileName = allMaterials[chunkIndex].hiResMaterial.materialFile;\n\n\n        var chunkData = terrainData.chunkArray[chunkIndex];\n\n        var mainTex = allTextures[chunkTextureIndices[0]];\n        var mat = customMaterial;\n\n        /// TODO: just tick invert y = false...?\n        var pageOffetX = (cx % 4) / 4.0;\n        var pageOffetY = 0.75 - (cy % 4) / 4.0;\n\n        //offset 0 -> 0.75\n\n\n        //Make sure we have shared textures\n\n        /// Load and store all tiled textures\n        var fileNames = [];\n        for (var gi = 0; gi < chunkTextureIndices.length / 2; gi++) {\n            var textureFileName = allTextures[chunkTextureIndices[gi]].filename;\n\n            fileNames.push(textureFileName);\n\n            /// If the texture is not already loaded, read it from the .dat!\n            if (!chunkTextures[textureFileName]) {\n\n                /// Load local texture\n                var chunkTex = MaterialUtils.loadLocalTexture(localReader, textureFileName);\n\n                if (chunkTex) {\n                    /// Set repeat, antistropy and repeat Y\n                    chunkTex.anisotropy = maxAnisotropy;\n                    chunkTex.wrapS = THREE.RepeatWrapping;\n                    chunkTex.wrapT = THREE.RepeatWrapping;\n                }\n\n                chunkTextures[textureFileName] = chunkTex;\n            }\n        } /// End for each chunkTextureIndices\n\n        /// Create Composite texture material, refering the shared textures\n        var pageTexName = pageX + \",\" + pageY;\n        var pageTexName2 = pageX + \",\" + pageY + \"-2\";\n\n\n        //var fog = SceneUtils.getScene().fog;\n        var fog = {\n            color: {\n                r: 1,\n                g: 1,\n                b: 1\n            },\n            near: 0,\n            far: 0\n        }\n\n        /// Set the haze from the environment output\n        if (envOutput.hazeColor) {\n            fog.color.r = envOutput.hazeColor[2] / 255.0;\n            fog.color.g = envOutput.hazeColor[1] / 255.0;\n            fog.color.b = envOutput.hazeColor[0] / 255.0;\n        }\n\n        var uniforms = THREE.UniformsUtils.merge([\n            THREE.UniformsLib['lights'],\n        ]);\n\n        /// TODO: READ FROM VO, don't default to hard coded scale\n        uniforms.uvScale = {\n            type: \"v2\",\n            value: new THREE.Vector2(8.0, 8.0)\n        };\n        uniforms.offset = {\n            type: \"v2\",\n            value: new THREE.Vector2(pageOffetX, pageOffetY)\n        };\n\n        uniforms.texturePicker = {\n            type: \"t\",\n            value: chunkTextures[pageTexName]\n        };\n        uniforms.texturePicker2 = {\n            type: \"t\",\n            value: chunkTextures[pageTexName2]\n        };\n\n        uniforms.texture1 = {\n            type: \"t\",\n            value: chunkTextures[fileNames[0]]\n        };\n        uniforms.texture2 = {\n            type: \"t\",\n            value: chunkTextures[fileNames[1]]\n        };\n        uniforms.texture3 = {\n            type: \"t\",\n            value: chunkTextures[fileNames[2]]\n        };\n        uniforms.texture4 = {\n            type: \"t\",\n            value: chunkTextures[fileNames[3]]\n        };\n\n\n        mat = new THREE.ShaderMaterial({\n            uniforms: uniforms,\n            fragmentShader: TerrainShader.getFragmentShader(),\n            vertexShader: TerrainShader.getVertexShader()\n        });\n\n        ///Store referenceto each material\n        allMats.push(mat);\n\n\n        /// -1 for faces -> vertices , -2 for ignoring outer faces\n        var chunkGeo = new THREE.PlaneBufferGeometry(cdx, cdy, chunkW - 3, chunkW - 3);\n\n        var cn = 0;\n\n        ///Render chunk\n\n        /// Each chunk vertex\n        for (var y = 0; y < chunkW; y++) {\n\n            for (var x = 0; x < chunkW; x++) {\n\n                if (x != 0 && x != chunkW - 1 && y != 0 && y != chunkW - 1) {\n                    chunkGeo.getAttribute('position').array[cn * 3 + 2] = terrainData.heightMapArray[n];\n                    cn++;\n                }\n\n                n++;\n            }\n        } // End each chunk vertex\n\n\n        /// Flip the plane to fit wonky THREE js world axes\n        var mS = (new THREE.Matrix4()).identity();\n        mS.elements[5] = -1;\n        chunkGeo.applyMatrix(mS);\n\n        /// Compute face normals for lighting, not used when textured\n        chunkGeo.computeFaceNormals();\n        //chunkGeo.computeVertexNormals();\n\n\n        /// Build chunk mesh!\n        var chunk;\n        chunk = new THREE.Mesh(chunkGeo, customMaterial);\n        if (mat.length) {\n            chunk = THREE.SceneUtils.createMultiMaterialObject(chunkGeo, mat);\n        } else {\n            chunk = new THREE.Mesh(chunkGeo, mat);\n        }\n\n\n        ///Move and rotate Mesh to fit in place\n        chunk.rotation.set(Math.PI / 2, 0, 0);\n\n        /// Last term is the new one: -cdx*(2/35)\n        var globalOffsetX = parameterData.rect[0] + cdx / 2;\n        var chunkOffsetX = cx * cdx;\n\n        chunk.position.x = globalOffsetX + chunkOffsetX;\n\n        ///Adjust for odd / even number of chunks\n        if (terrainData.numChunksD_2 % 2 == 0) {\n\n            /// Last term is the new one: -cdx*(2/35)\n            var globalOffsetY = parameterData.rect[1] + cdy / 2 - 0; // -cdy*(1/35);\n            var chunkOffsetY = cy * cdy * 1; //33/35;\n\n            chunk.position.z = chunkOffsetY + globalOffsetY;\n        } else {\n\n            var globalOffsetY = parameterData.rect[1] - cdy / 2 + 0; //cdy*(1/35);\n            var chunkOffsetY = cy * cdy * 1; //33/35;\n\n            chunk.position.z = globalOffsetY + chunkOffsetY;\n        }\n\n\n        var px = chunk.position.x;\n        var py = chunk.position.z;\n\n\n        if (!mapRect) {\n            mapRect = {\n                x1: px - cdx / 2,\n                x2: px + cdx / 2,\n                y1: py - cdy / 2,\n                y2: py + cdy / 2\n            };\n        }\n\n        mapRect.x1 = Math.min(mapRect.x1, px - cdx / 2);\n        mapRect.x2 = Math.max(mapRect.x2, px + cdx / 2);\n\n        mapRect.y1 = Math.min(mapRect.y1, py - cdy / 2);\n        mapRect.y2 = Math.max(mapRect.y2, py + cdy / 2);\n\n        chunk.updateMatrix();\n        chunk.updateMatrixWorld();\n\n        /// Add to list of stuff to render\n        /// TODO: Perhaps use some kind of props for each entry instead?\n        terrainTiles.push(chunk);\n\n    } /// End render chunk function\n\n\n    let cx = 0,\n        cy = 0;\n\n    while (cy < yChunks) {\n        //Process chunk\n        renderChunk(cx, cy);\n\n        //Step to next chunk\n        cx += 1;\n        if (cx >= xChunks) {\n            cx = 0;\n            cy++;\n        }\n\n        await new Promise(resolve => setTimeout(resolve, 1));\n\n        //Log\n        let pct = Math.floor(100 * (cy * xChunks + cx) / (xChunks * yChunks));\n        T3D.Logger.log(T3D.Logger.TYPE_PROGRESS, \"Loading Terrain\", pct);\n\n    }\n\n    return {\n        terrainTiles: terrainTiles,\n\n        //Draw water surface using map bounds:\n        water: drawWater(mapRect),\n\n        //Return bounds:\n        mapRect: mapRect\n    };\n\n}\n\nfunction getTerrainFilesId(mapFile) {\n    var terrainChunk = mapFile.getChunk(\"trn\");\n    var pimgTableDataChunk = mapFile.getChunk(\"pimg\");\n    var fileIds = [];\n\n    /// ------------ SPLASH TEXTURES ------------\n    var pimgData = pimgTableDataChunk && pimgTableDataChunk.data;\n    var strippedPages = pimgData.strippedPages;\n\n    ///Only use layer 0\n    strippedPages.forEach(function (page) {\n\n        /// Only load layer 0 and 1\n        if (page.layer <= 1 && page.filename > 0) {\n            fileIds.push(page.filename);\n        }\n    });\n    /// ------------ END SPLASH TEXTURES ------------\n\n\n\n    /// ------------ TILED IMAGES ------------\n    var terrainData = terrainChunk.data;\n    var allTextures = terrainData.materials.texFileArray;\n    allTextures.forEach(function (texture) {\n        if (texture.filename > 0)\n            fileIds.push(texture.filename);\n    })\n    /// ------------ END TILED IMAGES ------------\n\n    return fileIds;\n}\n\nmodule.exports = {\n    loadPagedImageCallback: loadPagedImageCallback,\n    getTerrainFilesId: getTerrainFilesId\n}","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/*\n\tguid 1683952224941671000 is fucked up floor in SAB HUB\n\tmaterialFilename for that mesh is 564821, shared with lots of stuff\n\tlod 1 and 2 are both 0\n\tmaterial flags is 2056\n*/\n\n/**\n * Collection of methods for generating THREE materials and textures\n * from Guild Wars 2 data formats.\n * @namespace MaterialUtils\n */\n\n\n\n/**\n * Builds a custom vertex shader for a given number of uv cannels.\n * WIP not implemented yet!\n * \n * @memberof MaterialUtils\n * @param  {Number} numUv Number of UV channels used by this shader\n * @return {String}       Genereted vertex shader source\n */\nfunction buildVS(numUv) {\n\n\tvar vdefs = \"\";\n\tvar adefs = \"\";\n\tvar reads = \"\";\n\tfor (var i = 0; i < numUv; i++) {\n\t\tvdefs += \"varying vec2 vUv_\" + (i + 1) + \";\\n\";\n\n\t\t/// uv and uv2 are defined by THREE\n\t\tif (i > 1)\n\t\t\tadefs += \"attribute vec2 uv\" + (i + 1) + \";\\n\";\n\n\n\t\treads += \"vUv_\" + (i + 1) + \" = uv\" + (i > 0 ? (i + 1) : \"\") + \";\\n\";\n\t}\n\n\treturn adefs + vdefs +\n\t\t\"void main()\\n\" +\n\t\t\"{\\n\" +\n\t\treads +\n\t\t\"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\" +\n\t\t\"gl_Position = projectionMatrix * mvPosition;\\n\" +\n\t\t\"}\";\n}\n\n\n/**\n * Generate a texture of a specified color, used to be part of THREEjs\n * \n * @memberof MaterialUtils\n * @param {Number} width \n * @param {Number} height \n * @param {THREE.Color} color \n * @returns {THREE.DataTexture}\n */\nfunction generateDataTexture(width, height, color) {\n\t// create a buffer with color data\n\tvar size = width * height;\n\tvar data = new Uint8Array(4 * size);\n\tvar r = Math.floor(color.r * 255);\n\tvar g = Math.floor(color.g * 255);\n\tvar b = Math.floor(color.b * 255);\n\tvar a = 255;\n\n\tfor (var i = 0; i < size; i++) {\n\t\tvar stride = i * 4;\n\n\t\tdata[stride] = r;\n\t\tdata[stride + 1] = g;\n\t\tdata[stride + 2] = b;\n\t\tdata[stride + 3] = a;\n\t}\n\t// used the buffer to create a DataTexture\n\treturn new THREE.DataTexture(data, width, height, THREE.RGBAFormat);\n}\n\n/**\n * Builds a custom pixel shader for a given number of uv cannels.\n * WIP not implemented yet!\n * \n * @memberof MaterialUtils\n * @param  {Array}  textures  THREE textures\n * @param  {Number} numUv     Number of UV channels used by this shader\n * @param  {Number} alphaTest Texture see-trough alpha treshold\n * @param  {any} lightMap  TODO\n * @returns {string}\n */\nfunction buildPS(textures, numUv, alphaTest, lightMap) {\n\tvar t1uv = \"vUv_\" + (textures[0].uvIdx + 1);\n\n\n\tvar discard = \"\";\n\n\tif (alphaTest) {\n\t\tdiscard = \"    if (c1.a < 0.5) \\n\" +\n\t\t\t\"       discard;\\n\";\n\t}\n\n\t/// Color from 1st text or lighted by 2nd?\n\tvar writeColor = \"gl_FragColor = c1;\\n\";\n\n\tif (lightMap) {\n\t\tvar texIdx = 0;\n\t\t//var t2uv = \"vUv_4\";//+(3-textures[texIdx].uvIdx+1);\n\t\tvar t2uv = \"vUv_1\"; // + (textures[texIdx].uvIdx+1);\n\t\t//console.log(\"t2uv\",t2uv);\n\n\t\twriteColor = \"   vec4 c2 = texture2D( texture\" + (texIdx + 1) + \", \" + t2uv + \" );\\n\" +\n\t\t\t\"     gl_FragColor = c2;\\n\";\n\t\t//\"     gl_FragColor = vec4(c2.rgb * c1.r/.5, c2.a);\\n\";\n\t}\n\n\n\tvar uniforms = \"\"\n\ttextures.forEach(function (t, idx) {\n\t\tuniforms += \"uniform sampler2D texture\" + (idx + 1) + \";\\n\";\n\t});\n\t/*uniforms += \"uniform sampler2D texture1;\\n\";\n\tif(lightMap)\n\t\tuniforms += \"uniform sampler2D texture2;\\n\";*/\n\n\tvar varyings = \"\";\n\tfor (var i = 0; i < numUv; i++) {\n\t\tvaryings += \"varying vec2 vUv_\" + (i + 1) + \";\\n\";\n\n\t}\n\n\treturn uniforms + varyings +\n\t\t\"void main( void ) {\\n\" +\n\t\t\"    vec4 c1 = texture2D( texture1, \" + t1uv + \" );\\n\" +\n\t\tdiscard +\n\t\twriteColor +\n\t\t\"}\";\n}\n\n/**\n * WIP, concept for generatin materials to render multi UV chanelled meshes.\n * \n * @memberof MaterialUtils\n * @param  {Array} \ttextures  THREE texture\n * @param  {Number} numUV     Number of UV channels used by this shader\n * @param  {Number} alphaTest Texture see-trough alpha treshold\n * @return {THREE.ShaderMaterial} Generated shader\n */\nfunction getUVMat(textures, numUV, alphaTest) {\n\n\tvar lightMap = false;\n\tvar uniforms = {};\n\n\ttextures.forEach(function (t, idx) {\n\t\tuniforms[\"texture\" + idx] = {\n\t\t\ttype: \"t\",\n\t\t\tvalue: t\n\t\t};\n\t});\n\n\tif (textures.length > 1) {\n\t\tlightMap = true;\n\t}\n\n\tvar attributes = {};\n\n\tfor (var i = 2; i < numUV; i++) {\n\t\tattributes[\"uv\" + (i + 1)] = {\n\t\t\ttype: 'v2',\n\t\t\tvalue: []\n\t\t};\n\t}\n\n\tvar vs = buildVS(numUV);\n\n\treturn new THREE.ShaderMaterial({\n\t\tuniforms: uniforms,\n\t\tvertexShader: vs,\n\t\tfragmentShader: buildPS(\n\t\t\ttextures,\n\t\t\tnumUV,\n\t\t\talphaTest,\n\t\t\tlightMap\n\t\t),\n\t\tattributes: attributes,\n\t\tside: THREE.FrontSide,\n\t});\n\n}\n\n/**\n * Builds a THREE texture from a ModelMaterialData by reading settings and\n * loading any required data from the localReader. Uses sharedTextures for \n * texture caching.\n *\n * This method is full of guesses and estimations, and could be improved on\n * a lot, allowing rendering of multi UV channeled materials, or special\n * materials like custom color chanelled gear.\n * \n * @memberof MaterialUtils\n * @param  {ModelMaterialData} material \tA value object often automaticaly  \n *                                       \tgenerated by a\n *                                       \t{{#crossLink \"GW2Chunk\"}}{{/crossLink}}\n *                                       \tstructure definitions can be found in \n *                                       \tAllFormats.js, look for the latest \n *                                       \tversion of ModelMaterialData\n *                                       \t\n * @param  {GW2File} materialFile   A GW2File instance, must be of type AMAT\n * @param  {LocalReader} localReader The LocalReader to load the file contents from.   \n * @param  {Object} sharedTextures  Value Object for keeping the texture cache\n * @return {THREE.Material}         A THREE Material with the generated contents and settings.\n */\nfunction getMaterial(material, materialFile, localReader, sharedTextures) {\n\n\tif (!materialFile)\n\t\treturn;\n\n\tvar dxChunk = materialFile.getChunk(\"dx9s\");\n\tvar grChunk = materialFile.getChunk(\"grmt\");\n\n\t/// Append all textures to the custom material\n\tvar finalTextures = [];\n\n\t//Some materials don't use textures..\n\tif (material && material.textures.length /* && material.textures[texIndex]*/ ) {\n\n\t\t/// TODO: check for flags!\t\t\t\n\t\t/// \n\t\t/// techinques[] -> passes[] -> effects[] -> samplerIndex[]\n\t\t/// \n\t\t//console.log(\"num effects\",dxChunk.data.techniques[0].passes[0].effects.length);\n\n\t\t//if(grChunk.data.flags!=76)\n\t\t//\treturn;\n\n\t\t/// 3 teqs : high medium low\t\t\t\t\t\t\t\tGRAPHICS LEVEL SETTINGS\n\t\t/// 1 passes\t\t\t\t\t\t\t\t\t\t\t\tDON'T CARE\n\t\t/// 15 effects\t\t\tEach effect has a pixel shader \t\tHOW??\n\t\t/// 1 or 2 sampler indices \t\t\t\t\t\t\t\t\tUSE ALL! (Multi material)\n\n\t\tvar effects = dxChunk.data.techniques[0].passes[0].effects;\n\t\t//var effect = effects[10];\n\t\tvar effect = effects[0];\n\n\t\tvar shader = dxChunk.data.shaders[effect.pixelShader];\n\n\t\t/*effects.forEach(function (eff) {\n\t\t\tif(eff.samplerIndex.length > effect.samplerIndex.length)\n\t\t\t\teffect = eff;\n\t\t});*/\n\t\t//var samplerIdx = effect.samplerIndex[0];\n\n\t\tvar samplerTextures = [];\n\t\tfor (var i = 0; i < effect.samplerIndex.length; i++) {\n\n\t\t\tvar samplerIdx = effect.samplerIndex[i];\n\t\t\tvar sampler = dxChunk.data.samplers[samplerIdx];\n\n\t\t\t/// SHOULD NEVER HAPPEN, hide mesh!\n\t\t\tif (!sampler)\n\t\t\t\tcontinue; //return;\n\n\t\t\tvar textureToken = sampler && grChunk.data.texTokens[sampler.textureIndex];\n\t\t\tif (!textureToken)\n\t\t\t\ttextureToken = \"0-0\";\n\t\t\t/*else\n\t\t\t\ttextureToken =textureToken.val;*/\n\n\t\t\t/// Find the texture reffered by this sampler\n\t\t\tvar samplerTex = null;\n\n\t\t\tmaterial.textures.forEach(function (tex, index) {\n\n\t\t\t\t///Seems like only 1st part of token is used...\n\t\t\t\tif (!samplerTex && tex.token.split(\"-\")[0] == textureToken.split(\"-\")[0]) {\n\t\t\t\t\t//console.log(\"TEX match\",tex.token, textureToken)\n\t\t\t\t\tsamplerTex = tex;\n\t\t\t\t}\n\t\t\t});\n\n\t\t\t/// Add this sampler's texture to the collection of all textures\n\t\t\tif (samplerTex) {\n\t\t\t\tsamplerTextures.push(samplerTex);\n\t\t\t} else {\n\t\t\t\t///FALLBACK, just guess what texture we should use\n\t\t\t\tif (sampler)\n\t\t\t\t\tsamplerTextures.push(material.textures[sampler.textureIndex]);\n\t\t\t\telse if (material.textures.length > 0)\n\t\t\t\t\tsamplerTextures.push(material.textures[0]);\n\t\t\t\telse return;\n\t\t\t}\n\n\n\t\t} /// END for each sampler index in effect\n\n\t\t/// We now have all textures\n\t\t//console.log(\"textures from sampler\", samplerTextures);\n\n\n\t\t/// Fallback to using whatever texture there is.\n\t\tif (samplerTextures.length <= 0) {\n\t\t\treturn;\n\t\t\t//mainTex =  material.textures[0];\t\t\t\n\t\t}\n\n\n\t\t//console.log(\"num samplers \",samplerTextures.length);\n\t\tsamplerTextures.forEach(function (texture, idx) {\n\n\t\t\tif (!texture)\n\t\t\t\treturn;\n\n\t\t\t/// Set texture \"URL\"\n\t\t\tvar texURL = texture && texture.filename;\n\n\t\t\t/// Load texture from RAM or local reader:\n\t\t\tfinalTextures[idx] = getTexture(texURL, localReader, sharedTextures)\n\t\t\tif (finalTextures[idx]) {\n\t\t\t\tfinalTextures[idx].uvIdx = texture.uvPSInputIndex;\n\t\t\t}\n\n\t\t});\n\n\n\t} /// End if material and texture\t\t\t\n\n\tvar finalMaterial;\n\n\n\t/// Create custom shader material if there are textures\n\tif (finalTextures) {\n\n\t\t// TODO: make this work!\n\t\tif (false && finalTextures.length > 0) {\n\t\t\tfinalMaterial = getUVMat(finalTextures, material.texCoordCount, grChunk.data.flags != 16460);\n\t\t} else {\n\t\t\tvar ft = false;\n\t\t\tvar nt = false;\n\t\t\tmaterial.textures.forEach(function (t) {\n\t\t\t\t//Flag for diffuse map\n\t\t\t\tif (!ft && t.token.split(\"-\")[0] == \"1733499172\")\n\t\t\t\t\tft = t;\n\n\t\t\t\t//Flag for normal map\n\t\t\t\tif (!nt && t.token.split(\"-\")[0] == \"404146670\")\n\t\t\t\t\tnt = t;\n\t\t\t});\n\n\t\t\tif (!ft || ft.filename <= 0)\n\t\t\t\treturn;\n\n\t\t\tfinalMaterial = new THREE.MeshPhongMaterial({\n\t\t\t\tside: THREE.FrontSide,\n\t\t\t\tmap: getTexture(ft.filename, localReader, sharedTextures)\n\t\t\t});\n\t\t\tif (nt) {\n\t\t\t\tvar normalMap = getTexture(nt.filename, localReader, sharedTextures);\n\t\t\t\tnormalMap.flipY = true;\n\t\t\t\tfinalMaterial.normalMap = normalMap;\n\t\t\t}\n\n\n\t\t\tfinalMaterial.textureFilename = ft.filename;\n\t\t\tif (grChunk.data.flags != 16460) {\n\t\t\t\t//console.log(\"Setting alpha flag for \",grChunk.data.flags)\n\t\t\t\tfinalMaterial.alphaTest = 0.05;\n\t\t\t}\n\t\t}\n\n\t}\n\n\t/// Fallback material is monocolored red\n\telse {\n\t\tfinalMaterial = new THREE.MeshBasicMaterial({\n\t\t\tside: THREE.FrontSide,\n\t\t\tcolor: 0xff0000,\n\t\t\tshading: THREE.FlatShading\n\t\t});\n\t}\n\n\n\tfinalMaterial.needsUpdate = true;\n\n\n\t/// Set material props\n\t/// disable for now in order for custom shaders not to fuck up\n\n\tif (material) {\n\n\t\tvar alphaMask0 = 0x0001; // + 0x0100 + 0x0200;\n\t\tvar alphaMask1 = 0x0010\n\t\tvar alphaMask2 = 0x0100 + 0x0200;\n\t\tvar alphaMask2b = 0x0200;\n\n\n\t\tvar grChunk = materialFile.getChunk(\"grmt\");\n\n\t\t//Enable alpha test for transparent flags\n\t\tif ((\n\t\t\t\tmaterial.materialFlags & alphaMask0 ||\n\t\t\t\tmaterial.materialFlags & alphaMask1 ||\n\t\t\t\tmaterial.materialFlags & alphaMask2\n\t\t\t) //&& solidColor != null\n\t\t) {\n\t\t\t//return;\n\t\t\t//mesh.material.transparent = true;\n\t\t\t//mesh.material.opacity = 2.0;\n\n\t\t\t//var clr = solidColor;\n\t\t\t//var propAlpha = 0;\n\n\t\t\t///Backgroud color adds to alpha\n\t\t\t//if( mesh.materialFlags == 2569  ){\n\n\t\t\t/// This is rly just guesswork\n\t\t\t/// Check material flag  2568 (as int) and compare material filename 27353 to 20041\n\t\t\t/// Same flags but some have alpha and some don't\n\t\t\t//if( mesh.materialFlags & alphaMask2b  ){\n\t\t\t//\tpropAlpha =  (clr[3] - 128)/128;\n\t\t\t//\t//propAlpha = Math.max(0,propAlpha);\n\t\t\t//}\n\n\t\t\t//mesh.material.alphaTest = Math.max(0, 0.1 );//- propAlpha*2);\n\n\t\t}\n\n\n\t\t/// GRCHUNK -> DATA -> FLAGS\n\n\t\t///HAS LIGHT - TEX - ? - EMISSIVE16460\n\t\t///\n\n\t\t/// 56533 LOD FOR TOMBSTONE?\n\n\t\t//\t16460\t\t\t0100 0000 0100 1100\t\t\t\"standard\" stuff rendering OK in SAB (no alpha test)\n\n\t\t//\t\n\t\t//\t16452(SAB)\t\t0100 0000 0100 0100\t\t\tyellow numbers in sab signs\n\t\t//\t16448(SAB)\t\t0100 0000 0100 0000\t\t\tfaces on rocks, cloudmen, skybox portal images, holes in walls, floor plates...\n\t\t//\t\t\t\t\t\t\t\t\t\t\t\tno lighting??\n\t\t//\t\n\t\t//\t 8268\t\t\t0010 0000 0100 1100\t\n\t\t//\t 3392\t\t\t0000 1101 0100 0000\t\t\tMoto machine light bulbs\n\t\t//\t 2380\t\t\t0000 1001 0100 1100\n\t\t//\t 2368\t\t\t0000 1001 0100 0000\t\t\tFountain water with rings, portal border and circular \"light\"\n\t\t//\t  332\t\t\t0000 0001 0100 1100\n\t\t//\t  324\t\t\t0000 0001 0100 0100\t\t\tMoto face sprites\n\t\t//\t  \n\t\t//\t  320(SAB)\t\t0000 0001 0100 0000\t\t\tportal textures (normal maps ish)\n\t\t//\t  \n\t\t//\t   76\t\t\t0000 0000 0100 1100\t\t\tLOTS OF STUFF\n\t\t//\t   \t\t\t\t\t\t\t\t\t\t\tTree leaves, ground, hills, some roofs, flags, street lights\n\t\t//\t   \t\t\t\t\t\t\t\t\t\t\tsheild textures, some fences, water tops, waterfall\n\t\t//\t   \t\t\t\t\t\t\t\t\t\t\t\n\t\t//\t   \t\t\t\t\t\t\t\t\t\t\tIN KHYLO \"everything with alpha\"\n\t\t//\t   \n\t\t//\t   \n\t\t//\t   68\t\t\t0000 0000 0100 0100\t\t\tSome flowers (lo res?) fountain edges foam\n\t\t//\t   \n\t\t//\t   64(SAB)\t\t0000 0000 0100 0000\t\t\tclouds, sun iamge\n\n\n\t\tvar lightMask = 8;\n\n\t\tvar knownFileFlags = [\n\t\t\t16460,\n\t\t\t16452,\n\t\t\t16448,\n\t\t\t8268,\n\t\t\t3392,\n\t\t\t2380,\n\t\t\t2368,\n\t\t\t332,\n\t\t\t324,\n\t\t\t320,\n\t\t\t76,\n\t\t\t68,\n\t\t\t64\n\t\t];\n\n\t\tif (knownFileFlags.indexOf(grChunk.data.flags) < 0) {\n\t\t\tT3D.Logger.log(\n\t\t\t\tT3D.Logger.TYPE_WARNING,\n\t\t\t\t\"unknown GR flag\", grChunk.data.flags\n\t\t\t);\n\t\t}\n\n\t\tif (!(grChunk.data.flags & lightMask)) {\n\t\t\t//debugger;\n\t\t\t//console.log(\"no light\");\n\t\t\tfinalMaterial = new THREE.MeshBasicMaterial({\n\t\t\t\tside: THREE.FrontSide,\n\t\t\t\tmap: finalMaterial.map\n\t\t\t});\n\n\t\t}\n\n\t\tif (grChunk.data.flags != 16460) {\n\t\t\tfinalMaterial.alphaTest = 0.05;\n\t\t}\n\n\n\t} /// End if material\n\n\n\treturn finalMaterial;\n\n}\n\n\n/**\n * Load image data into a THREE.Texture from a texture file in the .dat file, using a LocalReader.\n * Any loaded tetures are added to sharedTextures, allowing for texture caching and fewer reads.\n * \n * @memberof MaterialUtils\n * @param  {Number} texURL         The fileId or baseId of the file to load image data from.\n * @param  {LocalReader} localReader    The LocalReader to load the file contents from.\n * @param  {Object} sharedTextures Value Object for keeping the texture cache\n * @return {THREE.Texture} A texture that will be populated by the file data when it is loaded.\n */\nfunction getTexture(texURL, localReader, sharedTextures) {\n\n\tvar finalTexture;\n\n\t/// Read texture from shared array of loaded textures\n\t/// or read it from URL and add to shared ones!\t\t\t\n\tif (texURL && sharedTextures[texURL]) {\n\n\t\t/// Just read from already loaded textures.\n\t\tfinalTexture = sharedTextures[texURL];\n\n\t} else if (texURL) {\n\n\t\t/// Load and add to shared array.\n\t\tfinalTexture = loadLocalTexture(localReader, texURL);\n\n\t\t/// Set standard texture functionality.\n\t\tfinalTexture.wrapT = THREE.RepeatWrapping;\n\t\tfinalTexture.wrapS = THREE.RepeatWrapping;\n\t\tfinalTexture.flipY = false;\n\n\t\tsharedTextures[texURL] = finalTexture;\n\t}\n\n\treturn finalTexture;\n}\n\n\n\n/**\n * Load image data into a THREE.Texture from a texture file in the .dat file, using a LocalReader.\n * If you're loading multiple textures, make sure to use\n * {{#crossLink \"MaterialUtils/getTexture\"}}{{/crossLink}} that allows you to cache textures.\n * \n * @memberof MaterialUtils\n * @param {LocalReader} localReader - The LocalReader to load the file contents from.\n * @param {Number} fileId - The fileId or baseId of the file to load image data from.\n * @param {Number} mapping - What THREE mapping the returned texture will use, not implemented.\n \n * @return {THREE.Texture} A texture that will be populated by the file data when it is loaded.\n */\nfunction loadLocalTexture(localReader, fileId, mapping, defaultColor, onerror) {\n\n\tif (defaultColor === undefined) {\n\t\tdefaultColor = Math.floor(0xffffff * Math.random())\n\t}\n\n\t/// Temporary texture that will be returned by the function.\n\t/// Color is randomized in order to differentiate different textures during loading.\n\tvar texture = generateDataTexture(\n\t\t1, // Width\n\t\t1, // Height\n\t\tnew THREE.Color(defaultColor) // Color\n\t);\n\n\t//Threejs r71 is using these settings by default, r72+ changed it\n\ttexture.minFilter = THREE.LinearMipMapLinearFilter;\n\ttexture.magFilter = THREE.LinearFilter;\n\ttexture.generateMipmaps = true;\n\ttexture.flipY = true;\n\n\t/// Only allow non-zero fileId, otherwise jsut return static texture\n\tif (parseInt(fileId) <= 0) {\n\t\tif (onerror)\n\t\t\tonerror();\n\t\treturn texture;\n\t}\n\n\t/// Load file using LocalReader.\n\tlocalReader.readFile(fileId, true, false, undefined, undefined, true)\n\t\t.then((result) => {\n\n\t\t\t/// Require infalted data to be returned.\n\t\t\tif (!result.buffer) {\n\t\t\t\tif (onerror)\n\t\t\t\t\tonerror();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t/// Create image using returned data.\n\t\t\tvar image = {\n\t\t\t\tdata: new Uint8Array(result.buffer),\n\t\t\t\twidth: result.imageWidth,\n\t\t\t\theight: result.imageHeight\n\t\t\t};\n\n\t\t\t/// Use RGBA for all textures for now...\n\t\t\t/// TODO: don't use alpha for some formats!\n\t\t\ttexture.format = (result.dxtType == 3 || result.dxtType == 5 || true) ? THREE.RGBAFormat : THREE.RGBFormat;\n\n\t\t\t/// Update texture with the loaded image.\n\t\t\ttexture.image = image;\n\t\t\ttexture.needsUpdate = true;\n\t\t});\n\n\t/// Return texture with temporary content.\n\treturn texture;\n};\n\nmodule.exports = {\n\tbuildVS: buildVS,\n\tgenerateDataTexture: generateDataTexture,\n\tbuildPS: buildPS,\n\tgetUVMat: getUVMat,\n\tgetMaterial: getMaterial,\n\tloadLocalTexture: loadLocalTexture\n}","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst base32Max = Math.pow(2, 32);\n\n/**\n * Collection Math and sorting methods\n * @namespace MathUtils\n */\n\n/**\n * Takes an integer and calculates what the 16 bit float\n * representation of the binary data used to read the integer is.\n *\n * @memberof MathUtils\n * @param  {Number} h Integer value\n * @return {Number} Float value\n */\nfunction f16(h) {\n    var s = (h & 0x8000) >> 15;\n    var e = (h & 0x7C00) >> 10;\n    var f = h & 0x03FF;\n\n    if (e == 0) {\n        return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));\n    } else if (e == 0x1F) {\n        return f ? NaN : ((s ? -1 : 1) * Infinity);\n    }\n\n    return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + (f / Math.pow(2, 10)));\n}\n\n/**\n * Calculates the number of binary ones present in the data used to\n * generate the input integer.\n * \n * @memberof MathUtils\n * @param  {Number} bits Integer\n * @return {Number}      Number of binary ones in the data\n */\nfunction popcount(bits) {\n    var SK5 = 0x55555555,\n        SK3 = 0x33333333,\n        SKF0 = 0x0f0f0f0f,\n        SKFF = 0xff00ff;\n\n    bits -= (bits >> 1) & SK5;\n    bits = (bits & SK3) + ((bits >> 2) & SK3);\n    bits = (bits & SKF0) + ((bits >> 4) & SKF0);\n    bits += bits >> 8;\n\n    return (bits + (bits >> 15)) & 63;\n}\n\n/**\n * Calculates the 64 bit integer value of two 32 bit integers. Only works up to \n * the limit of the javascript Number maximum value.\n * \n * @memberof MathUtils\n * @param  {Number[]} arr     Input integers, length should be 2.\n * @return {Number}      64 bit representation of the two integers.\n */\nfunction arr32To64(arr) {\n    /// Re-read as uint64 (still little endian)\n    /// Warn: this will not work for ~50+ bit longs cus all JS numbers are 64 bit floats...\n    return base32Max * arr[1] + arr[0];\n}\n\n/**\n * Sorts an array and returns unique values only.\n * \n * @memberof MathUtils\n * @param  {Array} arr_in     Input array\n * @param  {Function} comparator A comparator function between the objects in arr_in\n * @return {Array}            Sorted and unique value.\n */\nfunction sort_unique(arr_in, comparator) {\n    var arr = Array.prototype.sort.call(arr_in, comparator);\n\n    var u = {},\n        a = [];\n    for (var i = 0, l = arr.length; i < l; ++i) {\n        if (u.hasOwnProperty(arr[i])) {\n            continue;\n        }\n        a.push(arr[i]);\n        u[arr[i]] = 1;\n    }\n\n    return a;\n}\n\n\nmodule.exports = {\n    f16: f16,\n    popcount: popcount,\n    arr32To64: arr32To64,\n    sort_unique: sort_unique\n};","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nconst GW2File = require(\"../format/file/GW2File\");\nconst MaterialUtils = require(\"./MaterialUtils\");\nconst MathUtils = require(\"./MathUtils\");\n\n//TODO: Remove this local cache!!\nlet matFiles = {};\n\nconst fvfFormat = require('./Constants').fvfFormat;\n\n\n/**\n * Returns a THREE representation of the data contained by a GW2 model file.\n * The data is read using a LocalReader reference into the GW2 .dat.\n *\n * @memberof ModelUtils \n * @param {LocalReader} localReader The LocalReader to load the file contents from.\n * @param {Object} chunk Model GEOM chunk.\n * @param {Object} modelDataChunk Model MODL chunk.\n * @param {Object} sharedTextures  Value Object for keeping the texture cache.\n * @param {boolean} showUnmaterialed If false does not render any models with missing materials.\n * \n * @return {Array} Each geometry in the model file represented by a textured THREE.Mesh object\n */\nfunction renderGeomChunk(localReader, chunk, modelDataChunk, sharedTextures, showUnmaterialed) {\n\n\tvar rawMeshes = chunk.data.meshes;\n\tvar meshes = [];\n\tvar mats = modelDataChunk.data.permutations[0].materials;\n\n\tfor (let rawMesh of rawMeshes) {\n\n\t\tvar rawGeom = rawMesh.geometry;\n\t\tvar fvf = rawGeom.verts.mesh.fvf; //rawGeom.fvf;\n\n\t\tvar numVerts = rawGeom.verts.vertexCount; //rawGeom.vertexCount;\n\n\t\tvar rawVerts = rawGeom.verts.mesh.vertices; //rawGeom.vertices\n\n\t\tvar indices = rawGeom.indices.indices;\n\n\t\tvar geom = new THREE.BufferGeometry();\n\n\t\tvar vertDS = new DataStream(rawVerts.buffer);\n\n\t\t//Dirty step length for now:\n\t\tvar stride = rawVerts.length / numVerts;\n\n\t\t//Each vertex\n\t\t//DO UV as well\n\t\tvar vertices = new Float32Array(numVerts * 3);\n\t\tvar tangents = null;\n\t\tvar normals = null;\n\t\tvar uvs = [];\n\n\n\t\t/// Calculate the distance to the first pair of UV data from the\n\t\t/// start of the vertex entry\n\t\t/// \n\t\tvar distToNormals = !!(fvf & fvfFormat.Position) * 12 +\n\t\t\t!!(fvf & fvfFormat.Weights) * 4 +\n\t\t\t!!(fvf & fvfFormat.Group) * 4;\n\n\t\tvar distToTangent =\n\t\t\tdistToNormals +\n\t\t\t!!(fvf & fvfFormat.Normal) * 12 +\n\t\t\t!!(fvf & fvfFormat.Color) * 4;\n\n\t\tvar distToBittangent =\n\t\t\tdistToTangent +\n\t\t\t!!(fvf & fvfFormat.Tangent) * 12;\n\n\t\tvar distToTangentFrame = distToBittangent +\n\t\t\t!!(fvf & fvfFormat.Bitangent) * 12;\n\n\t\tvar distToUV =\n\t\t\tdistToTangentFrame +\n\t\t\t!!(fvf & fvfFormat.TangentFrame) * 12;\n\n\t\t/// Check if the UV is 32 bit float or 16 bit float.\n\t\tvar uv32Flag = (fvf & fvfFormat.UV32Mask) >> 8;\n\t\tvar uv16Flag = (fvf & fvfFormat.UV16Mask) >> 16;\n\t\tvar isUV32 = !!uv32Flag;\n\t\tvar hasUV = !!uv16Flag || !!uv32Flag;\n\n\t\t/// Popcount (count the number of binary 1's) in the UV flag\n\t\t/// to get the number of UV pairs used in this vertex format.\n\t\tvar masked = isUV32 ? uv32Flag : uv16Flag;\n\t\tvar numUV = MathUtils.popcount(masked);\n\n\t\tnumUV = Math.min(numUV, 1.0);\n\n\t\t/// Create typed UV arrays\n\t\tif (hasUV) {\n\t\t\tfor (var i = 0; i < numUV; i++) {\n\t\t\t\tuvs[i] = new Float32Array(numVerts * 2);\n\t\t\t}\n\t\t}\n\n\n\t\t// if (!!(fvf & fvfFormat.Normal)) {\n\t\t// \tconsole.log(\"HAS Normal\");\n\t\t// }\n\t\t// if (!!(fvf & fvfFormat.Tangent)) {\n\t\t// \tconsole.log(\"HAS Tangent\");\n\t\t// }\n\t\t// if (!!(fvf & fvfFormat.Bitangent)) {\n\t\t// \tconsole.log(\"HAS Bitangent\");\n\t\t// }\n\t\t// if (!!(fvf & fvfFormat.TangentFrame)) {\n\t\t// \tconsole.log(\"HAS TangentFrame\");\n\t\t// }\n\n\t\t/// Read data from each vertex data entry\n\t\tfor (var i = 0; i < numVerts; i++) {\n\n\t\t\t/// Go to vertex memory position\n\t\t\tvertDS.seek(i * stride);\n\n\t\t\t/// Read position data\n\t\t\t/// (we just hope all meshes has 32 bit position...)\n\t\t\tvar x = vertDS.readFloat32();\n\t\t\tvar z = vertDS.readFloat32();\n\t\t\tvar y = vertDS.readFloat32();\n\n\t\t\t/// Write position data, transformed to Tyria3D coordinate system.\n\t\t\tvertices[i * 3 + 0] = x; //- c.x;\n\t\t\tvertices[i * 3 + 1] = -y; //+ c.y;\n\t\t\tvertices[i * 3 + 2] = -z; //+ c.z;\n\n\t\t\t/// Read data at UV position\n\t\t\tif (hasUV) {\n\n\t\t\t\tfor (var uvIdx = 0; uvIdx < numUV; uvIdx++) {\n\n\t\t\t\t\tvertDS.seek(\n\t\t\t\t\t\ti * stride +\n\t\t\t\t\t\tdistToUV +\n\t\t\t\t\t\tuvIdx * (isUV32 ? 8 : 4)\n\t\t\t\t\t);\n\n\t\t\t\t\t/// Add one UV pair:\n\n\t\t\t\t\tvar u, v;\n\t\t\t\t\tif (isUV32) {\n\t\t\t\t\t\tu = vertDS.readUint32();\n\t\t\t\t\t\tv = vertDS.readUint32();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu = MathUtils.f16(vertDS.readUint16());\n\t\t\t\t\t\tv = MathUtils.f16(vertDS.readUint16());\n\t\t\t\t\t}\n\n\t\t\t\t\t/// Push to correct UV array\n\t\t\t\t\tuvs[uvIdx][i * 2 + 0] = u;\n\t\t\t\t\tuvs[uvIdx][i * 2 + 1] = v;\n\t\t\t\t}\n\n\n\t\t\t} /// End if has UV\n\n\t\t} /// End each vertex\n\n\t\t/// Each face descripbed in indices\n\t\tvar faces = new Uint16Array(indices.length);\n\t\tfor (var i = 0; i < indices.length; i += 3) {\n\n\t\t\t// This is ONE face\n\t\t\tfaces[i + 0] = indices[i + 2];\n\t\t\tfaces[i + 1] = indices[i + 1];\n\t\t\tfaces[i + 2] = indices[i + 0];\n\n\t\t} // End each index aka \"face\"\n\n\n\t\t/// Add position, index and uv props to buffered geometry\n\t\tgeom.addAttribute('position', new THREE.BufferAttribute(vertices, 3));\n\t\t//geom.addAttribute( 'index', new THREE.BufferAttribute( faces, 1) );\n\t\tgeom.setIndex(new THREE.BufferAttribute(faces, 1));\n\n\n\t\t/// Calculate normals\n\t\t/// Not all models have normals included, so we ask THREE to do the math at runtime.\n\t\tgeom.computeVertexNormals();\n\n\t\tif (hasUV) {\n\n\t\t\tfor (var uvIdx = 0; uvIdx < numUV; uvIdx++) {\n\n\t\t\t\t/// Names are \"uv\", \"uv2\", \"uv3\", ... , \"uvN\"\n\t\t\t\tvar uvName = \"uv\" + (uvIdx > 0 ? uvIdx + 1 : \"\");\n\n\t\t\t\t/// Set \"custom\" attribute uvN\n\t\t\t\tgeom.addAttribute(uvName, new THREE.BufferAttribute(uvs[uvIdx], 2));\n\n\t\t\t\t/// Flag for update\n\t\t\t\tgeom.attributes[uvName].needsUpdate = true;\n\t\t\t}\n\n\n\t\t\t/// Not needed anymore?\n\t\t\tgeom.uvsNeedUpdate = true;\n\t\t}\n\n\n\t\t/// Tell geometry to update its UVs and buffers\n\t\tgeom.buffersNeedUpdate = true;\n\n\t\t/// DONE READING VERTEX DATA\n\n\t\t/// Get material used for this mesh\n\t\tvar matIdx = rawMesh.materialIndex;\n\t\tvar mat = mats[matIdx];\n\t\tvar materialFile = null\n\n\t\tif (mat && matFiles[mat.filename]) {\n\t\t\tmaterialFile = matFiles[mat.filename];\n\t\t}\n\n\t\tvar finalMaterial = MaterialUtils.getMaterial(mat, materialFile, localReader, sharedTextures);\n\n\t\t/// IF we could not find a material abort OR use a wireframe placeholder.\n\t\tif (!finalMaterial) {\n\t\t\tif (showUnmaterialed) {\n\t\t\t\tfinalMaterial = new THREE.MeshLambertMaterial({\n\t\t\t\t\tcolor: 0x5bb1e8,\n\t\t\t\t\twireframe: false,\n\t\t\t\t\tside: THREE.DoubleSide\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t}\n\n\t\t/// Create the final mesh from the BufferedGeometry and MeshBasicMaterial\n\t\tvar finalMesh = new THREE.Mesh(geom, finalMaterial);\n\n\t\t/// Set material info on the returned mesh\n\t\tif (mat) {\n\t\t\tfinalMesh.materialFlags = mat.materialFlags;\n\t\t\tfinalMesh.materialFilename = mat.filename;\n\t\t}\n\n\t\tfinalMesh.materialName = rawMesh.materialName;\n\n\t\t/// Use materialFilename, materialName, and material.textureFilename in order to build export\n\n\t\t/// Set lod info on the returned mesh\n\t\tfinalMesh.numLods = rawMesh.geometry.lods.length;\n\t\tfinalMesh.lodOverride = modelDataChunk.data.lodOverride;\n\n\t\t/// Set flag and UV info on the returned mehs\n\t\tfinalMesh.flags = rawMesh.flags;\n\t\tfinalMesh.numUV = numUV;\n\n\t\t/// Add mesh to returned Array\n\t\tmeshes.push(finalMesh);\n\n\t} /// End rawMeshes forEach\n\n\treturn meshes;\n}\n\n/**\n * Loads mesh array from Model file and sends as argument to callback.\n * \n * @memberof ModelUtils\n * @async\n * @param  {Number} filename Name of the model file to load data from.\n * @param  {Array} solidColor RGBA array of 4 integers\n * @param {LocalReader} localReader The LocalReader to load the file contents from.\n * @param {Object} sharedTextures  Value Object for keeping the texture cache.\n * @param {boolean} showUnmaterialed If false does not render any models with missing materials.\n \n * @param  {Function} callback Fired once all meshes have been loaded.\n * two arguments are passed to the callback function.\n * \n * The first argument is an Array with each textured THREE.Mesh objects.\n * \n * The second argument is the bounding spehere of this model file.\n * \n */\n\nfunction loadMeshFromModelFile(filename, solidColor, localReader, sharedTextures, showUnmaterialed, hideLOD, callback) {\n\n\t//Short handles prop attributes\n\tvar finalMeshes = [];\n\n\t///Load file\n\tlocalReader.readFile(filename, false, false, undefined, undefined, true).then((result) => {\n\t\tlet inflatedData = result.buffer;\n\n\t\ttry {\n\t\t\tif (!inflatedData) {\n\t\t\t\tthrow \"Could not find MFT entry for \" + filename;\n\t\t\t}\n\n\t\t\tvar ds = new DataStream(inflatedData);\n\n\t\t\tvar modelFile = new GW2File(ds, 0);\n\n\t\t\t//MODL for materials -> textures\n\t\t\tvar modelDataChunk = modelFile.getChunk(\"modl\");\n\n\t\t\t//GEOM for geometry\n\t\t\tvar geometryDataChunk = modelFile.getChunk(\"geom\");\n\n\t\t\t/// Hacky fix for not being able to adjust for position\n\t\t\tvar boundingSphere = modelDataChunk.data.boundingSphere;\n\t\t\tvar bsc = boundingSphere.center;\n\t\t\tboundingSphere.radius += Math.sqrt(bsc[0] * bsc[0] + Math.sqrt(bsc[1] * bsc[1] + bsc[2] * bsc[2]));\n\n\t\t\t/// Load all material files\n\t\t\tvar allMats = modelDataChunk.data.permutations[0].materials;\n\n\t\t\tfunction loadMaterialIndex(mIdx, matCallback) {\n\n\t\t\t\tif (mIdx >= allMats.length) {\n\n\t\t\t\t\tmatCallback();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar mat = allMats[mIdx];\n\n\t\t\t\t/// Skip if file is loaded\n\t\t\t\tif (matFiles[mat.filename]) {\n\t\t\t\t\tloadMaterialIndex(mIdx + 1, matCallback);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tlocalReader.readFile(mat.filename, false, false, undefined, undefined, true)\n\t\t\t\t\t.then((result) => {\n\t\t\t\t\t\tlet inflatedData = result.buffer;\n\t\t\t\t\t\tif (inflatedData) {\n\t\t\t\t\t\t\tvar ds = new DataStream(inflatedData);\n\t\t\t\t\t\t\tvar materialFile = new GW2File(ds, 0);\n\t\t\t\t\t\t\tmatFiles[mat.filename] = materialFile;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tloadMaterialIndex(mIdx + 1, matCallback);\n\n\t\t\t\t\t});\n\t\t\t}\n\n\n\n\t\t\tloadMaterialIndex(0, function () {\n\n\t\t\t\t/// Create meshes\n\t\t\t\tvar meshes = renderGeomChunk(localReader, geometryDataChunk, modelDataChunk, sharedTextures, showUnmaterialed);\n\n\t\t\t\t// Build mesh group\n\t\t\t\tfor (let mesh of meshes) {\n\n\t\t\t\t\tvar texMask = 0x8 + 0x0800;\n\n\t\t\t\t\t//Must have texture\n\t\t\t\t\tif (!showUnmaterialed && !(mesh.materialFlags & texMask)) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\t//Hide LOD meshes if hideLOD is true\n\t\t\t\t\tif (hideLOD && (mesh.flags == 4 || mesh.flags == 1)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\t//Add to final colection\n\t\t\t\t\tfinalMeshes.push(mesh);\n\n\t\t\t\t} /// END FOR EACH meshes\n\n\t\t\t\tcallback(finalMeshes, boundingSphere);\n\n\n\t\t\t}); /// END LOAD MATERIALS CALLBACK\n\n\n\t\t} catch (e) {\n\t\t\tconsole.warn(\"Failed rendering model \" + filename, e);\n\t\t\tvar mesh = new THREE.Mesh(new THREE.BoxGeometry(200, 2000, 200), new THREE.MeshNormalMaterial());\n\t\t\tmesh.flags = 4;\n\t\t\tmesh.materialFlags = 2056;\n\t\t\tmesh.lodOverride = [1000000, 1000000];\n\t\t\tfinalMeshes.push(mesh);\n\n\t\t\t/// Send the final meshes to callback function\n\t\t\tcallback(finalMeshes);\n\t\t}\n\n\t}); /// END FILE LOADED CALLBACK FUNCTION\n}\n\n\n/**\n * Gets a mesh array from Model file and sends as argument to callback. Uses a cache of meshes in order\n * to never read the same model file twice.\n * \n * @memberof ModelUtils\n * @async\n * @param  {Number} filename The fileId or baseId of the Model file to load\n * @param  {Array} color RGBA array of 4 integers\n * @param  {LocalReader} localReader The LocalReader object used to read data from the GW2 .dat file.\n * @param {Object} sharedMeshes  Value Object for keeping the texture cache.\n * @param {Object} sharedTextures  Value Object for keeping the texture cache.\n * @param {boolean} showUnmaterialed If false does not render any models with missing materials.\n * @param  {Function} callback Fired once all meshes have been loaded.\n * three arguments are passed to the callback function.\n * \n * The first argument is an Array with each textured THREE.Mesh objects.\n *\n * The second argument is a boolean, true indicates that these meshes were not\n * loaded from the dat file, but retrieved from the run time cache.\n * \n * The third argument is the bounding spehere of this model file.\n */\nfunction getMeshesForFilename(filename, color, localReader, sharedMeshes, sharedTextures, showUnmaterialed, hideLOD, callback) {\n\n\t/// If this file has already been loaded, just return a reference to the meshes.\n\t/// isCached will be set to true to inform the caller the meshes will probably\n\t/// have to be cloned in some way.\n\tif (sharedMeshes[filename]) {\n\t\tcallback(sharedMeshes[filename].meshes, true, sharedMeshes[filename].boundingSphere)\n\t}\n\n\t/// If this file has never been loaded, load it using loadMeshFromModelFile\n\t/// the resulting mesh array will be cached within this model's scope.\n\telse {\n\n\t\tloadMeshFromModelFile(filename, color, localReader, sharedTextures, showUnmaterialed, hideLOD, function (meshes, boundingSphere) {\n\n\t\t\t/// Cache result if any.\n\t\t\tif (meshes) {\n\t\t\t\tsharedMeshes[filename] = {\n\t\t\t\t\tmeshes: meshes,\n\t\t\t\t\tboundingSphere: boundingSphere\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/// Allways fire callback.\n\t\t\tcallback(meshes, false, boundingSphere);\n\n\t\t});\n\t}\n}\n\n\n/**\n * WIP, Tries to find all fileIds refered by a model file.\n * \n * @memberof ModelUtils\n * @async\n * @param  {Number}   filename    Model file Id\n * @param  {LocalReader}   localReader LocalReader instance to read from\n * @param  {Function} callback   First argument is list of used file IDs\n */\nfunction getFilesUsedByModel(filename, localReader, callback) {\n\tvar fileIds = [filename];\n\n\t///Load model file\n\tlocalReader.readFile(filename, false, false, undefined, undefined, true).then((result) => {\n\t\tlet inflatedData = result.buffer;\n\n\t\ttry {\n\t\t\tif (!inflatedData) {\n\t\t\t\tthrow \"Could not find MFT entry for \" + filename;\n\t\t\t}\n\n\t\t\tvar ds = new DataStream(inflatedData);\n\t\t\tvar modelFile = new GW2File(ds, 0);\n\n\t\t\t//MODL for materials -> textures\n\t\t\tvar modelDataChunk = modelFile.getChunk(\"modl\");\n\n\t\t\t/// Get materials used by model\n\t\t\tvar mats = modelDataChunk.data.permutations[0].materials;\n\n\t\t\t/// Add each material file AND referenced TEXTURES\n\t\t\tfor (let mat of mats) {\n\n\t\t\t\t/// Add material file id\n\t\t\t\tvar matFileName = mat.filename;\n\t\t\t\tfileIds.push(matFileName);\n\n\t\t\t\t/// Add each texture file id\n\t\t\t\tmat.textures.forEach(function (tex) {\n\t\t\t\t\tfileIds.push(tex.filename);\n\t\t\t\t})\n\n\t\t\t}\n\n\t\t} catch (e) {\n\t\t\tconsole.warn(\"Could not export any data\", e);\n\t\t}\n\n\t\tcallback(fileIds);\n\t});\n\n}\n\nmodule.exports = {\n\trenderGeomChunk: renderGeomChunk,\n\tgetMeshesForFilename: getMeshesForFilename,\n\tgetFilesUsedByModel: getFilesUsedByModel\n};","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * @namespace ParserUtils\n */\n\n/**\n * Collection of methods used for parsing complex data types from the .dat\n *\n * Most of these methods are only refered by the automatically generated script\n * AllFormats.js\n * \n */\n\nmodule.exports = {\n\n\t/**\n\t * Generates a function for reading an array using DataStream\n\t * \n\t * @param  {Array} structDef DataStream formatted structure definition\n\t *                           for the items in the array.\n\t * @param  {Number} maxCount The maximum allowed length of the array.\n\t *                           Allows any length if left unspecified.\n\t * @return {Function}        The generated parsing function.\n\t */\n\tgetArrayReader: function (structDef, maxCount) {\n\t\treturn function (ds, struct) {\n\t\t\tvar ret = [];\n\t\t\ttry {\n\n\t\t\t\tvar arr_len = ds.readUint32();\n\t\t\t\tvar offset = ds.readUint32();\n\t\t\t\tif (offset == 0) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t\tvar arr_ptr = ds.position - 4 + offset;\n\t\t\t\tvar pos = ds.position;\n\n\t\t\t\tif (maxCount && arr_len > maxCount) {\n\t\t\t\t\tthrow (\"Array length \" + arr_len + \" exceeded allowed maximum \" + maxCount);\n\t\t\t\t}\n\n\t\t\t\tvar pos = ds.position;\n\n\n\t\t\t\tds.seek(arr_ptr);\n\t\t\t\tret = ds.readType(['[]', structDef, arr_len], struct);\n\t\t\t\tds.seek(pos);\n\t\t\t} catch (e) {\n\t\t\t\tconsole.warn(\"getArrayReader Failed loading array\", e);\n\t\t\t\tconsole.warn(\"getArrayReader Failed loading array, structDef\", structDef);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t},\n\n\t/**\n\t * Generates a function for reading a refered array using DataStream\n\t * \n\t * @param  {Array} structDef DataStream formatted structure definition\n\t *                           for the items in the array.\n\t * @return {Function}        The generated parsing function.\n\t */\n\tgetRefArrayReader: function (structDef) {\n\t\treturn function (ds, struct) {\n\n\t\t\tvar ret_arr = [];\n\n\t\t\t/// Read array of offsets\n\t\t\tvar arr_len = ds.readUint32();\n\t\t\tvar arr_ptr = ds.position + ds.readUint32();\n\n\t\t\tif (arr_len == 0) {\n\t\t\t\treturn ret_arr;\n\t\t\t}\n\n\t\t\tvar orgPos = ds.position;\n\n\t\t\t/// Go to pointer and read an array of offsets!\n\t\t\tds.seek(arr_ptr);\n\t\t\tvar offsets = ds.readInt32Array(arr_len);\n\n\n\t\t\t//p_data is after having read array\n\t\t\t//var pointer = p_data - 4;\n\t\t\tvar pointer = orgPos - 4;\n\n\t\t\t//auto offset  = *reinterpret_cast<const int32*>(pointer);\n\t\t\tds.seek(pointer);\n\t\t\tvar offset = ds.readUint32(); /// this should be the same as arr_ptr\n\n\t\t\t//pointer     += offset;\n\t\t\tpointer += offset;\n\n\t\t\tfor (var i = 0; i < offsets.length; i++) {\n\n\n\t\t\t\tif (offsets[i] != 0) {\n\n\t\t\t\t\tvar pos = pointer + i * 4 + offsets[i];\n\t\t\t\t\tds.seek(pos);\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tret_arr.push(ds.readStruct(structDef));\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t//debugger;\n\t\t\t\t\t\tret_arr.push(null);\n\t\t\t\t\t\tconsole.warn(\"getRefArrayReader could not find refered data at offset\", offsets[i], e);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} /// End for each offset\n\n\t\t\tds.seek(orgPos);\n\t\t\treturn ret_arr;\n\n\n\t\t}\n\t},\n\n\n\t/**\n\t * Generates a function for reading a 64bit initeger. For now just reads each\n\t * 32 bit integer and glues together as a string.\n\t * \n\t * @return {Function}        The generated parsing function.\n\t */\n\tgetQWordReader: function () {\n\t\tvar base32Max = 4294967296;\n\t\treturn function (ds, struct) {\n\t\t\treturn ds.readUint32() + \"-\" + ds.readUint32();\n\n\t\t\tvar p0 = ds.readUint32();\n\t\t\tvar p1 = ds.readUint32();\n\t\t\treturn base32Max * p1 + p0;\n\t\t}\n\n\t},\n\n\t/**\n\t * Generates a function for reading a string of 8 bit chars.\n\t * \n\t * @return {Function}        The generated parsing function.\n\t */\n\tgetStringReader: function () {\n\t\treturn function (ds, struct) {\n\t\t\tvar ptr = ds.position + ds.readUint32();\n\t\t\tvar pos = ds.position;\n\n\t\t\t/// Go to pointer\n\t\t\tds.seek(ptr);\n\n\t\t\tvar ret = ds.readCString();\n\n\t\t\t/// Go back to where we were\n\t\t\tds.seek(pos);\n\n\t\t\treturn ret;\n\t\t}\n\t},\n\n\t/**\n\t * Generates a function for reading a string of 16 bit chars.\n\t * \n\t * @return {Function}        The generated parsing function.\n\t */\n\tgetString16Reader: function (stringOffset) {\n\t\treturn function (ds, struct) {\n\t\t\tvar ptr = ds.position + ds.readUint32() + (stringOffset ? stringOffset : 0);\n\t\t\tvar pos = ds.position;\n\n\t\t\t/// Go to pointer\n\t\t\tds.seek(ptr);\n\n\t\t\tvar ret = \"\";\n\t\t\tvar num;\n\t\t\twhile (ds.position + 2 < ds.byteLength && (num = ds.readUint16()) != 0) {\n\t\t\t\tret += String.fromCharCode(num);\n\t\t\t}\n\t\t\t//ds.readCString();\n\n\t\t\t/// Go back to where we were\n\t\t\tds.seek(pos);\n\n\t\t\treturn ret;\n\t\t}\n\t},\n\n\n\t/**\n\t * Generates a function for reading a pointer.\n\t * \n\t * @param  {Array} structDef DataStream formatted structure definition\n\t *                           for the item pointed to.\n\t * @return {Function}        The generated parsing function.\n\t */\n\tgetPointerReader: function (structDef) {\n\t\treturn function (ds, struct) {\n\t\t\tvar offset = ds.readUint32();\n\n\t\t\tif (offset == 0) {\n\t\t\t\treturn {};\n\t\t\t}\n\n\t\t\tvar ptr = ds.position - 4 + offset;\n\t\t\tvar pos = ds.position;\n\n\t\t\t/// Go to pointer\n\t\t\tds.seek(ptr);\n\n\t\t\tvar ret = ds.readStruct(structDef);\n\n\t\t\t/// Go back to where we were\n\t\t\tds.seek(pos);\n\n\n\t\t\treturn ret;\n\t\t}\n\t},\n\n\t/**\n\t * Generates a function for reading a filename/file Id.\n\t * \n\t * @return {Function}        The generated parsing function.\n\t */\n\tgetFileNameReader: function () {\n\t\treturn function (ds, struct) {\n\t\t\ttry {\n\t\t\t\tvar ptr = ds.position + ds.readUint32();\n\t\t\t\tvar pos = ds.position;\n\n\t\t\t\t/// Go to pointer\n\t\t\t\tds.seek(ptr);\n\n\t\t\t\tvar fileRef = ds.readStruct([\n\t\t\t\t\t\"m_lowPart\", \"uint16\", //uint16 m_lowPart;\n\t\t\t\t\t\"m_highPart\", \"uint16\", //uint16 m_highPart;\n\t\t\t\t\t\"m_terminator\", \"uint16\", //uint16 m_terminator;\n\t\t\t\t]);\n\n\n\t\t\t\t/// Getting the file name...\n\t\t\t\t/// Both need to be >= than 256 (terminator is 0)\n\t\t\t\tvar ret = 0xFF00 * (fileRef.m_highPart - 0x100) + (fileRef.m_lowPart - 0x100) + 1;\n\t\t\t\t//var ret = (fileRef.m_highPart - 0x100) * 0xff00 + (fileRef.m_lowPart - 0xff);\n\n\t\t\t\tif (ret < 0) {\n\t\t\t\t\tret = 0;\n\t\t\t\t\t//console.log(\"FR negative\", fileRef.m_highPart, fileRef.m_lowPart, fileRef.m_terminator);\n\t\t\t\t\t//debugger;\n\t\t\t\t}\n\n\t\t\t\t/// Go back to where we were\n\t\t\t\tds.seek(pos);\n\n\t\t\t\treturn ret;\n\t\t\t} catch (e) {\n\t\t\t\t/// Go back to where we were\n\t\t\t\tds.seek(pos);\n\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n}","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/**\n * Collection of methods used for generating THREE meshes from Guild Wars 2 data formats.\n * @namespace RenderUtils\n */\n\n\n/**\n * Creates a mesh representing a single plane.\n * \n * @memberof RenderUtils\n * @param  {Object} rect     An object with x1,x2,y1 and y2 properties.\n * @param  {Number} yPos     Vertical position of the rectangle.\n * @param  {THREE.Material} material \tMesh material to apply.\n * @param  {Number} dy       Mesh height.\n * @return {THREE.Mesh}      The generated mesh.\n */\nfunction renderRect(rect, yPos, material, dy) {\n    var dx = rect.x1 - rect.x2;\n    var dz = rect.y1 - rect.y2;\n    if (!dy)\n        dy = 1;\n\n    var cx = (rect.x1 + rect.x2) / 2;\n    var cz = (rect.y1 + rect.y2) / 2;\n    var cy = yPos;\n\n    var geometry = new THREE.BoxGeometry(dx, dy, dz);\n\n\n    material = material || new THREE.MeshBasicMaterial({\n        color: 0xff0000,\n        wireframe: true,\n    });\n    var plane = new THREE.Mesh(geometry, material);\n    plane.overdraw = true;\n\n    plane.position.x = cx;\n    plane.position.y = cy;\n    plane.position.z = cz;\n\n    return plane;\n};\n\nmodule.exports = {\n    renderRect: renderRect\n}","/*\nCopyright  Tyria3DLibrary project contributors\n\nThis file is part of the Tyria 3D Library.\n\nTyria 3D Library is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nTyria 3D Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with the Tyria 3D Library. If not, see <http://www.gnu.org/licenses/>.\n*/\n\nmodule.exports = {\n    ///TODO: port fog from in-engine\n\n    getFragmentShader: function () {\n        return [\n            \"uniform vec2 uvScale;\",\n            \"uniform vec2 offset;\",\n            \"uniform sampler2D texturePicker;\",\n            \"uniform sampler2D texturePicker2;\",\n            \"uniform sampler2D texture1;\",\n            \"uniform sampler2D texture2;\",\n            \"uniform sampler2D texture3;\",\n            \"uniform sampler2D texture4;\",\n\n            THREE.ShaderChunk[\"logdepthbuf_pars_fragment\"],\n\n            \"varying vec2 vUv;\",\n            \"varying vec3 vecNormal;\",\n\n            \"vec3 blend(\",\n            \"vec4 texture1, float a1, vec4 texture2, float a2,\",\n            \"vec4 texture3, float a3, vec4 texture4, float a4)\",\n            \"{\",\n            \"float depth = 2.0;\",\n            \"float alphaMult = 1.0;\",\n            \"float alphaAdd  = 0.0;\",\n            \"a1 *= 4.0;\",\n            \"a2 *= 4.0;\",\n            \"a3 *= 4.0;\",\n            \"a4 *= 4.0;\",\n            \"a1 =  a1+(1.5+texture1.a);\",\n            \"a2 =  a2+(1.5+texture2.a);\",\n            \"a3 =  a3+(1.5+texture3.a);\",\n            \"a4 =  a4+(1.5+texture4.a);\",\n            \"float ma = max(a1,a2);\",\n            \"ma = max(ma,a3);\",\n            \"ma = max(ma,a4);\",\n            \"ma -= depth;\",\n            \"float b1 = max(a1 - ma, 0.0);\",\n            \"float b2 = max(a2 - ma, 0.0);\",\n            \"float b3 = max(a3 - ma, 0.0);\",\n            \"float b4 = max(a4 - ma, 0.0);\",\n            \"return (\",\n            \"texture1.rgb * b1 + texture2.rgb * b2 +\",\n            \"texture3.rgb * b3 + texture4.rgb * b4 \",\n            \") / (b1 + b2 + b3 + b4);\",\n            \"}\",\n\n            \"void main( void ) {\",\n            \"vec2 position = vUv*uvScale;\",\n            \"float edge = 1.0/1024.0;\",\n            \"vec2 compPos = edge + (vUv*0.25 + offset) * (1.0-edge*2.0);\",\n            \"vec4 tp1 = texture2D( texturePicker, compPos);\",\n            \"vec4 tp2 = texture2D( texturePicker2, compPos);\",\n            \"vec4 composite = tp1;\",\n            \"vec4 t1 = texture2D( texture1, position );\",\n            \"vec4 t2 = texture2D( texture2, position );\",\n            \"vec4 t3 = texture2D( texture3, position );\",\n            \"vec4 t4 = texture2D( texture4, position );\",\n            \"vec3 color = blend(\",\n            \"t1, tp1.a,\",\n            \"t2, tp1.b,\",\n            \"t3, tp1.g,\",\n            \"t4, tp1.r\",\n            \");\",\n            \"color *= 0.5+tp2.r;\",\n            \"gl_FragColor = vec4(color,1.0);\",\n            THREE.ShaderChunk[\"logdepthbuf_fragment\"],\n            \"}\"\n\n        ].join(\"\\n\");\n    },\n    getVertexShader: function () {\n        return [\n            \"varying vec2 vUv;\",\n            \"varying vec3 vecNormal;\",\n            THREE.ShaderChunk[\"logdepthbuf_pars_vertex\"],\n            \"void main()\",\n            \"{\",\n\n            \"vUv =  uv;\",\n            \"vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\",\n            \"vecNormal = (modelMatrix * vec4(normal, 0.0)).xyz;\",\n            \"gl_Position = projectionMatrix * mvPosition;\",\n            THREE.ShaderChunk[\"logdepthbuf_vertex\"],\n            \"}\"\n        ].join(\"\\n\");\n    }\n}"]}